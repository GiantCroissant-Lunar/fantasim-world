// Generated by combine_cs.py on 2026-01-30T14:49:14Z
// Source root: project/
// Tests excluded: yes

// --- PATH: contracts/Geosphere.Plate.Cache.Contracts/ArtifactGenerationContext.cs ---
using FantaSim.Geosphere.Plate.Topology.Contracts.Identity;

namespace FantaSim.Geosphere.Plate.Cache.Contracts;

/// <summary>
/// Context passed to artifact generators.
/// </summary>
public sealed record ArtifactGenerationContext(
    TruthStreamIdentity Stream,
    long LastSequence,
    string InputFingerprint);


// --- PATH: contracts/Geosphere.Plate.Cache.Contracts/CacheLookupResult.cs ---
using FantaSim.Geosphere.Plate.Cache.Contracts.Models;

namespace FantaSim.Geosphere.Plate.Cache.Contracts;

/// <summary>
/// Represents the outcome of a derived artifact cache lookup.
/// </summary>
public readonly record struct CacheLookupResult(
    bool IsHit,
    byte[]? Payload,
    Manifest? Manifest,
    string? InputFingerprint)
{
    public static CacheLookupResult Hit(byte[] payload, Manifest manifest, string inputFingerprint)
    {
        ArgumentNullException.ThrowIfNull(payload);
        ArgumentException.ThrowIfNullOrWhiteSpace(inputFingerprint);
        return new CacheLookupResult(true, payload, manifest, inputFingerprint);
    }

    public static CacheLookupResult Miss(string inputFingerprint)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(inputFingerprint);
        return new CacheLookupResult(false, null, null, inputFingerprint);
    }
}


// --- PATH: contracts/Geosphere.Plate.Cache.Contracts/IArtifactCacheStore.cs ---
using FantaSim.Geosphere.Plate.Cache.Contracts.Models;
using FantaSim.Geosphere.Plate.Topology.Contracts.Identity;

namespace FantaSim.Geosphere.Plate.Cache.Contracts;

/// <summary>
/// High-level contract for derived artifact cache stores.
/// </summary>
public interface IArtifactCacheStore
{
    Task<Manifest?> GetManifestAsync(string key, CancellationToken ct);

    Task<byte[]?> GetPayloadAsync(string key, CancellationToken ct);

    Task StoreAsync(string manifestKey, Manifest manifest, string payloadKey, byte[] payload, CancellationToken ct);

    Task DeleteAsync(string manifestKey, string payloadKey, CancellationToken ct);

    IAsyncEnumerable<string> EnumerateKeysAsync(string prefix, CancellationToken ct);
}


// --- PATH: contracts/Geosphere.Plate.Cache.Contracts/IArtifactGenerator.cs ---
namespace FantaSim.Geosphere.Plate.Cache.Contracts;

public interface IArtifactGenerator<T>
{
    string GeneratorId { get; }

    string GeneratorVersion { get; }

    Task<T> GenerateAsync(ArtifactGenerationContext context, CancellationToken ct);

    byte[] Serialize(T artifact);

    T Deserialize(byte[] data);
}


// --- PATH: contracts/Geosphere.Plate.Cache.Contracts/IDerivedArtifactCache.cs ---
using FantaSim.Geosphere.Plate.Topology.Contracts.Identity;

namespace FantaSim.Geosphere.Plate.Cache.Contracts;

public interface IDerivedArtifactCache
{
    Task<CacheLookupResult> GetOrCreateArtifactAsync<T>(
        TruthStreamIdentity stream,
        string productType,
        long lastSequence,
        string generatorId,
        string generatorVersion,
        Dictionary<string, object> parameters,
        IArtifactGenerator<T> generator,
        CancellationToken ct);
}


// --- PATH: contracts/Geosphere.Plate.Cache.Contracts/Models/Boundary.cs ---
using MessagePack;

namespace FantaSim.Geosphere.Plate.Cache.Contracts.Models;

/// <summary>
/// Boundary specification for derived artifacts.
/// </summary>
[MessagePackObject]
public readonly record struct Boundary(
    [property: Key(0)] string Kind,
    [property: Key(1)] ulong LastSequence
)
{
    /// <summary>
    /// Creates a sequence-based boundary.
    /// </summary>
    public static Boundary Sequence(ulong lastSequence) =>
        new("sequence", lastSequence);

    /// <summary>
    /// Validates the boundary specification.
    /// </summary>
    public void Validate()
    {
        if (string.IsNullOrWhiteSpace(Kind))
            throw new ArgumentException("Kind cannot be null or empty", nameof(Kind));

        if (Kind != "sequence")
            throw new ArgumentException("Only 'sequence' boundary kind is supported in v1", nameof(Kind));
    }
}


// --- PATH: contracts/Geosphere.Plate.Cache.Contracts/Models/ExternalStorageInfo.cs ---
using MessagePack;

namespace FantaSim.Geosphere.Plate.Cache.Contracts.Models;

/// <summary>
/// External storage details for artifacts stored outside the main key-value store.
/// </summary>
[MessagePackObject]
public readonly record struct ExternalStorageInfo(
    [property: Key(0)] string Uri,
    [property: Key(1)] string? ETag,
    [property: Key(2)] string? Backend
)
{
    /// <summary>
    /// Validates the external storage specification.
    /// </summary>
    public void Validate()
    {
        if (string.IsNullOrWhiteSpace(Uri))
            throw new ArgumentException("Uri cannot be null or empty", nameof(Uri));

        // Validate URI format
        if (!Uri.Contains("://"))
            throw new ArgumentException("Uri must be a valid URI with scheme (e.g., s3://, file://)", nameof(Uri));
    }
}


// --- PATH: contracts/Geosphere.Plate.Cache.Contracts/Models/FingerprintEnvelope.cs ---
using MessagePack;

namespace FantaSim.Geosphere.Plate.Cache.Contracts.Models;

/// <summary>
/// FingerprintEnvelope is encoded as a MessagePack array (not map) with fields in exact positional order.
///
/// Array structure:
/// [
///   source_stream (str),      // position 0
///   boundary_kind (str),      // position 1
///   last_sequence (uint64),   // position 2
///   generator_id (str),       // position 3
///   generator_version (str),  // position 4
///   params_hash (str)         // position 5 (lowercase hex)
/// ]
///
/// Array marker: 0x96 (fixarray with 6 elements)
/// </summary>
[MessagePackObject]
public readonly record struct FingerprintEnvelope(
    [property: Key(0)] string SourceStream,
    [property: Key(1)] string BoundaryKind,
    [property: Key(2)] ulong LastSequence,
    [property: Key(3)] string GeneratorId,
    [property: Key(4)] string GeneratorVersion,
    [property: Key(5)] string ParamsHash
)
{
    /// <summary>
    /// Validates that all fields are well-formed.
    /// </summary>
    public void Validate()
    {
        if (string.IsNullOrWhiteSpace(SourceStream))
            throw new ArgumentException("SourceStream cannot be null or empty", nameof(SourceStream));

        if (string.IsNullOrWhiteSpace(BoundaryKind))
            throw new ArgumentException("BoundaryKind cannot be null or empty", nameof(BoundaryKind));

        if (string.IsNullOrWhiteSpace(GeneratorId))
            throw new ArgumentException("GeneratorId cannot be null or empty", nameof(GeneratorId));

        if (string.IsNullOrWhiteSpace(GeneratorVersion))
            throw new ArgumentException("GeneratorVersion cannot be null or empty", nameof(GeneratorVersion));

        if (string.IsNullOrWhiteSpace(ParamsHash))
            throw new ArgumentException("ParamsHash cannot be null or empty", nameof(ParamsHash));

        // Validate params_hash format (64 lowercase hex characters)
        if (ParamsHash.Length != 64)
            throw new ArgumentException("ParamsHash must be 64 characters (SHA-256 hex)", nameof(ParamsHash));

        foreach (var c in ParamsHash)
        {
            if (!IsLowercaseHexChar(c))
                throw new ArgumentException("ParamsHash must be lowercase hexadecimal", nameof(ParamsHash));
        }
    }

    private static bool IsLowercaseHexChar(char c) =>
        (c >= '0' && c <= '9') || (c >= 'a' && c <= 'f');
}


// --- PATH: contracts/Geosphere.Plate.Cache.Contracts/Models/GeneratorInfo.cs ---
using MessagePack;

namespace FantaSim.Geosphere.Plate.Cache.Contracts.Models;

/// <summary>
/// Generator specification for derived artifacts.
/// </summary>
[MessagePackObject]
public readonly record struct GeneratorInfo(
    [property: Key(0)] string Id,
    [property: Key(1)] string Version
)
{
    /// <summary>
    /// Validates the generator specification.
    /// </summary>
    public void Validate()
    {
        if (string.IsNullOrWhiteSpace(Id))
            throw new ArgumentException("Id cannot be null or empty", nameof(Id));

        if (string.IsNullOrWhiteSpace(Version))
            throw new ArgumentException("Version cannot be null or empty", nameof(Version));
    }
}


// --- PATH: contracts/Geosphere.Plate.Cache.Contracts/Models/Manifest.cs ---
using MessagePack;

namespace FantaSim.Geosphere.Plate.Cache.Contracts.Models;

/// <summary>
/// Manifest metadata record describing a derived artifact.
///
/// Required Fields:
/// - schema_version (int): Schema version, starts at 1
/// - product_type (str): Must equal product type in the key
/// - input_fingerprint (str): Must equal fingerprint in the key
/// - source_stream (str): Full stream identity string
/// - boundary (map): Boundary specification
/// - generator (map): Generator specification
/// - params_hash (str): Lowercase hex SHA-256 of params
/// - storage (map): Storage specification
///
/// Optional Fields:
/// - created_at_utc (str): ISO-8601 UTC timestamp
/// - meta (map): Freeform metadata
/// - external (map): External storage details
/// - params (map): Full params object (for debugging)
/// </summary>
[MessagePackObject]
public readonly record struct Manifest(
    // Required fields
    [property: Key(0)] int SchemaVersion,
    [property: Key(1)] string ProductType,
    [property: Key(2)] string InputFingerprint,
    [property: Key(3)] string SourceStream,
    [property: Key(4)] Boundary Boundary,
    [property: Key(5)] GeneratorInfo Generator,
    [property: Key(6)] string ParamsHash,
    [property: Key(7)] StorageInfo Storage,

    // Optional fields (nullable)
    [property: Key(8)] string? CreatedAtUtc,
    [property: Key(9)] Dictionary<string, object>? Meta,
    [property: Key(10)] ExternalStorageInfo? External,
    [property: Key(11)] Dictionary<string, object>? Params
)
{
    /// <summary>
    /// Current manifest schema version.
    /// </summary>
    public const int CurrentSchemaVersion = 1;

    /// <summary>
    /// Creates a new manifest with required fields.
    /// </summary>
    public static Manifest Create(
        string productType,
        string inputFingerprint,
        string sourceStream,
        Boundary boundary,
        GeneratorInfo generator,
        string paramsHash,
        StorageInfo storage)
    {
        return new Manifest(
            SchemaVersion: CurrentSchemaVersion,
            ProductType: productType,
            InputFingerprint: inputFingerprint,
            SourceStream: sourceStream,
            Boundary: boundary,
            Generator: generator,
            ParamsHash: paramsHash,
            Storage: storage,
            CreatedAtUtc: null,
            Meta: null,
            External: null,
            Params: null
        );
    }

    /// <summary>
    /// Validates the manifest according to the schema.
    /// </summary>
    public void Validate()
    {
        if (SchemaVersion != CurrentSchemaVersion)
            throw new ArgumentException($"SchemaVersion must be {CurrentSchemaVersion}", nameof(SchemaVersion));

        if (string.IsNullOrWhiteSpace(ProductType))
            throw new ArgumentException("ProductType cannot be null or empty", nameof(ProductType));

        if (string.IsNullOrWhiteSpace(InputFingerprint))
            throw new ArgumentException("InputFingerprint cannot be null or empty", nameof(InputFingerprint));

        // Validate input_fingerprint format (64 lowercase hex characters)
        if (InputFingerprint.Length != 64)
            throw new ArgumentException("InputFingerprint must be 64 characters (SHA-256 hex)", nameof(InputFingerprint));

        foreach (var c in InputFingerprint)
        {
            if (!IsLowercaseHexChar(c))
                throw new ArgumentException("InputFingerprint must be lowercase hexadecimal", nameof(InputFingerprint));
        }

        if (string.IsNullOrWhiteSpace(SourceStream))
            throw new ArgumentException("SourceStream cannot be null or empty", nameof(SourceStream));

        Boundary.Validate();
        Generator.Validate();

        if (string.IsNullOrWhiteSpace(ParamsHash))
            throw new ArgumentException("ParamsHash cannot be null or empty", nameof(ParamsHash));

        // Validate params_hash format
        if (ParamsHash.Length != 64)
            throw new ArgumentException("ParamsHash must be 64 characters (SHA-256 hex)", nameof(ParamsHash));

        foreach (var c in ParamsHash)
        {
            if (!IsLowercaseHexChar(c))
                throw new ArgumentException("ParamsHash must be lowercase hexadecimal", nameof(ParamsHash));
        }

        Storage.Validate();

        // If storage mode is external, external info is required
        if (Storage.Mode == StorageMode.External && External == null)
            throw new ArgumentException("External storage info is required when Storage.Mode is External", nameof(External));

        External?.Validate();
    }

    private static bool IsLowercaseHexChar(char c) =>
        (c >= '0' && c <= '9') || (c >= 'a' && c <= 'f');
}


// --- PATH: contracts/Geosphere.Plate.Cache.Contracts/Models/StorageInfo.cs ---
using MessagePack;

namespace FantaSim.Geosphere.Plate.Cache.Contracts.Models;

/// <summary>
/// Storage mode discriminator.
/// </summary>
public enum StorageMode
{
    Embedded,
    External
}

/// <summary>
/// Storage specification for derived artifacts.
/// </summary>
[MessagePackObject]
public readonly record struct StorageInfo(
    [property: Key(0)] StorageMode Mode,
    [property: Key(1)] string ContentHash,
    [property: Key(2)] ulong ContentLength
)
{
    /// <summary>
    /// Creates an embedded storage specification.
    /// </summary>
    public static StorageInfo Embedded(string contentHash, ulong contentLength) =>
        new(StorageMode.Embedded, contentHash, contentLength);

    /// <summary>
    /// Creates an external storage specification.
    /// </summary>
    public static StorageInfo External(string contentHash, ulong contentLength) =>
        new(StorageMode.External, contentHash, contentLength);

    /// <summary>
    /// Validates the storage specification.
    /// </summary>
    public void Validate()
    {
        if (string.IsNullOrWhiteSpace(ContentHash))
            throw new ArgumentException("ContentHash cannot be null or empty", nameof(ContentHash));

        // Validate content_hash format (64 lowercase hex characters)
        if (ContentHash.Length != 64)
            throw new ArgumentException("ContentHash must be 64 characters (SHA-256 hex)", nameof(ContentHash));

        foreach (var c in ContentHash)
        {
            if (!IsLowercaseHexChar(c))
                throw new ArgumentException("ContentHash must be lowercase hexadecimal", nameof(ContentHash));
        }
    }

    private static bool IsLowercaseHexChar(char c) =>
        (c >= '0' && c <= '9') || (c >= 'a' && c <= 'f');
}


// --- PATH: contracts/Geosphere.Plate.Datasets.Contracts/Canonicalization/DeterministicIdPolicy.cs ---
using System.Globalization;
using System.Security.Cryptography;
using System.Text;

namespace FantaSim.Geosphere.Plate.Datasets.Contracts.Canonicalization;

public static class DeterministicIdPolicy
{
    public static Guid DeriveEventId(string datasetId, string assetId, long sequence)
    {
        return DeriveStableGuid(datasetId, assetId, sequence.ToString(CultureInfo.InvariantCulture));
    }

    public static Guid DeriveStableId(string datasetId, string assetId, string kind, string key)
    {
        return DeriveStableGuid(datasetId, assetId, kind, key);
    }

    private static Guid DeriveStableGuid(params string[] parts)
    {
        if (parts.Length == 0)
            throw new ArgumentException("At least one part is required.", nameof(parts));

        foreach (var p in parts)
            ArgumentNullException.ThrowIfNull(p);

        var material = string.Join("\n", parts);
        var bytes = Encoding.UTF8.GetBytes(material);

        Span<byte> hash = stackalloc byte[32];
        SHA256.HashData(bytes, hash);

        Span<byte> rfcBytes = stackalloc byte[16];
        hash[..16].CopyTo(rfcBytes);

        rfcBytes[6] = (byte)((rfcBytes[6] & 0x0F) | 0x40);
        rfcBytes[8] = (byte)((rfcBytes[8] & 0x3F) | 0x80);

        Span<byte> guidBytes = stackalloc byte[16];
        guidBytes[0] = rfcBytes[3];
        guidBytes[1] = rfcBytes[2];
        guidBytes[2] = rfcBytes[1];
        guidBytes[3] = rfcBytes[0];
        guidBytes[4] = rfcBytes[5];
        guidBytes[5] = rfcBytes[4];
        guidBytes[6] = rfcBytes[7];
        guidBytes[7] = rfcBytes[6];
        rfcBytes[8..].CopyTo(guidBytes[8..]);

        return new Guid(guidBytes);
    }
}


// --- PATH: contracts/Geosphere.Plate.Datasets.Contracts/Ingest/IPlatesDatasetIngestor.cs ---
using FantaSim.Geosphere.Plate.Datasets.Contracts.Loading;

namespace FantaSim.Geosphere.Plate.Datasets.Contracts.Ingest;

public interface IPlatesDatasetIngestor
{
    Task<PlatesDatasetIngestResult> IngestAsync(
        string datasetRootPath,
        PlatesDatasetIngestSpec spec,
        PlatesDatasetLoadOptions? loadOptions,
        CancellationToken cancellationToken);
}


// --- PATH: contracts/Geosphere.Plate.Datasets.Contracts/Ingest/IngestMode.cs ---
namespace FantaSim.Geosphere.Plate.Datasets.Contracts.Ingest;

public enum IngestMode
{
    AssetOnly = 0,
    Ingest = 1
}


// --- PATH: contracts/Geosphere.Plate.Datasets.Contracts/Ingest/PlatesAssetIngestTarget.cs ---
using FantaSim.Geosphere.Plate.Datasets.Contracts.Loading;
using FantaSim.Geosphere.Plate.Topology.Contracts.Identity;
using UnifySerialization.Abstractions;

namespace FantaSim.Geosphere.Plate.Datasets.Contracts.Ingest;

[UnifyModel]
public sealed record PlatesAssetIngestTarget(
    [property: UnifyProperty(0)] PlatesAssetKind Kind,
    [property: UnifyProperty(1)] string AssetId,
    [property: UnifyProperty(2)] TruthStreamIdentity StreamIdentity
);


// --- PATH: contracts/Geosphere.Plate.Datasets.Contracts/Ingest/PlatesDatasetIngestAudit.cs ---
using UnifySerialization.Abstractions;

namespace FantaSim.Geosphere.Plate.Datasets.Contracts.Ingest;

[UnifyModel]
public sealed record PlatesDatasetIngestAudit(
    [property: UnifyProperty(0)] string DatasetId,
    [property: UnifyProperty(1)] string BodyId,
    [property: UnifyProperty(2)] string ManifestFileName,
    [property: UnifyProperty(3)] string ManifestFileSha256,
    [property: UnifyProperty(4)] string ManifestCanonicalSha256,
    [property: UnifyProperty(5)] string StableIdPolicyId,
    [property: UnifyProperty(6)] string AssetOrderingPolicyId,
    [property: UnifyProperty(7)] string QuantizationPolicyId,
    [property: UnifyProperty(8)] PlatesDatasetIngestAssetAudit[] Assets,
    [property: UnifyProperty(9)] PlatesDatasetIngestTargetAudit[] Targets,
    [property: UnifyProperty(10)] PlatesDatasetIngestStreamAudit[] Streams,
    [property: UnifyProperty(11)] string AuditSha256);

[UnifyModel]
public sealed record PlatesDatasetIngestAssetAudit(
    [property: UnifyProperty(0)] string AssetId,
    [property: UnifyProperty(1)] string Kind,
    [property: UnifyProperty(2)] string RelativePath,
    [property: UnifyProperty(3)] string Format,
    [property: UnifyProperty(4)] string FileSha256);

[UnifyModel]
public sealed record PlatesDatasetIngestTargetAudit(
    [property: UnifyProperty(0)] string AssetId,
    [property: UnifyProperty(1)] string Kind,
    [property: UnifyProperty(2)] string StreamKey);

[UnifyModel]
public sealed record PlatesDatasetIngestStreamAudit(
    [property: UnifyProperty(0)] string StreamKey,
    [property: UnifyProperty(1)] int EventCount,
    [property: UnifyProperty(2)] long FirstSequence,
    [property: UnifyProperty(3)] long LastSequence,
    [property: UnifyProperty(4)] string EventIdDigestSha256);


// --- PATH: contracts/Geosphere.Plate.Datasets.Contracts/Ingest/PlatesDatasetIngestResult.cs ---
using FantaSim.Geosphere.Plate.Datasets.Contracts.Loading;
using FantaSim.Geosphere.Plate.Datasets.Contracts.Validation;
using FantaSim.Geosphere.Plate.Topology.Contracts.Identity;

namespace FantaSim.Geosphere.Plate.Datasets.Contracts.Ingest;

public sealed record PlatesDatasetIngestResult(
    IPlatesDataset? Dataset,
    IReadOnlyList<TruthStreamIdentity> ProducedStreams,
    PlatesDatasetIngestAudit? Audit,
    IReadOnlyList<DatasetValidationError> Errors)
{
    public bool IsSuccess => Dataset is not null && Errors.Count == 0;
}


// --- PATH: contracts/Geosphere.Plate.Datasets.Contracts/Ingest/PlatesDatasetIngestSpec.cs ---
using UnifySerialization.Abstractions;

namespace FantaSim.Geosphere.Plate.Datasets.Contracts.Ingest;

[UnifyModel]
public sealed record PlatesDatasetIngestSpec(
    [property: UnifyProperty(0)] IngestMode Mode,
    [property: UnifyProperty(1)] PlatesAssetIngestTarget[] Targets
);


// --- PATH: contracts/Geosphere.Plate.Datasets.Contracts/Loading/IPlatesDataset.cs ---
using FantaSim.Geosphere.Plate.Datasets.Contracts.Manifest;

namespace FantaSim.Geosphere.Plate.Datasets.Contracts.Loading;

public interface IPlatesDataset
{
    string DatasetRootPath { get; }

    PlatesDatasetManifest Manifest { get; }

    IReadOnlyList<ResolvedAsset> Assets { get; }
}


// --- PATH: contracts/Geosphere.Plate.Datasets.Contracts/Loading/IPlatesDatasetLoader.cs ---
namespace FantaSim.Geosphere.Plate.Datasets.Contracts.Loading;

public interface IPlatesDatasetLoader
{
    Task<PlatesDatasetLoadResult> LoadAsync(
        string datasetRootPath,
        PlatesDatasetLoadOptions? options,
        CancellationToken cancellationToken);
}


// --- PATH: contracts/Geosphere.Plate.Datasets.Contracts/Loading/PlatesAssetKind.cs ---
namespace FantaSim.Geosphere.Plate.Datasets.Contracts.Loading;

public enum PlatesAssetKind
{
    FeatureSet = 0,
    RasterSequence = 1,
    MotionModel = 2
}


// --- PATH: contracts/Geosphere.Plate.Datasets.Contracts/Loading/PlatesDatasetLoadOptions.cs ---
namespace FantaSim.Geosphere.Plate.Datasets.Contracts.Loading;

public sealed record PlatesDatasetLoadOptions(
    bool ValidateOnly = false,
    string ManifestFileName = "plates.dataset.json");


// --- PATH: contracts/Geosphere.Plate.Datasets.Contracts/Loading/PlatesDatasetLoadResult.cs ---
using FantaSim.Geosphere.Plate.Datasets.Contracts.Validation;

namespace FantaSim.Geosphere.Plate.Datasets.Contracts.Loading;

public sealed record PlatesDatasetLoadResult(
    IPlatesDataset? Dataset,
    IReadOnlyList<DatasetValidationError> Errors)
{
    public bool IsSuccess => Dataset is not null && Errors.Count == 0;
}


// --- PATH: contracts/Geosphere.Plate.Datasets.Contracts/Loading/ResolvedAsset.cs ---
using UnifySerialization.Abstractions;

namespace FantaSim.Geosphere.Plate.Datasets.Contracts.Loading;

[UnifyModel]
public sealed record ResolvedAsset(
    [property: UnifyProperty(0)] PlatesAssetKind Kind,
    [property: UnifyProperty(1)] string AssetId,
    [property: UnifyProperty(2)] string AbsolutePath,
    [property: UnifyProperty(3)] string Format
);


// --- PATH: contracts/Geosphere.Plate.Datasets.Contracts/Manifest/BodyFrame.cs ---
using UnifySerialization.Abstractions;

namespace FantaSim.Geosphere.Plate.Datasets.Contracts.Manifest;

public enum BodyShape
{
    Sphere = 0,
    Ellipsoid = 1
}

[UnifyModel]
public sealed record BodyFrame(
    [property: UnifyProperty(0)] BodyShape Shape,
    [property: UnifyProperty(1)] double? Radius,
    [property: UnifyProperty(2)] double? SemiMajor,
    [property: UnifyProperty(3)] double? SemiMinor,
    [property: UnifyProperty(4)] string Unit,
    [property: UnifyProperty(5)] string AngularConvention
);


// --- PATH: contracts/Geosphere.Plate.Datasets.Contracts/Manifest/CanonicalizationRules.cs ---
using UnifySerialization.Abstractions;

namespace FantaSim.Geosphere.Plate.Datasets.Contracts.Manifest;

[UnifyModel]
public sealed record CanonicalizationRules(
    [property: UnifyProperty(0)] int Version,
    [property: UnifyProperty(1)] string StableIdPolicyId,
    [property: UnifyProperty(2)] string AssetOrderingPolicyId,
    [property: UnifyProperty(3)] string QuantizationPolicyId
);


// --- PATH: contracts/Geosphere.Plate.Datasets.Contracts/Manifest/FeatureSetAsset.cs ---
using UnifySerialization.Abstractions;

namespace FantaSim.Geosphere.Plate.Datasets.Contracts.Manifest;

[UnifyModel]
public sealed record FeatureSetAsset(
    [property: UnifyProperty(0)] string AssetId,
    [property: UnifyProperty(1)] string RelativePath,
    [property: UnifyProperty(2)] string Format
);


// --- PATH: contracts/Geosphere.Plate.Datasets.Contracts/Manifest/MotionModelAsset.cs ---
using UnifySerialization.Abstractions;

namespace FantaSim.Geosphere.Plate.Datasets.Contracts.Manifest;

[UnifyModel]
public sealed record MotionModelAsset(
    [property: UnifyProperty(0)] string AssetId,
    [property: UnifyProperty(1)] string RelativePath,
    [property: UnifyProperty(2)] string Format
);


// --- PATH: contracts/Geosphere.Plate.Datasets.Contracts/Manifest/PlatesDatasetManifest.cs ---
using UnifySerialization.Abstractions;

namespace FantaSim.Geosphere.Plate.Datasets.Contracts.Manifest;

[UnifyModel]
public sealed record PlatesDatasetManifest(
    [property: UnifyProperty(0)] string DatasetId,
    [property: UnifyProperty(1)] string BodyId,
    [property: UnifyProperty(2)] BodyFrame BodyFrame,
    [property: UnifyProperty(3)] TimeMapping TimeMapping,
    [property: UnifyProperty(4)] FeatureSetAsset[] FeatureSets,
    [property: UnifyProperty(5)] RasterSequenceAsset[] RasterSequences,
    [property: UnifyProperty(6)] MotionModelAsset[] MotionModels,
    [property: UnifyProperty(7)] CanonicalizationRules CanonicalizationRules
);


// --- PATH: contracts/Geosphere.Plate.Datasets.Contracts/Manifest/RasterSequenceAsset.cs ---
using UnifySerialization.Abstractions;

namespace FantaSim.Geosphere.Plate.Datasets.Contracts.Manifest;

[UnifyModel]
public sealed record RasterSequenceAsset(
    [property: UnifyProperty(0)] string AssetId,
    [property: UnifyProperty(1)] string RelativePath,
    [property: UnifyProperty(2)] string Format
);


// --- PATH: contracts/Geosphere.Plate.Datasets.Contracts/Manifest/TimeMapping.cs ---
using UnifySerialization.Abstractions;

namespace FantaSim.Geosphere.Plate.Datasets.Contracts.Manifest;

[UnifyModel]
public sealed record TimeMapping(
    [property: UnifyProperty(0)] string TickUnit
);


// --- PATH: contracts/Geosphere.Plate.Datasets.Contracts/Validation/DatasetValidationError.cs ---
using UnifySerialization.Abstractions;

namespace FantaSim.Geosphere.Plate.Datasets.Contracts.Validation;

[UnifyModel]
public sealed record DatasetValidationError(
    [property: UnifyProperty(0)] string Code,
    [property: UnifyProperty(1)] string Path,
    [property: UnifyProperty(2)] string Message);


// --- PATH: contracts/Geosphere.Plate.Datasets.Contracts/Validation/PlatesDatasetManifestValidator.cs ---
using System.IO;
using FantaSim.Geosphere.Plate.Datasets.Contracts.Manifest;

namespace FantaSim.Geosphere.Plate.Datasets.Contracts.Validation;

public static class PlatesDatasetManifestValidator
{
    private const string StableIdPolicyIdV1 = "sha256-guid-v1";
    private const string AssetOrderingPolicyIdV1 = "kind_assetId_path-v1";
    private const string QuantizationPolicyIdV1 = "euler_microdegrees-v1";

    /// <summary>
    /// Allowed angular conventions for planet-agnostic coordinate systems.
    /// RFC-V2-0032 requires explicit declaration; implicit Earth CRS is forbidden.
    /// </summary>
    private static readonly HashSet<string> AllowedAngularConventions = new(StringComparer.OrdinalIgnoreCase)
    {
        // v1 formats (existing usage)
        "body_lonlat_degrees",
        "body_lonlat_radians",
        "body_cartesian",
        // Versioned formats (recommended)
        "body-lonlat-degrees-v1",
        "body-lonlat-radians-v1",
        "body-cartesian-v1",
        "planetographic-lonlat-degrees-v1",
        "planetocentric-lonlat-degrees-v1"
    };

    /// <summary>
    /// Patterns that indicate implicit Earth CRS assumptions.
    /// RFC-V2-0032 §2.1: MUST NOT assume WGS84, EPSG:4326, or any implicit Earth CRS.
    /// </summary>
    private static readonly string[] RejectedEarthCrsPatterns =
    [
        "epsg:",
        "wgs84",
        "wgs-84",
        "crs84",
        "crs-84",
        "ogc:crs84",
        "urn:ogc:",
        "proj:"
    ];

    /// <summary>
    /// Allowed unit identifiers for body frame dimensions.
    /// </summary>
    private static readonly HashSet<string> AllowedUnits = new(StringComparer.OrdinalIgnoreCase)
    {
        "m",
        "km",
        "au",
        "mi",
        "nmi"
    };

    public static IReadOnlyList<DatasetValidationError> Validate(PlatesDatasetManifest manifest)
    {
        ArgumentNullException.ThrowIfNull(manifest);

        var errors = new List<DatasetValidationError>();

        if (string.IsNullOrWhiteSpace(manifest.DatasetId))
            errors.Add(new DatasetValidationError("dataset_id.required", "datasetId", "DatasetId is required."));

        if (string.IsNullOrWhiteSpace(manifest.BodyId))
            errors.Add(new DatasetValidationError("body_id.required", "bodyId", "BodyId is required."));

        if (manifest.BodyFrame is null)
        {
            errors.Add(new DatasetValidationError("body_frame.required", "bodyFrame", "BodyFrame is required."));
        }
        else
        {
            ValidateBodyFrame(manifest.BodyFrame, errors);
        }

        if (manifest.TimeMapping is null)
        {
            errors.Add(new DatasetValidationError("time_mapping.required", "timeMapping", "TimeMapping is required."));
        }
        else
        {
            if (string.IsNullOrWhiteSpace(manifest.TimeMapping.TickUnit))
            {
                errors.Add(new DatasetValidationError("tick_unit.required", "timeMapping.tickUnit", "TickUnit is required."));
            }
            else if (!string.Equals(manifest.TimeMapping.TickUnit, "CTU", StringComparison.OrdinalIgnoreCase))
            {
                errors.Add(new DatasetValidationError("tick_unit.invalid", "timeMapping.tickUnit", "TickUnit must be CTU."));
            }
        }

        if (manifest.CanonicalizationRules is null)
        {
            errors.Add(new DatasetValidationError("canonicalization_rules.required", "canonicalizationRules", "CanonicalizationRules is required."));
        }
        else
        {
            ValidateCanonicalizationRules(manifest.CanonicalizationRules, errors);
        }

        ValidateAssets(manifest, errors);

        errors.Sort(static (a, b) =>
        {
            var c = string.Compare(a.Code, b.Code, StringComparison.Ordinal);
            if (c != 0)
                return c;

            c = string.Compare(a.Path, b.Path, StringComparison.Ordinal);
            if (c != 0)
                return c;

            return string.Compare(a.Message, b.Message, StringComparison.Ordinal);
        });

        return errors;
    }

    private static void ValidateCanonicalizationRules(CanonicalizationRules rules, List<DatasetValidationError> errors)
    {
        if (rules.Version <= 0)
        {
            errors.Add(new DatasetValidationError("canonicalization_rules.version.invalid", "canonicalizationRules.version", "CanonicalizationRules.Version must be > 0."));
            return;
        }

        if (rules.Version != 1)
        {
            errors.Add(new DatasetValidationError("canonicalization_rules.version.unsupported", "canonicalizationRules.version", "CanonicalizationRules.Version is not supported."));
            return;
        }

        if (string.IsNullOrWhiteSpace(rules.StableIdPolicyId))
            errors.Add(new DatasetValidationError("canonicalization_rules.stable_id_policy_id.required", "canonicalizationRules.stableIdPolicyId", "CanonicalizationRules.StableIdPolicyId is required."));

        if (string.IsNullOrWhiteSpace(rules.AssetOrderingPolicyId))
            errors.Add(new DatasetValidationError("canonicalization_rules.asset_ordering_policy_id.required", "canonicalizationRules.assetOrderingPolicyId", "CanonicalizationRules.AssetOrderingPolicyId is required."));

        if (string.IsNullOrWhiteSpace(rules.QuantizationPolicyId))
            errors.Add(new DatasetValidationError("canonicalization_rules.quantization_policy_id.required", "canonicalizationRules.quantizationPolicyId", "CanonicalizationRules.QuantizationPolicyId is required."));

        if (!string.Equals(rules.StableIdPolicyId, StableIdPolicyIdV1, StringComparison.Ordinal))
            errors.Add(new DatasetValidationError("canonicalization_rules.stable_id_policy_id.invalid", "canonicalizationRules.stableIdPolicyId", "CanonicalizationRules.StableIdPolicyId is invalid."));

        if (!string.Equals(rules.AssetOrderingPolicyId, AssetOrderingPolicyIdV1, StringComparison.Ordinal))
            errors.Add(new DatasetValidationError("canonicalization_rules.asset_ordering_policy_id.invalid", "canonicalizationRules.assetOrderingPolicyId", "CanonicalizationRules.AssetOrderingPolicyId is invalid."));

        if (!string.Equals(rules.QuantizationPolicyId, QuantizationPolicyIdV1, StringComparison.Ordinal))
            errors.Add(new DatasetValidationError("canonicalization_rules.quantization_policy_id.invalid", "canonicalizationRules.quantizationPolicyId", "CanonicalizationRules.QuantizationPolicyId is invalid."));
    }

    private static void ValidateBodyFrame(BodyFrame bodyFrame, List<DatasetValidationError> errors)
    {
        // Validate Unit (required + whitelist)
        if (string.IsNullOrWhiteSpace(bodyFrame.Unit))
        {
            errors.Add(new DatasetValidationError("body_frame.unit.required", "bodyFrame.unit", "BodyFrame.Unit is required."));
        }
        else if (!AllowedUnits.Contains(bodyFrame.Unit))
        {
            errors.Add(new DatasetValidationError(
                "body_frame.unit.invalid",
                "bodyFrame.unit",
                $"BodyFrame.Unit '{bodyFrame.Unit}' is not recognized. Allowed values: {string.Join(", ", AllowedUnits)}."));
        }

        // Validate AngularConvention (required + whitelist + reject Earth CRS)
        if (string.IsNullOrWhiteSpace(bodyFrame.AngularConvention))
        {
            errors.Add(new DatasetValidationError("body_frame.angular_convention.required", "bodyFrame.angularConvention", "BodyFrame.AngularConvention is required."));
        }
        else
        {
            // RFC-V2-0032 §2.1: Reject implicit Earth CRS patterns
            var conventionLower = bodyFrame.AngularConvention.ToLowerInvariant();
            foreach (var pattern in RejectedEarthCrsPatterns)
            {
                if (conventionLower.Contains(pattern, StringComparison.Ordinal))
                {
                    errors.Add(new DatasetValidationError(
                        "body_frame.angular_convention.earth_crs_rejected",
                        "bodyFrame.angularConvention",
                        $"BodyFrame.AngularConvention '{bodyFrame.AngularConvention}' appears to reference an implicit Earth CRS. " +
                        "RFC-V2-0032 requires planet-agnostic coordinate declarations. Use an allowed convention instead."));
                    break;
                }
            }

            // Validate against allowed conventions whitelist
            if (!AllowedAngularConventions.Contains(bodyFrame.AngularConvention))
            {
                errors.Add(new DatasetValidationError(
                    "body_frame.angular_convention.invalid",
                    "bodyFrame.angularConvention",
                    $"BodyFrame.AngularConvention '{bodyFrame.AngularConvention}' is not recognized. " +
                    $"Allowed values: {string.Join(", ", AllowedAngularConventions)}."));
            }
        }

        switch (bodyFrame.Shape)
        {
            case BodyShape.Sphere:
                if (!bodyFrame.Radius.HasValue || bodyFrame.Radius.Value <= 0)
                    errors.Add(new DatasetValidationError("body_frame.radius.required", "bodyFrame.radius", "BodyFrame.Radius must be > 0 for spheres."));
                if (bodyFrame.SemiMajor.HasValue)
                    errors.Add(new DatasetValidationError("body_frame.semi_major.unexpected", "bodyFrame.semiMajor", "SemiMajor must be null for spheres."));
                if (bodyFrame.SemiMinor.HasValue)
                    errors.Add(new DatasetValidationError("body_frame.semi_minor.unexpected", "bodyFrame.semiMinor", "SemiMinor must be null for spheres."));
                break;

            case BodyShape.Ellipsoid:
                if (!bodyFrame.SemiMajor.HasValue || bodyFrame.SemiMajor.Value <= 0)
                    errors.Add(new DatasetValidationError("body_frame.semi_major.required", "bodyFrame.semiMajor", "SemiMajor must be > 0 for ellipsoids."));
                if (!bodyFrame.SemiMinor.HasValue || bodyFrame.SemiMinor.Value <= 0)
                    errors.Add(new DatasetValidationError("body_frame.semi_minor.required", "bodyFrame.semiMinor", "SemiMinor must be > 0 for ellipsoids."));
                if (bodyFrame.Radius.HasValue)
                    errors.Add(new DatasetValidationError("body_frame.radius.unexpected", "bodyFrame.radius", "Radius must be null for ellipsoids."));
                break;

            default:
                errors.Add(new DatasetValidationError("body_frame.shape.invalid", "bodyFrame.shape", "BodyFrame.Shape is invalid."));
                break;
        }
    }

    private static void ValidateAssets(PlatesDatasetManifest manifest, List<DatasetValidationError> errors)
    {
        var featureSets = manifest.FeatureSets ?? Array.Empty<FeatureSetAsset>();
        var rasterSequences = manifest.RasterSequences ?? Array.Empty<RasterSequenceAsset>();
        var motionModels = manifest.MotionModels ?? Array.Empty<MotionModelAsset>();

        var assetIds = new Dictionary<string, int>(StringComparer.Ordinal);

        ValidateAssetIds(featureSets.Select(a => (a.AssetId, "featureSets")), assetIds, errors);
        ValidateAssetIds(rasterSequences.Select(a => (a.AssetId, "rasterSequences")), assetIds, errors);
        ValidateAssetIds(motionModels.Select(a => (a.AssetId, "motionModels")), assetIds, errors);

        ValidateAssetPaths(featureSets.Select(a => (a.RelativePath, "featureSets")), errors);
        ValidateAssetPaths(rasterSequences.Select(a => (a.RelativePath, "rasterSequences")), errors);
        ValidateAssetPaths(motionModels.Select(a => (a.RelativePath, "motionModels")), errors);

        ValidateAssetFormats(featureSets.Select(a => (a.Format, "featureSets")), errors);
        ValidateAssetFormats(rasterSequences.Select(a => (a.Format, "rasterSequences")), errors);
        ValidateAssetFormats(motionModels.Select(a => (a.Format, "motionModels")), errors);
    }

    private static void ValidateAssetIds(IEnumerable<(string AssetId, string Group)> ids, Dictionary<string, int> seen, List<DatasetValidationError> errors)
    {
        var index = 0;
        foreach (var (assetId, group) in ids)
        {
            var path = $"{group}[{index}].assetId";
            if (string.IsNullOrWhiteSpace(assetId))
            {
                errors.Add(new DatasetValidationError("asset_id.required", path, "AssetId is required."));
            }
            else if (!seen.TryAdd(assetId, 1))
            {
                errors.Add(new DatasetValidationError("asset_id.duplicate", path, "AssetId must be unique across all assets."));
            }

            index++;
        }
    }

    private static void ValidateAssetPaths(IEnumerable<(string RelativePath, string Group)> paths, List<DatasetValidationError> errors)
    {
        var index = 0;
        foreach (var (relativePath, group) in paths)
        {
            var path = $"{group}[{index}].relativePath";
            if (string.IsNullOrWhiteSpace(relativePath))
            {
                errors.Add(new DatasetValidationError("asset_path.required", path, "RelativePath is required."));
            }
            else if (Path.IsPathRooted(relativePath))
            {
                errors.Add(new DatasetValidationError("asset_path.rooted", path, "RelativePath must be a relative path."));
            }

            index++;
        }
    }

    private static void ValidateAssetFormats(IEnumerable<(string Format, string Group)> formats, List<DatasetValidationError> errors)
    {
        var index = 0;
        foreach (var (format, group) in formats)
        {
            var path = $"{group}[{index}].format";
            if (string.IsNullOrWhiteSpace(format))
            {
                errors.Add(new DatasetValidationError("asset_format.required", path, "Format is required."));
            }

            index++;
        }
    }
}


// --- PATH: contracts/Geosphere.Plate.Junction.Contracts/Diagnostics/JunctionClosureDiagnostic.cs ---
﻿using System.Collections.Immutable;
using MessagePack;
using FantaSim.Geosphere.Plate.Topology.Contracts.Entities;
using FantaSim.Geosphere.Plate.Velocity.Contracts;
using UnifyGeometry;

namespace FantaSim.Geosphere.Plate.Junction.Contracts.Diagnostics;

/// <summary>
/// Kinematic closure diagnostic for a junction (RFC-V2-0042 §7.1).
/// </summary>
/// <remarks>
/// <para>
/// At a triple junction where plates A, B, C meet, the relative velocities must close:
/// <code>v_AB + v_BC + v_CA = 0</code>
/// </para>
/// <para>
/// The <see cref="Residual"/> is the magnitude of the closure error.
/// Non-zero residual indicates inconsistent rotation poles or topology/kinematics mismatch.
/// </para>
/// </remarks>
[MessagePackObject]
public readonly record struct JunctionClosureDiagnostic(
    /// <summary>The junction being diagnosed.</summary>
    [property: Key(0)] JunctionId JunctionId,

    /// <summary>Junction position in body frame coordinates.</summary>
    [property: Key(1)] Point3 Position,

    /// <summary>The closure residual vector (should be near zero for consistent kinematics).</summary>
    [property: Key(2)] Velocity3d Residual,

    /// <summary>Magnitude of the residual vector.</summary>
    [property: Key(3)] double ResidualMagnitude,

    /// <summary>Relative velocities between incident plates (for debugging).</summary>
    [property: Key(4)] ImmutableArray<PlateRelativeVelocity> RelativeVelocities,

    /// <summary>True if residual is below the closure tolerance.</summary>
    [property: Key(5)] bool IsClosed
);


// --- PATH: contracts/Geosphere.Plate.Junction.Contracts/Diagnostics/JunctionDiagnostics.cs ---
﻿using System.Collections.Immutable;
using MessagePack;
using FantaSim.Geosphere.Plate.Junction.Contracts.Products;
using Plate.TimeDete.Time.Primitives;

namespace FantaSim.Geosphere.Plate.Junction.Contracts.Diagnostics;

/// <summary>
/// Complete diagnostic result for junction analysis (RFC-V2-0042 §7.2).
/// </summary>
[MessagePackObject]
public readonly record struct JunctionDiagnostics(
    /// <summary>The tick at which diagnostics were computed.</summary>
    [property: Key(0)] CanonicalTick Tick,

    /// <summary>Closure diagnostics for all junctions with available kinematics.</summary>
    [property: Key(1)] ImmutableArray<JunctionClosureDiagnostic> ClosureDiagnostics,

    /// <summary>Junctions that could not be processed (e.g., missing kinematics, invalid topology).</summary>
    [property: Key(2)] ImmutableArray<JunctionInfo> InvalidJunctions,

    /// <summary>Total number of junctions analyzed.</summary>
    [property: Key(3)] int TotalJunctions,

    /// <summary>Number of junctions with closed kinematics (residual below tolerance).</summary>
    [property: Key(4)] int ClosedJunctions,

    /// <summary>Number of junctions with unclosed kinematics (residual above tolerance).</summary>
    [property: Key(5)] int UnclosedJunctions
)
{
    /// <summary>
    /// Closure ratio: proportion of analyzed junctions that are kinematically closed.
    /// </summary>
    [IgnoreMember]
    public double ClosureRatio => TotalJunctions > 0
        ? (double)ClosedJunctions / TotalJunctions
        : 1.0;

    /// <summary>
    /// True if all analyzed junctions are kinematically closed.
    /// </summary>
    [IgnoreMember]
    public bool AllClosed => UnclosedJunctions == 0;
}


// --- PATH: contracts/Geosphere.Plate.Junction.Contracts/Diagnostics/PlateRelativeVelocity.cs ---
﻿using MessagePack;
using FantaSim.Geosphere.Plate.Topology.Contracts.Entities;
using FantaSim.Geosphere.Plate.Velocity.Contracts;

namespace FantaSim.Geosphere.Plate.Junction.Contracts.Diagnostics;

/// <summary>
/// Relative velocity between two plates at a junction point (RFC-V2-0042 §7.1).
/// </summary>
[MessagePackObject]
public readonly record struct PlateRelativeVelocity(
    /// <summary>The "from" plate in the relative velocity calculation.</summary>
    [property: Key(0)] PlateId FromPlate,

    /// <summary>The "to" plate in the relative velocity calculation.</summary>
    [property: Key(1)] PlateId ToPlate,

    /// <summary>Velocity of ToPlate relative to FromPlate at the junction point.</summary>
    [property: Key(2)] Velocity3d Velocity
);


// --- PATH: contracts/Geosphere.Plate.Junction.Contracts/Products/JunctionClassification.cs ---
﻿namespace FantaSim.Geosphere.Plate.Junction.Contracts.Products;

/// <summary>
/// Classification of a triple junction by boundary types (RFC-V2-0042 §6.3).
/// </summary>
/// <remarks>
/// <para>
/// Labels follow standard plate tectonics notation:
/// <list type="bullet">
///   <item><description>R = Ridge (divergent boundary)</description></item>
///   <item><description>F = Transform fault (strike-slip)</description></item>
///   <item><description>T = Trench (convergent/subduction boundary)</description></item>
/// </list>
/// </para>
/// <para>
/// Classification is derived from boundary types in alphabetical order (F &lt; R &lt; T).
/// For example, a junction with Ridge-Trench-Trench boundaries → RTT.
/// </para>
/// </remarks>
public enum JunctionClassification
{
    /// <summary>Transform-Transform-Transform: three strike-slip boundaries.</summary>
    FFF,

    /// <summary>Transform-Transform-Trench: two transforms, one convergent.</summary>
    FFT,

    /// <summary>Transform-Trench-Trench: one transform, two convergent.</summary>
    FTT,

    /// <summary>Ridge-Transform-Transform: one divergent, two transforms.</summary>
    RFF,

    /// <summary>Ridge-Transform-Trench: one each of ridge, transform, trench.</summary>
    RFT,

    /// <summary>Ridge-Ridge-Transform: two divergent, one transform.</summary>
    RRF,

    /// <summary>Ridge-Ridge-Ridge: three divergent boundaries (spreading center intersection).</summary>
    RRR,

    /// <summary>Ridge-Ridge-Trench: two divergent, one convergent.</summary>
    RRT,

    /// <summary>Ridge-Trench-Trench: one divergent, two convergent.</summary>
    RTT,

    /// <summary>Trench-Trench-Trench: three convergent boundaries.</summary>
    TTT,

    /// <summary>Unknown or unclassifiable junction (missing types, non-triple, etc.).</summary>
    Unknown
}


// --- PATH: contracts/Geosphere.Plate.Junction.Contracts/Products/JunctionIncident.cs ---
using MessagePack;
using FantaSim.Geosphere.Plate.Topology.Contracts.Entities;
using FantaSim.Geosphere.Plate.Topology.Contracts.Numerics;

namespace FantaSim.Geosphere.Plate.Junction.Contracts.Products;

/// <summary>
/// A boundary incident at a junction (RFC-V2-0042 §6.1).
/// </summary>
/// <remarks>
/// <para>
/// Represents a directed boundary segment terminating at a junction point.
/// The angle field establishes deterministic cyclic ordering around the junction.
/// </para>
/// <para>
/// <b>Sphere-correct:</b> Angle is measured in the local tangent plane at the junction,
/// CCW from North (not from global +X). This is computed using a <see cref="Frame3"/>
/// constructed at the junction's surface point.
/// </para>
/// </remarks>
[MessagePackObject]
public readonly record struct JunctionIncident(
    /// <summary>The boundary terminating at this junction.</summary>
    [property: Key(0)] BoundaryId BoundaryId,

    /// <summary>True if this is the boundary's start point; false if endpoint.</summary>
    [property: Key(1)] bool IsStartpoint,

    /// <summary>
    /// Angle in the local tangent plane at the junction (radians, CCW from North).
    /// </summary>
    /// <remarks>
    /// This angle is computed by projecting the boundary direction onto the tangent plane
    /// at the junction's surface point and measuring from North. It is stable across
    /// the entire sphere, unlike global angles which break at the poles.
    /// </remarks>
    [property: Key(2)] double TangentAngle,

    /// <summary>Plate on the left side of this incident (looking along boundary direction).</summary>
    [property: Key(3)] PlateId LeftPlateId,

    /// <summary>Plate on the right side of this incident (looking along boundary direction).</summary>
    [property: Key(4)] PlateId RightPlateId
)
{
    /// <summary>
    /// Computes the tangent angle for a boundary direction at a junction.
    /// </summary>
    /// <param name="junctionPosition">The surface point where the junction is located.</param>
    /// <param name="boundaryDirection">The 3D direction vector along the boundary (outward from junction).</param>
    /// <returns>Angle in radians, CCW from North in the tangent plane.</returns>
    public static double ComputeTangentAngle(SurfacePoint junctionPosition, Vector3d boundaryDirection)
    {
        // Create local tangent frame at the junction
        var frame = junctionPosition.CreateTangentFrame();

        // Project boundary direction onto tangent plane and compute angle
        return frame.ComputeTangentAngle(boundaryDirection);
    }

    /// <summary>
    /// Compares two incidents by their tangent angle for deterministic ordering.
    /// </summary>
    public static int CompareByAngle(JunctionIncident a, JunctionIncident b)
    {
        var angleCmp = a.TangentAngle.CompareTo(b.TangentAngle);
        return angleCmp != 0 ? angleCmp : a.BoundaryId.Value.CompareTo(b.BoundaryId.Value);
    }
}


// --- PATH: contracts/Geosphere.Plate.Junction.Contracts/Products/JunctionInfo.cs ---
﻿using System.Collections.Immutable;
using MessagePack;
using FantaSim.Geosphere.Plate.Topology.Contracts.Entities;
using UnifyGeometry;

namespace FantaSim.Geosphere.Plate.Junction.Contracts.Products;

/// <summary>
/// Derived junction information (RFC-V2-0042 §6.2).
/// </summary>
/// <remarks>
/// <para>
/// A JunctionInfo captures the complete derived state of a junction at a tick:
/// <list type="bullet">
///   <item><description>Position in body frame</description></item>
///   <item><description>Ordered incident boundaries</description></item>
///   <item><description>Incident plates (deduplicated)</description></item>
///   <item><description>Optional classification (if triple junction with known types)</description></item>
/// </list>
/// </para>
/// </remarks>
[MessagePackObject]
public readonly record struct JunctionInfo(
    /// <summary>The junction's stable identifier.</summary>
    [property: Key(0)] JunctionId JunctionId,

    /// <summary>Junction position in body frame coordinates.</summary>
    [property: Key(1)] Point3 Position,

    /// <summary>Incident boundaries in deterministic cyclic order (CCW from +X).</summary>
    [property: Key(2)] ImmutableArray<JunctionIncident> Incidents,

    /// <summary>Plates meeting at this junction (deduplicated, sorted by PlateId).</summary>
    [property: Key(3)] ImmutableArray<PlateId> IncidentPlates,

    /// <summary>Triple junction classification, if applicable.</summary>
    [property: Key(4)] JunctionClassification? Classification
)
{
    /// <summary>
    /// Returns true if this is a triple junction (exactly 3 incidents).
    /// </summary>
    [IgnoreMember]
    public bool IsTriple => Incidents.Length == 3;

    /// <summary>
    /// Number of incident boundaries at this junction.
    /// </summary>
    [IgnoreMember]
    public int Degree => Incidents.Length;
}


// --- PATH: contracts/Geosphere.Plate.Junction.Contracts/Products/JunctionSet.cs ---
﻿using System.Collections.Immutable;
using MessagePack;
using FantaSim.Geosphere.Plate.Topology.Contracts.Entities;
using Plate.TimeDete.Time.Primitives;

namespace FantaSim.Geosphere.Plate.Junction.Contracts.Products;

/// <summary>
/// Collection of all junctions at a tick (RFC-V2-0042 §6.4).
/// </summary>
/// <remarks>
/// <para>
/// JunctionSet is a snapshot of all derived junction information at a specific tick.
/// Junctions are sorted by JunctionId for deterministic ordering.
/// </para>
/// </remarks>
[MessagePackObject]
public readonly record struct JunctionSet(
    /// <summary>The tick at which this junction set was computed.</summary>
    [property: Key(0)] CanonicalTick Tick,

    /// <summary>All junctions, sorted by JunctionId.</summary>
    [property: Key(1)] ImmutableArray<JunctionInfo> Junctions
)
{
    /// <summary>
    /// Lookup junction by ID.
    /// </summary>
    /// <param name="junctionId">The junction to find.</param>
    /// <returns>The junction info, or null if not found.</returns>
    public JunctionInfo? GetJunction(JunctionId junctionId)
        => Junctions.FirstOrDefault(j => j.JunctionId == junctionId);

    /// <summary>
    /// Find junctions involving a specific plate.
    /// </summary>
    /// <param name="plateId">The plate to search for.</param>
    /// <returns>All junctions where the plate is incident.</returns>
    public IEnumerable<JunctionInfo> GetJunctionsForPlate(PlateId plateId)
        => Junctions.Where(j => j.IncidentPlates.Contains(plateId));

    /// <summary>
    /// Count of triple junctions (exactly 3 incident boundaries).
    /// </summary>
    [IgnoreMember]
    public int TripleJunctionCount => Junctions.Count(j => j.IsTriple);

    /// <summary>
    /// Count of non-triple junctions (≠3 incident boundaries).
    /// </summary>
    [IgnoreMember]
    public int NonTripleJunctionCount => Junctions.Count(j => !j.IsTriple);
}


// --- PATH: contracts/Geosphere.Plate.Junction.Contracts/Solvers/IJunctionAnalyzer.cs ---
﻿using FantaSim.Geosphere.Plate.Junction.Contracts.Diagnostics;
using FantaSim.Geosphere.Plate.Junction.Contracts.Products;
using FantaSim.Geosphere.Plate.Kinematics.Contracts.Derived;
using FantaSim.Geosphere.Plate.Topology.Contracts.Derived;
using FantaSim.Geosphere.Plate.Velocity.Contracts;
using Plate.TimeDete.Time.Primitives;

namespace FantaSim.Geosphere.Plate.Junction.Contracts.Solvers;

/// <summary>
/// Solver for building junction products and diagnostics (RFC-V2-0042 §9.1).
/// </summary>
/// <remarks>
/// <para>
/// <b>Determinism:</b> All methods MUST produce identical results for identical inputs.
/// </para>
/// <para>
/// <b>Pure computation:</b> Solvers MUST NOT perform I/O or mutate truth.
/// </para>
/// </remarks>
public interface IJunctionAnalyzer
{
    /// <summary>
    /// Builds the junction set at the given tick.
    /// </summary>
    /// <param name="tick">Query tick.</param>
    /// <param name="topology">Materialized topology state at tick.</param>
    /// <param name="options">Analysis options (uses defaults if null).</param>
    /// <returns>Complete junction set with incidents and classifications.</returns>
    /// <remarks>
    /// <para>
    /// Incident ordering follows RFC-V2-0042 §10.1: sorted by angle (CCW from +X),
    /// ties broken by BoundaryId.
    /// </para>
    /// <para>
    /// Classification requires boundary types to be available in topology.
    /// If types are missing, junctions are classified as <see cref="JunctionClassification.Unknown"/>.
    /// </para>
    /// </remarks>
    JunctionSet BuildJunctionSet(
        CanonicalTick tick,
        IPlateTopologyStateView topology,
        JunctionAnalysisOptions? options = null);

    /// <summary>
    /// Computes kinematic diagnostics for all junctions.
    /// Requires velocity solver from RFC-V2-0033.
    /// </summary>
    /// <param name="tick">Query tick.</param>
    /// <param name="junctions">Junction set to analyze.</param>
    /// <param name="topology">Materialized topology state at tick.</param>
    /// <param name="kinematics">Materialized kinematics state at tick.</param>
    /// <param name="velocitySolver">Velocity computation solver.</param>
    /// <param name="options">Analysis options (uses defaults if null).</param>
    /// <returns>Complete diagnostics including closure analysis.</returns>
    JunctionDiagnostics Diagnose(
        CanonicalTick tick,
        JunctionSet junctions,
        IPlateTopologyStateView topology,
        IPlateKinematicsStateView kinematics,
        IPlateVelocitySolver velocitySolver,
        JunctionAnalysisOptions? options = null);

    /// <summary>
    /// Computes closure diagnostic for a single junction.
    /// </summary>
    /// <param name="junction">The junction to diagnose.</param>
    /// <param name="tick">Query tick.</param>
    /// <param name="topology">Materialized topology state at tick.</param>
    /// <param name="kinematics">Materialized kinematics state at tick.</param>
    /// <param name="velocitySolver">Velocity computation solver.</param>
    /// <param name="options">Analysis options (uses defaults if null).</param>
    /// <returns>Closure diagnostic for the junction.</returns>
    JunctionClosureDiagnostic DiagnoseJunction(
        JunctionInfo junction,
        CanonicalTick tick,
        IPlateTopologyStateView topology,
        IPlateKinematicsStateView kinematics,
        IPlateVelocitySolver velocitySolver,
        JunctionAnalysisOptions? options = null);
}


// --- PATH: contracts/Geosphere.Plate.Junction.Contracts/Solvers/JunctionAnalysisOptions.cs ---
﻿namespace FantaSim.Geosphere.Plate.Junction.Contracts.Solvers;

/// <summary>
/// Options for junction analysis (RFC-V2-0042 §8).
/// </summary>
/// <remarks>
/// <para>
/// Default values are designed for typical plate tectonics scenarios.
/// Adjust <see cref="ClosureTolerance"/> for different simulation precision requirements.
/// </para>
/// </remarks>
public readonly record struct JunctionAnalysisOptions(
    /// <summary>
    /// Maximum residual magnitude considered "closed" (default: 1e-6).
    /// </summary>
    double ClosureTolerance = 1e-6,

    /// <summary>
    /// Whether to compute RRR/RTT classification labels (default: true).
    /// Requires boundary type metadata.
    /// </summary>
    bool IncludeClassification = true,

    /// <summary>
    /// Whether to compute velocity residual diagnostics (default: true).
    /// Requires kinematics and velocity solver.
    /// </summary>
    bool IncludeClosureDiagnostics = true
)
{
    /// <summary>
    /// Default options for junction analysis.
    /// </summary>
    public static JunctionAnalysisOptions Default => new();

    /// <summary>
    /// Options for fast analysis (skip classification and closure diagnostics).
    /// </summary>
    public static JunctionAnalysisOptions Fast => new(
        ClosureTolerance: 1e-6,
        IncludeClassification: false,
        IncludeClosureDiagnostics: false);
}


// --- PATH: contracts/Geosphere.Plate.Kinematics.Contracts/Derived/IPlateKinematicsStateView.cs ---
using Plate.TimeDete.Time.Primitives;
using FantaSim.Geosphere.Plate.Topology.Contracts.Entities;
using FantaSim.Geosphere.Plate.Topology.Contracts.Identity;
using FantaSim.Geosphere.Plate.Topology.Contracts.Numerics;

namespace FantaSim.Geosphere.Plate.Kinematics.Contracts.Derived;

public interface IPlateKinematicsStateView
{
    TruthStreamIdentity Identity { get; }

    long LastEventSequence { get; }

    bool TryGetRotation(
        PlateId plateId,
        CanonicalTick tick,
        out Quaterniond rotation);
}


// --- PATH: contracts/Geosphere.Plate.Kinematics.Contracts/Entities/MotionSegmentId.cs ---
using System.Buffers.Binary;
using Plate.TimeDete.Determinism.Abstractions;
using MessagePack;

namespace FantaSim.Geosphere.Plate.Kinematics.Contracts.Entities;

/// <summary>
/// Stable identifier representing a motion segment in plate kinematics truth.
/// </summary>
[MessagePackObject]
public readonly record struct MotionSegmentId
{
    private readonly Guid _value;

    [SerializationConstructor]
    public MotionSegmentId(Guid value)
    {
        _value = value;
    }

    [Key(0)]
    public Guid Value => _value;

    [IgnoreMember]
    public bool IsEmpty => _value == Guid.Empty;

    /// <summary>
    /// Creates a new non-deterministic MotionSegmentId.
    /// </summary>
    /// <remarks>
    /// WARNING: This method uses Guid.NewGuid() which breaks determinism.
    /// Use <see cref="NewId(ISeededRng)"/> for reproducible simulation runs.
    /// </remarks>
    [Obsolete("Use NewId(ISeededRng) for deterministic simulation runs. This method breaks replay determinism.")]
    public static MotionSegmentId NewId() => new(Guid.NewGuid());

    /// <summary>
    /// Creates a new deterministic MotionSegmentId using a seeded RNG.
    /// </summary>
    /// <param name="rng">The seeded RNG to use for ID generation.</param>
    /// <returns>A new MotionSegmentId with a deterministic value.</returns>
    public static MotionSegmentId NewId(ISeededRng rng)
    {
        ArgumentNullException.ThrowIfNull(rng);
        var a = rng.NextUInt64();
        var b = rng.NextUInt64();
        Span<byte> bytes = stackalloc byte[16];
        BinaryPrimitives.WriteUInt64LittleEndian(bytes[..8], a);
        BinaryPrimitives.WriteUInt64LittleEndian(bytes[8..], b);
        return new MotionSegmentId(new Guid(bytes));
    }

    public override string ToString() => _value.ToString("D");
}


// --- PATH: contracts/Geosphere.Plate.Kinematics.Contracts/Events/IKinematicsEventStore.cs ---
using FantaSim.Geosphere.Plate.Topology.Contracts.Identity;

namespace FantaSim.Geosphere.Plate.Kinematics.Contracts.Events;

public enum TickMonotonicityPolicy
{
    Allow = 0,
    Warn = 1,
    Reject = 2
}

public sealed class AppendOptions
{
    public static readonly AppendOptions Default = new();

    public TickMonotonicityPolicy TickPolicy { get; init; } = TickMonotonicityPolicy.Allow;
}

public interface IKinematicsEventStore
{
    Task AppendAsync(
        TruthStreamIdentity stream,
        IEnumerable<IPlateKinematicsEvent> events,
        CancellationToken cancellationToken);

    Task AppendAsync(
        TruthStreamIdentity stream,
        IEnumerable<IPlateKinematicsEvent> events,
        AppendOptions options,
        CancellationToken cancellationToken);

    IAsyncEnumerable<IPlateKinematicsEvent> ReadAsync(
        TruthStreamIdentity stream,
        long fromSequenceInclusive,
        CancellationToken cancellationToken);

    Task<long?> GetLastSequenceAsync(
        TruthStreamIdentity stream,
        CancellationToken cancellationToken);
}


// --- PATH: contracts/Geosphere.Plate.Kinematics.Contracts/Events/IPlateKinematicsEvent.cs ---
using Plate.TimeDete.Time.Primitives;
using FantaSim.Geosphere.Plate.Topology.Contracts.Identity;

namespace FantaSim.Geosphere.Plate.Kinematics.Contracts.Events;

/// <summary>
/// Base interface for all plate kinematics truth events (RFC-V2-0023).
/// </summary>
public interface IPlateKinematicsEvent
{
    Guid EventId { get; }

    string EventType { get; }

    CanonicalTick Tick { get; }

    long Sequence { get; }

    TruthStreamIdentity StreamIdentity { get; }

    ReadOnlyMemory<byte> PreviousHash { get; }

    ReadOnlyMemory<byte> Hash { get; }
}


// --- PATH: contracts/Geosphere.Plate.Kinematics.Contracts/Events/MotionSegmentRetiredEvent.cs ---
using Plate.TimeDete.Time.Primitives;
using FantaSim.Geosphere.Plate.Kinematics.Contracts.Entities;
using FantaSim.Geosphere.Plate.Topology.Contracts.Entities;
using FantaSim.Geosphere.Plate.Topology.Contracts.Identity;
using UnifySerialization.Abstractions;

namespace FantaSim.Geosphere.Plate.Kinematics.Contracts.Events;

/// <summary>
/// Retires a previously-defined motion segment.
/// </summary>
[UnifyModel]
public readonly record struct MotionSegmentRetiredEvent(
    [property: UnifyProperty(0)] Guid EventId,
    [property: UnifyProperty(1)] PlateId PlateId,
    [property: UnifyProperty(2)] MotionSegmentId SegmentId,
    [property: UnifyProperty(3)] string Reason,
    [property: UnifyProperty(4)] CanonicalTick Tick,
    [property: UnifyProperty(5)] long Sequence,
    [property: UnifyProperty(6)] TruthStreamIdentity StreamIdentity,
    [property: UnifyProperty(7)] ReadOnlyMemory<byte> PreviousHash,
    [property: UnifyProperty(8)] ReadOnlyMemory<byte> Hash
) : IPlateKinematicsEvent
{
    string IPlateKinematicsEvent.EventType => nameof(MotionSegmentRetiredEvent);
}


// --- PATH: contracts/Geosphere.Plate.Kinematics.Contracts/Events/MotionSegmentUpsertedEvent.cs ---
using System.Runtime.InteropServices;
using Plate.TimeDete.Time.Primitives;
using FantaSim.Geosphere.Plate.Kinematics.Contracts.Entities;
using FantaSim.Geosphere.Plate.Kinematics.Contracts.Numerics;
using FantaSim.Geosphere.Plate.Topology.Contracts.Entities;
using FantaSim.Geosphere.Plate.Topology.Contracts.Identity;
using UnifySerialization.Abstractions;

namespace FantaSim.Geosphere.Plate.Kinematics.Contracts.Events;

/// <summary>
/// Defines or updates a motion segment for a plate over an interval [TickA, TickB].
/// </summary>
[StructLayout(LayoutKind.Auto)]
[UnifyModel]
public readonly record struct MotionSegmentUpsertedEvent(
    [property: UnifyProperty(0)] Guid EventId,
    [property: UnifyProperty(1)] PlateId PlateId,
    [property: UnifyProperty(2)] MotionSegmentId SegmentId,
    [property: UnifyProperty(3)] CanonicalTick TickA,
    [property: UnifyProperty(4)] CanonicalTick TickB,
    [property: UnifyProperty(5)] QuantizedEulerPoleRotation StageRotation,
    [property: UnifyProperty(6)] CanonicalTick Tick,
    [property: UnifyProperty(7)] long Sequence,
    [property: UnifyProperty(8)] TruthStreamIdentity StreamIdentity,
    [property: UnifyProperty(9)] ReadOnlyMemory<byte> PreviousHash,
    [property: UnifyProperty(10)] ReadOnlyMemory<byte> Hash
) : IPlateKinematicsEvent
{
    string IPlateKinematicsEvent.EventType => nameof(MotionSegmentUpsertedEvent);
}


// --- PATH: contracts/Geosphere.Plate.Kinematics.Contracts/Events/PlateMotionModelAssignedEvent.cs ---
using Plate.TimeDete.Time.Primitives;
using FantaSim.Geosphere.Plate.Topology.Contracts.Entities;
using FantaSim.Geosphere.Plate.Topology.Contracts.Identity;
using UnifySerialization.Abstractions;

namespace FantaSim.Geosphere.Plate.Kinematics.Contracts.Events;

/// <summary>
/// Optional event associating a named motion model with a plate.
/// </summary>
[UnifyModel]
public readonly record struct PlateMotionModelAssignedEvent(
    [property: UnifyProperty(0)] Guid EventId,
    [property: UnifyProperty(1)] PlateId PlateId,
    [property: UnifyProperty(2)] string ModelId,
    [property: UnifyProperty(3)] CanonicalTick Tick,
    [property: UnifyProperty(4)] long Sequence,
    [property: UnifyProperty(5)] TruthStreamIdentity StreamIdentity,
    [property: UnifyProperty(6)] ReadOnlyMemory<byte> PreviousHash,
    [property: UnifyProperty(7)] ReadOnlyMemory<byte> Hash
) : IPlateKinematicsEvent
{
    string IPlateKinematicsEvent.EventType => nameof(PlateMotionModelAssignedEvent);
}


// --- PATH: contracts/Geosphere.Plate.Kinematics.Contracts/Numerics/QuantizedEulerPoleRotation.cs ---
using System;
using System.Runtime.InteropServices;
using MessagePack;

namespace FantaSim.Geosphere.Plate.Kinematics.Contracts.Numerics;

/// <summary>
/// Quantized Euler pole rotation payload for deterministic persistence/hashing.
///
/// Values are stored as micro-degrees (1e-6 degrees) to avoid floating ambiguity.
/// </summary>
[StructLayout(LayoutKind.Auto)]
[MessagePackObject]
public readonly record struct QuantizedEulerPoleRotation(
    [property: Key(0)] int AxisAzimuthMicroDeg,
    [property: Key(1)] int AxisElevationMicroDeg,
    [property: Key(2)] int AngleMicroDeg)
{
    public const int MicroDegPerDeg = 1_000_000;

    public static QuantizedEulerPoleRotation Create(
        int axisAzimuthMicroDeg,
        int axisElevationMicroDeg,
        int angleMicroDeg)
    {
        axisAzimuthMicroDeg = WrapAzimuthMicroDeg(axisAzimuthMicroDeg);
        axisElevationMicroDeg = Math.Clamp(axisElevationMicroDeg, -90 * MicroDegPerDeg, 90 * MicroDegPerDeg);
        return new QuantizedEulerPoleRotation(axisAzimuthMicroDeg, axisElevationMicroDeg, angleMicroDeg);
    }

    private static int WrapAzimuthMicroDeg(int azimuth)
    {
        // Wrap to [-180, 180] degrees.
        var full = 360 * MicroDegPerDeg;
        var half = 180 * MicroDegPerDeg;

        var wrapped = azimuth % full;
        if (wrapped > half) wrapped -= full;
        if (wrapped < -half) wrapped += full;
        return wrapped;
    }

    [IgnoreMember]
    public double AxisAzimuthDeg => (double)AxisAzimuthMicroDeg / MicroDegPerDeg;

    [IgnoreMember]
    public double AxisElevationDeg => (double)AxisElevationMicroDeg / MicroDegPerDeg;

    [IgnoreMember]
    public double AngleDeg => (double)AngleMicroDeg / MicroDegPerDeg;
}


// --- PATH: contracts/Geosphere.Plate.Motion.Contracts/Flowline.cs ---
using System.Collections.Immutable;
using System.Runtime.InteropServices;
using MessagePack;
using Plate.TimeDete.Time.Primitives;
using FantaSim.Geosphere.Plate.Topology.Contracts.Entities;

namespace FantaSim.Geosphere.Plate.Motion.Contracts;

/// <summary>
/// Material path seeded from a boundary sample (RFC-V2-0035 §7.3).
/// </summary>
[StructLayout(LayoutKind.Auto)]
[MessagePackObject]
public readonly record struct Flowline(
    [property: Key(0)] BoundaryId BoundaryId,
    [property: Key(1)] int SeedIndex,
    [property: Key(2)] PlateSide Side,
    [property: Key(3)] CanonicalTick StartTick,
    [property: Key(4)] CanonicalTick EndTick,
    [property: Key(5)] IntegrationDirection Direction,
    [property: Key(6)] ImmutableArray<MotionPathSample> Samples
);


// --- PATH: contracts/Geosphere.Plate.Motion.Contracts/IFlowlineSolver.cs ---
using System.Collections.Immutable;
using Plate.TimeDete.Time.Primitives;
using FantaSim.Geosphere.Plate.Kinematics.Contracts.Derived;
using FantaSim.Geosphere.Plate.Topology.Contracts.Derived;
using FantaSim.Geosphere.Plate.Topology.Contracts.Entities;
using FantaSim.Geosphere.Plate.Velocity.Contracts;

namespace FantaSim.Geosphere.Plate.Motion.Contracts;

/// <summary>
/// Solver for computing flowlines from boundary samples (RFC-V2-0035 §8.2).
/// </summary>
public interface IFlowlineSolver
{
    /// <summary>
    /// Computes a flowline from a boundary sample.
    /// The seed position is taken directly from the sample to ensure consistency.
    /// </summary>
    /// <param name="boundaryId">The source boundary for seeding.</param>
    /// <param name="seed">The boundary velocity sample to seed from.</param>
    /// <param name="side">Which plate side to trace (Left or Right).</param>
    /// <param name="startTick">Integration start time.</param>
    /// <param name="endTick">Integration end time.</param>
    /// <param name="direction">Direction of integration (forward or backward).</param>
    /// <param name="topology">The topology state view.</param>
    /// <param name="kinematics">The kinematics state view.</param>
    /// <param name="spec">Optional integration specification (defaults used if null).</param>
    /// <returns>The computed flowline.</returns>
    Flowline ComputeFlowline(
        BoundaryId boundaryId,
        BoundaryVelocitySample seed,
        PlateSide side,
        CanonicalTick startTick,
        CanonicalTick endTick,
        IntegrationDirection direction,
        IPlateTopologyStateView topology,
        IPlateKinematicsStateView kinematics,
        MotionIntegrationSpec? spec = null);

    /// <summary>
    /// Computes flowlines for all samples in a boundary profile.
    /// </summary>
    /// <param name="boundaryId">The source boundary for seeding.</param>
    /// <param name="samples">The boundary velocity samples to seed from.</param>
    /// <param name="side">Which plate side to trace (Left or Right).</param>
    /// <param name="startTick">Integration start time.</param>
    /// <param name="endTick">Integration end time.</param>
    /// <param name="direction">Direction of integration (forward or backward).</param>
    /// <param name="topology">The topology state view.</param>
    /// <param name="kinematics">The kinematics state view.</param>
    /// <param name="spec">Optional integration specification (defaults used if null).</param>
    /// <returns>An immutable array of computed flowlines.</returns>
    ImmutableArray<Flowline> ComputeFlowlinesForBoundary(
        BoundaryId boundaryId,
        IReadOnlyList<BoundaryVelocitySample> samples,
        PlateSide side,
        CanonicalTick startTick,
        CanonicalTick endTick,
        IntegrationDirection direction,
        IPlateTopologyStateView topology,
        IPlateKinematicsStateView kinematics,
        MotionIntegrationSpec? spec = null);
}


// --- PATH: contracts/Geosphere.Plate.Motion.Contracts/IMotionPathSolver.cs ---
using Plate.TimeDete.Time.Primitives;
using UnifyGeometry;
using FantaSim.Geosphere.Plate.Kinematics.Contracts.Derived;
using FantaSim.Geosphere.Plate.Topology.Contracts.Derived;
using FantaSim.Geosphere.Plate.Topology.Contracts.Entities;

namespace FantaSim.Geosphere.Plate.Motion.Contracts;

/// <summary>
/// Solver for computing motion paths (RFC-V2-0035 §8.1).
/// </summary>
public interface IMotionPathSolver
{
    /// <summary>
    /// Computes the motion path of a point attached to a plate.
    /// </summary>
    /// <param name="plateId">The plate the point is attached to.</param>
    /// <param name="startPoint">The initial position (body frame at startTick).</param>
    /// <param name="startTick">Integration start time.</param>
    /// <param name="endTick">Integration end time.</param>
    /// <param name="direction">Direction of integration (forward or backward).</param>
    /// <param name="topology">The topology state view.</param>
    /// <param name="kinematics">The kinematics state view.</param>
    /// <param name="spec">Optional integration specification (defaults used if null).</param>
    /// <returns>The computed motion path.</returns>
    MotionPath ComputeMotionPath(
        PlateId plateId,
        Point3 startPoint,
        CanonicalTick startTick,
        CanonicalTick endTick,
        IntegrationDirection direction,
        IPlateTopologyStateView topology,
        IPlateKinematicsStateView kinematics,
        MotionIntegrationSpec? spec = null);
}


// --- PATH: contracts/Geosphere.Plate.Motion.Contracts/IntegrationDirection.cs ---
namespace FantaSim.Geosphere.Plate.Motion.Contracts;

/// <summary>
/// Direction of time integration (RFC-V2-0035 §6).
/// </summary>
public enum IntegrationDirection
{
    Forward,
    Backward
}


// --- PATH: contracts/Geosphere.Plate.Motion.Contracts/IntegrationMethod.cs ---
namespace FantaSim.Geosphere.Plate.Motion.Contracts;

/// <summary>
/// Integration method for motion paths (RFC-V2-0035 §6).
/// </summary>
public enum IntegrationMethod
{
    /// <summary>Forward Euler (MVP baseline).</summary>
    Euler,

    /// <summary>4th-order Runge-Kutta (future). Not required for MVP.</summary>
    RungeKutta4
}


// --- PATH: contracts/Geosphere.Plate.Motion.Contracts/MotionIntegrationSpec.cs ---
using System.Runtime.InteropServices;

namespace FantaSim.Geosphere.Plate.Motion.Contracts;

/// <summary>
/// Specification for motion path integration (RFC-V2-0035 §6).
/// </summary>
/// <remarks>
/// <para>
/// <b>Default values:</b> StepTicks = 1, MaxSteps = 1000, Method = Euler.
/// </para>
/// <para>
/// <b>Note:</b> Use <see cref="Default"/> for default specification, or specify all parameters explicitly.
/// The parameterless constructor uses struct default values (0), not these documented defaults.
/// </para>
/// </remarks>
[StructLayout(LayoutKind.Auto)]
public readonly record struct MotionIntegrationSpec
{
    /// <summary>Default integration specification with StepTicks=1, MaxSteps=1000, Method=Euler.</summary>
    public static MotionIntegrationSpec Default => new(1, 1000, IntegrationMethod.Euler);

    /// <summary>Time step size in canonical ticks. Default: 1.</summary>
    public int StepTicks { get; init; }

    /// <summary>Maximum number of integration steps. Default: 1000.</summary>
    public int MaxSteps { get; init; }

    /// <summary>Integration method. Default: Euler.</summary>
    public IntegrationMethod Method { get; init; }

    /// <summary>
    /// Creates a motion integration specification.
    /// </summary>
    /// <param name="stepTicks">Time step size in canonical ticks. Must be positive.</param>
    /// <param name="maxSteps">Maximum number of integration steps. Must be positive.</param>
    /// <param name="method">Integration method.</param>
    /// <exception cref="ArgumentOutOfRangeException">Thrown when stepTicks or maxSteps is not positive.</exception>
    public MotionIntegrationSpec(int stepTicks = 1, int maxSteps = 1000, IntegrationMethod method = IntegrationMethod.Euler)
    {
        if (stepTicks <= 0)
            throw new ArgumentOutOfRangeException(nameof(stepTicks), stepTicks, "StepTicks must be positive.");
        if (maxSteps <= 0)
            throw new ArgumentOutOfRangeException(nameof(maxSteps), maxSteps, "MaxSteps must be positive.");

        StepTicks = stepTicks;
        MaxSteps = maxSteps;
        Method = method;
    }
}


// --- PATH: contracts/Geosphere.Plate.Motion.Contracts/MotionPath.cs ---
using System.Collections.Immutable;
using System.Runtime.InteropServices;
using MessagePack;
using Plate.TimeDete.Time.Primitives;
using FantaSim.Geosphere.Plate.Topology.Contracts.Entities;

namespace FantaSim.Geosphere.Plate.Motion.Contracts;

/// <summary>
/// Trajectory of a material point attached to a plate (RFC-V2-0035 §7.2).
/// </summary>
[StructLayout(LayoutKind.Auto)]
[MessagePackObject]
public readonly record struct MotionPath(
    [property: Key(0)] PlateId PlateId,
    [property: Key(1)] CanonicalTick StartTick,
    [property: Key(2)] CanonicalTick EndTick,
    [property: Key(3)] IntegrationDirection Direction,
    [property: Key(4)] ImmutableArray<MotionPathSample> Samples
);


// --- PATH: contracts/Geosphere.Plate.Motion.Contracts/MotionPathSample.cs ---
using System.Runtime.InteropServices;
using MessagePack;
using Plate.TimeDete.Time.Primitives;
using UnifyGeometry;
using FantaSim.Geosphere.Plate.Velocity.Contracts;

namespace FantaSim.Geosphere.Plate.Motion.Contracts;

/// <summary>
/// A single sample along a motion path (RFC-V2-0035 §7.1).
/// </summary>
[MessagePackObject]
[StructLayout(LayoutKind.Sequential)]
public readonly record struct MotionPathSample(
    [property: Key(0)] CanonicalTick Tick,
    [property: Key(1)] Point3 Position,
    [property: Key(2)] Velocity3d Velocity,
    [property: Key(3)] int StepIndex
);


// --- PATH: contracts/Geosphere.Plate.Motion.Contracts/PlateSide.cs ---
namespace FantaSim.Geosphere.Plate.Motion.Contracts;

/// <summary>
/// Plate side for flowline seeding (RFC-V2-0035 §7.3).
/// </summary>
public enum PlateSide
{
    Left,
    Right
}


// --- PATH: contracts/Geosphere.Plate.Polygonization.Contracts/CMap/AnglePolicy.cs ---
using System.Runtime.InteropServices;

namespace FantaSim.Geosphere.Plate.Polygonization.Contracts.CMap;

/// <summary>
/// Policy for comparing angles in a deterministic, stable manner.
/// </summary>
/// <remarks>
/// <para>
/// Floating-point angle comparisons can be unstable near collinear edges.
/// This policy provides two mechanisms to stabilize ordering:
/// </para>
/// <list type="bullet">
///   <item><b>Quantization</b>: Round angles to discrete bins before comparison</item>
///   <item><b>Epsilon</b>: Treat angles within epsilon as equal, falling back to tie-breakers</item>
/// </list>
/// <para>
/// The default policy uses a small epsilon (1e-12 radians ≈ 0.2 microarcseconds)
/// which is well below any meaningful geometric tolerance while still catching
/// floating-point representation differences.
/// </para>
/// </remarks>
[StructLayout(LayoutKind.Auto)]
public readonly record struct AnglePolicy
{
    /// <summary>
    /// Epsilon for angle comparison (radians). Angles within this tolerance
    /// are considered equal and fall back to tie-breakers.
    /// </summary>
    public double Epsilon { get; init; }

    /// <summary>
    /// If true, quantize angles to discrete bins before comparison.
    /// Bin size is determined by <see cref="QuantizationRadians"/>.
    /// </summary>
    public bool UseQuantization { get; init; }

    /// <summary>
    /// Quantization bin size in radians. Only used if <see cref="UseQuantization"/> is true.
    /// </summary>
    public double QuantizationRadians { get; init; }

    /// <summary>
    /// Default policy: epsilon-based comparison with 1e-12 radians tolerance.
    /// </summary>
    public static AnglePolicy Default => new()
    {
        Epsilon = 1e-12,
        UseQuantization = false,
        QuantizationRadians = 0
    };

    /// <summary>
    /// Strict policy: no tolerance, direct floating-point comparison.
    /// Use only when you need exact IEEE 754 semantics.
    /// </summary>
    public static AnglePolicy Strict => new()
    {
        Epsilon = 0,
        UseQuantization = false,
        QuantizationRadians = 0
    };

    /// <summary>
    /// Quantized policy: round angles to 1e-9 radian bins (~0.2 milliarcseconds).
    /// Useful when geometry has known precision limits.
    /// </summary>
    public static AnglePolicy Quantized(double binSizeRadians = 1e-9) => new()
    {
        Epsilon = 0,
        UseQuantization = true,
        QuantizationRadians = binSizeRadians
    };

    /// <summary>
    /// Compares two angles according to this policy.
    /// Returns 0 if angles are considered equal (within tolerance or same bin).
    /// </summary>
    /// <param name="angleA">First angle in radians.</param>
    /// <param name="angleB">Second angle in radians.</param>
    /// <returns>
    /// Negative if angleA &lt; angleB, positive if angleA &gt; angleB, zero if equal within policy.
    /// </returns>
    public int CompareAngles(double angleA, double angleB)
    {
        double a = angleA;
        double b = angleB;

        if (UseQuantization && QuantizationRadians > 0)
        {
            // Quantize to discrete bins
            a = Math.Floor(a / QuantizationRadians) * QuantizationRadians;
            b = Math.Floor(b / QuantizationRadians) * QuantizationRadians;
        }

        var diff = a - b;

        if (Epsilon > 0 && Math.Abs(diff) <= Epsilon)
        {
            return 0; // Angles are equal within tolerance
        }

        return diff.CompareTo(0.0);
    }
}


// --- PATH: contracts/Geosphere.Plate.Polygonization.Contracts/CMap/BoundaryCMapExtensions.cs ---
namespace FantaSim.Geosphere.Plate.Polygonization.Contracts.CMap;

/// <summary>
/// Extension methods for face-walking on boundary cmaps.
///
/// RFC-V2-0041 §11.2: Face-walk enumeration.
/// </summary>
public static class BoundaryCMapExtensions
{
    /// <summary>
    /// Walks the face loop starting from the given dart.
    /// Returns all darts in the face boundary in order.
    ///
    /// The walk follows Next repeatedly until returning to the start dart.
    /// </summary>
    /// <param name="cmap">The combinatorial map.</param>
    /// <param name="start">The starting dart.</param>
    /// <returns>All darts in the face, in traversal order.</returns>
    public static IReadOnlyList<BoundaryDart> WalkFace(this IBoundaryCMap cmap, BoundaryDart start)
    {
        var result = new List<BoundaryDart>();
        var current = start;

        do
        {
            result.Add(current);
            current = cmap.Next(current);

            // Safety: detect infinite loops (shouldn't happen in valid cmap)
            if (result.Count > 10_000)
            {
                throw new InvalidOperationException(
                    $"Face walk exceeded 10000 darts starting from {start}. Possible invalid cmap.");
            }
        }
        while (current != start);

        return result;
    }

    /// <summary>
    /// Enumerates all faces in the cmap.
    /// Each face is returned exactly once, represented by its dart list.
    ///
    /// Faces are enumerated in deterministic order:
    /// - Start with minimum unvisited dart (by BoundaryDart ordering)
    /// - Face-walk that dart
    /// - Mark all darts in face as visited
    /// - Repeat until no unvisited darts
    ///
    /// RFC-V2-0041 §11.2: Extract Faces algorithm.
    /// </summary>
    /// <param name="cmap">The combinatorial map.</param>
    /// <returns>All faces, each as a list of darts in traversal order.</returns>
    public static IEnumerable<IReadOnlyList<BoundaryDart>> EnumerateFaces(this IBoundaryCMap cmap)
    {
        var visited = new HashSet<BoundaryDart>();
        var sortedDarts = cmap.Darts.OrderBy(d => d).ToList();

        foreach (var dart in sortedDarts)
        {
            if (visited.Contains(dart))
                continue;

            var face = cmap.WalkFace(dart);

            foreach (var d in face)
                visited.Add(d);

            yield return face;
        }
    }
}


// --- PATH: contracts/Geosphere.Plate.Polygonization.Contracts/CMap/BoundaryDart.cs ---
using System.Runtime.InteropServices;
using FantaSim.Geosphere.Plate.Topology.Contracts.Entities;

namespace FantaSim.Geosphere.Plate.Polygonization.Contracts.CMap;

/// <summary>
/// Represents a directed half-edge (dart) in the boundary combinatorial map.
///
/// A dart is uniquely identified by (BoundaryId, SegmentIndex, Direction).
/// This forms a deterministic, stable key for reproducible face-walks.
///
/// RFC-V2-0041 §11: Darts are the atomic primitives of the cmap.
/// </summary>
/// <remarks>
/// <para>
/// <b>Determinism Contract</b>: This struct implements <see cref="IComparable{T}"/>
/// with a total ordering guarantee. The comparison is:
/// </para>
/// <list type="number">
///   <item>BoundaryId (GUID, lexicographic byte comparison)</item>
///   <item>SegmentIndex (int, ascending)</item>
///   <item>Direction (Forward &lt; Backward)</item>
/// </list>
/// <para>
/// This ordering is used as a tie-breaker when sorting darts by angle during
/// face enumeration. Without stable tie-breaking, collinear boundaries or
/// floating-point angle ties would cause non-deterministic face IDs.
/// </para>
/// <para>
/// <b>Usage in angle sorting</b>: When multiple darts at a junction have the
/// same angle (within floating-point tolerance), the sort falls back to
/// <see cref="CompareTo"/> to ensure the same cyclic order across runs.
/// </para>
/// </remarks>
[StructLayout(LayoutKind.Auto)]
public readonly record struct BoundaryDart : IComparable<BoundaryDart>
{
    /// <summary>
    /// The boundary this dart belongs to.
    /// </summary>
    public required BoundaryId BoundaryId { get; init; }

    /// <summary>
    /// The segment index within the boundary polyline.
    /// For boundaries treated as single segments (junction-to-junction), this is 0.
    /// </summary>
    public required int SegmentIndex { get; init; }

    /// <summary>
    /// Direction of traversal along the segment.
    /// </summary>
    public required DartDirection Direction { get; init; }

    /// <summary>
    /// Deterministic comparison for dart ordering.
    /// Order: BoundaryId → SegmentIndex → Direction.
    /// </summary>
    public int CompareTo(BoundaryDart other)
    {
        // Compare BoundaryId (GUID comparison)
        var boundaryCompare = BoundaryId.Value.CompareTo(other.BoundaryId.Value);
        if (boundaryCompare != 0) return boundaryCompare;

        // Compare SegmentIndex
        var segmentCompare = SegmentIndex.CompareTo(other.SegmentIndex);
        if (segmentCompare != 0) return segmentCompare;

        // Compare Direction (Forward < Backward)
        return Direction.CompareTo(other.Direction);
    }

    /// <summary>
    /// Creates a dart key string for debugging/logging.
    /// </summary>
    public override string ToString()
        => $"Dart({BoundaryId.Value.ToString("N").Substring(0, 8)}[{SegmentIndex}]{(Direction == DartDirection.Forward ? "→" : "←")})";

    public static bool operator <(BoundaryDart left, BoundaryDart right) => left.CompareTo(right) < 0;
    public static bool operator >(BoundaryDart left, BoundaryDart right) => left.CompareTo(right) > 0;
    public static bool operator <=(BoundaryDart left, BoundaryDart right) => left.CompareTo(right) <= 0;
    public static bool operator >=(BoundaryDart left, BoundaryDart right) => left.CompareTo(right) >= 0;
}


// --- PATH: contracts/Geosphere.Plate.Polygonization.Contracts/CMap/CMapBuildException.cs ---
namespace FantaSim.Geosphere.Plate.Polygonization.Contracts.CMap;

/// <summary>
/// Exception thrown when combinatorial map construction fails.
/// </summary>
public class CMapBuildException : Exception
{
    public CMapBuildException(string message) : base(message) { }
    public CMapBuildException(string message, Exception innerException) : base(message, innerException) { }
}


// --- PATH: contracts/Geosphere.Plate.Polygonization.Contracts/CMap/DartDirection.cs ---
namespace FantaSim.Geosphere.Plate.Polygonization.Contracts.CMap;

/// <summary>
/// Direction of a dart relative to its boundary segment.
/// Used as part of the deterministic dart key.
/// </summary>
public enum DartDirection
{
    /// <summary>
    /// Forward direction along the boundary (start → end).
    /// </summary>
    Forward = 0,

    /// <summary>
    /// Backward direction along the boundary (end → start).
    /// </summary>
    Backward = 1
}


// --- PATH: contracts/Geosphere.Plate.Polygonization.Contracts/CMap/DeterministicOrder.cs ---
﻿using FantaSim.Geosphere.Plate.Topology.Contracts.Entities;

namespace FantaSim.Geosphere.Plate.Polygonization.Contracts.CMap;

/// <summary>
/// Canonical deterministic ordering for darts and related topology elements.
/// </summary>
/// <remarks>
/// <para>
/// <b>Single Source of Truth</b>: All dart ordering in the codebase MUST use this class.
/// Do not invent ad-hoc sort keys elsewhere — that leads to "why did face IDs change?" bugs.
/// </para>
/// <para>
/// The ordering is designed to be:
/// </para>
/// <list type="bullet">
///   <item><b>Deterministic</b>: Same inputs always produce same order across runs/machines</item>
///   <item><b>Stable</b>: Small floating-point variations don't change order (via AnglePolicy)</item>
///   <item><b>Complete</b>: No ties possible — every distinct dart has a unique position</item>
/// </list>
/// <para>
/// Sort key precedence (first difference wins):
/// </para>
/// <list type="number">
///   <item>Angle (with AnglePolicy for stability)</item>
///   <item>JunctionId (stabilizes vertex-local ordering)</item>
///   <item>BoundaryId</item>
///   <item>SegmentIndex</item>
///   <item>Direction</item>
/// </list>
/// </remarks>
public static class DeterministicOrder
{
    /// <summary>
    /// Compares two darts for canonical ordering.
    /// </summary>
    /// <param name="policy">Angle comparison policy.</param>
    /// <param name="angleA">Angle of dart A in radians (typically from atan2).</param>
    /// <param name="dartA">Dart A.</param>
    /// <param name="junctionIdA">Junction ID where dart A originates (optional stabilizer).</param>
    /// <param name="angleB">Angle of dart B in radians.</param>
    /// <param name="dartB">Dart B.</param>
    /// <param name="junctionIdB">Junction ID where dart B originates.</param>
    /// <returns>
    /// Negative if A &lt; B, positive if A &gt; B, zero only if darts are identical.
    /// </returns>
    public static int CompareDarts(
        AnglePolicy policy,
        double angleA, BoundaryDart dartA, JunctionId junctionIdA,
        double angleB, BoundaryDart dartB, JunctionId junctionIdB)
    {
        // 1) Angle (with policy-based tolerance/quantization)
        var angleCompare = policy.CompareAngles(angleA, angleB);
        if (angleCompare != 0) return angleCompare;

        // 2) Junction (stabilizes vertex-local ordering when angles tie)
        var junctionCompare = junctionIdA.Value.CompareTo(junctionIdB.Value);
        if (junctionCompare != 0) return junctionCompare;

        // 3) Boundary, segment, direction (via BoundaryDart.CompareTo)
        return dartA.CompareTo(dartB);
    }

    /// <summary>
    /// Compares two darts for canonical ordering without junction context.
    /// Use when all darts share the same origin junction.
    /// </summary>
    /// <param name="policy">Angle comparison policy.</param>
    /// <param name="angleA">Angle of dart A in radians.</param>
    /// <param name="dartA">Dart A.</param>
    /// <param name="angleB">Angle of dart B in radians.</param>
    /// <param name="dartB">Dart B.</param>
    /// <returns>
    /// Negative if A &lt; B, positive if A &gt; B, zero only if darts are identical.
    /// </returns>
    public static int CompareDarts(
        AnglePolicy policy,
        double angleA, BoundaryDart dartA,
        double angleB, BoundaryDart dartB)
    {
        // 1) Angle (with policy-based tolerance/quantization)
        var angleCompare = policy.CompareAngles(angleA, angleB);
        if (angleCompare != 0) return angleCompare;

        // 2) Boundary, segment, direction (via BoundaryDart.CompareTo)
        return dartA.CompareTo(dartB);
    }

    /// <summary>
    /// Compares two darts using default angle policy.
    /// Convenience overload for most use cases.
    /// </summary>
    public static int CompareDarts(
        double angleA, BoundaryDart dartA,
        double angleB, BoundaryDart dartB)
        => CompareDarts(AnglePolicy.Default, angleA, dartA, angleB, dartB);

    /// <summary>
    /// Computes the outgoing angle of a direction vector (atan2).
    /// </summary>
    /// <param name="dx">X component of direction.</param>
    /// <param name="dy">Y component of direction.</param>
    /// <returns>Angle in radians, range [-π, π].</returns>
    public static double ComputeAngle(double dx, double dy)
        => Math.Atan2(dy, dx);
}


// --- PATH: contracts/Geosphere.Plate.Polygonization.Contracts/CMap/IBoundaryCMap.cs ---
using FantaSim.Geosphere.Plate.Topology.Contracts.Entities;

namespace FantaSim.Geosphere.Plate.Polygonization.Contracts.CMap;

/// <summary>
/// Minimal combinatorial map interface for boundary network polygonization.
///
/// This is the internal derived structure built from the topology boundary network.
/// It provides the three core relations needed for deterministic face-walking:
/// - Twin: opposite direction of the same edge segment
/// - Next: follow boundary forward along face loop
/// - Origin: junction at dart's starting point
///
/// RFC-V2-0041 §11: Minimal cmap subset v0.
/// </summary>
/// <remarks>
/// This interface is intentionally minimal. It does NOT include:
/// - Sewing/unsewing operations (deferred to RFC-V2-0043)
/// - Attribute containers
/// - Incremental updates
/// - Multi-dimensional orbits
///
/// The cmap is built fresh per tick from the topology state view.
/// </remarks>
public interface IBoundaryCMap
{
    /// <summary>
    /// All junctions (vertices) in the cmap.
    /// Enumerated in deterministic order (sorted by JunctionId).
    /// </summary>
    IEnumerable<JunctionId> Junctions { get; }

    /// <summary>
    /// All darts in the cmap.
    /// Enumerated in deterministic order (sorted by BoundaryDart key).
    /// </summary>
    IEnumerable<BoundaryDart> Darts { get; }

    /// <summary>
    /// Gets the origin junction (starting vertex) of a dart.
    /// </summary>
    /// <param name="dart">The dart to query.</param>
    /// <returns>The junction at the dart's origin.</returns>
    JunctionId Origin(BoundaryDart dart);

    /// <summary>
    /// Gets the twin dart (same edge, opposite direction).
    /// α involution in cmap terminology.
    /// </summary>
    /// <param name="dart">The dart to query.</param>
    /// <returns>The twin dart on the opposite side of the edge.</returns>
    BoundaryDart Twin(BoundaryDart dart);

    /// <summary>
    /// Gets the next dart in the face loop.
    /// Following Next repeatedly returns to the starting dart (closed face).
    /// β1 permutation in cmap terminology.
    /// </summary>
    /// <param name="dart">The dart to query.</param>
    /// <returns>The next dart in the face boundary.</returns>
    BoundaryDart Next(BoundaryDart dart);

    /// <summary>
    /// Gets all darts incident to a junction in deterministic cyclic order.
    /// Order is computed by angle around the junction (CCW from +X axis).
    /// Ties broken by BoundaryId.
    ///
    /// RFC-V2-0041 §9.1: Deterministic cyclic ordering at junctions.
    /// </summary>
    /// <param name="junction">The junction to query.</param>
    /// <returns>Incident darts in cyclic order (outgoing darts from this junction).</returns>
    IReadOnlyList<BoundaryDart> IncidentOrdered(JunctionId junction);

    /// <summary>
    /// Checks if a dart exists in this cmap.
    /// </summary>
    bool ContainsDart(BoundaryDart dart);
}


// --- PATH: contracts/Geosphere.Plate.Polygonization.Contracts/CMap/IBoundaryCMapBuilder.cs ---
using FantaSim.Geosphere.Plate.Topology.Contracts.Derived;

namespace FantaSim.Geosphere.Plate.Polygonization.Contracts.CMap;

/// <summary>
/// Factory for building a boundary combinatorial map from topology state.
///
/// RFC-V2-0041 §11.1: Build cmap from boundary network.
/// </summary>
public interface IBoundaryCMapBuilder
{
    /// <summary>
    /// Builds a combinatorial map from the topology state at a given tick.
    ///
    /// The builder:
    /// 1. Creates two darts per boundary segment (Forward/Backward)
    /// 2. Links twin darts
    /// 3. Sets origin junctions
    /// 4. Computes cyclic ordering at each junction
    /// 5. Sets Next pointers based on cyclic ordering
    /// </summary>
    /// <param name="topology">The topology state view to build from.</param>
    /// <returns>The constructed combinatorial map.</returns>
    /// <exception cref="CMapBuildException">
    /// Thrown when topology is invalid for cmap construction
    /// (e.g., boundary not connected to junctions).
    /// </exception>
    IBoundaryCMap Build(IPlateTopologyStateView topology);
}


// --- PATH: contracts/Geosphere.Plate.Polygonization.Contracts/Products/BoundaryFaceAdjacency.cs ---
using System.Collections.Immutable;
using System.Runtime.InteropServices;
using FantaSim.Geosphere.Plate.Topology.Contracts.Entities;
using MessagePack;
using Plate.TimeDete.Time.Primitives;

namespace FantaSim.Geosphere.Plate.Polygonization.Contracts.Products;

/// <summary>
/// Face adjacency for a boundary segment.
/// RFC-V2-0041 §6.3.
/// </summary>
[StructLayout(LayoutKind.Auto)]
[MessagePackObject]
public readonly record struct BoundaryFaceAdjacency(
    [property: Key(0)] BoundaryId BoundaryId,
    [property: Key(1)] int SegmentIndex,
    [property: Key(2)] PlateId LeftPlateId,
    [property: Key(3)] PlateId RightPlateId
);

/// <summary>
/// Complete boundary-to-face mapping at a tick.
/// RFC-V2-0041 §6.4.
/// </summary>
[StructLayout(LayoutKind.Auto)]
[MessagePackObject]
public readonly record struct BoundaryFaceAdjacencyMap(
    [property: Key(0)] CanonicalTick Tick,
    [property: Key(1)] ImmutableArray<BoundaryFaceAdjacency> Adjacencies
);


// --- PATH: contracts/Geosphere.Plate.Polygonization.Contracts/Products/PlatePolygon.cs ---
using System.Collections.Immutable;
using FantaSim.Geosphere.Plate.Topology.Contracts.Entities;
using MessagePack;
using UnifyGeometry;

namespace FantaSim.Geosphere.Plate.Polygonization.Contracts.Products;

/// <summary>
/// A closed plate region extracted from the boundary network.
/// RFC-V2-0041 §6.1.
/// </summary>
[MessagePackObject]
public readonly record struct PlatePolygon(
    [property: Key(0)] PlateId PlateId,
    [property: Key(1)] Polyline3 OuterRing,
    [property: Key(2)] ImmutableArray<Polyline3> Holes
);


// --- PATH: contracts/Geosphere.Plate.Polygonization.Contracts/Products/PlatePolygonSet.cs ---
using System.Collections.Immutable;
using System.Runtime.InteropServices;
using FantaSim.Geosphere.Plate.Topology.Contracts.Entities;
using MessagePack;
using Plate.TimeDete.Time.Primitives;

namespace FantaSim.Geosphere.Plate.Polygonization.Contracts.Products;

/// <summary>
/// Collection of all plate polygons at a tick.
/// RFC-V2-0041 §6.2.
/// </summary>
[StructLayout(LayoutKind.Auto)]
[MessagePackObject]
public readonly record struct PlatePolygonSet(
    [property: Key(0)] CanonicalTick Tick,
    [property: Key(1)] ImmutableArray<PlatePolygon> Polygons
)
{
    /// <summary>
    /// Lookup polygon by plate ID.
    /// </summary>
    public PlatePolygon? GetPolygon(PlateId plateId)
        => Polygons.FirstOrDefault(p => p.PlateId == plateId) is var match && match.PlateId != default
            ? match
            : null;
}


// --- PATH: contracts/Geosphere.Plate.Polygonization.Contracts/Products/PolygonizationDiagnostics.cs ---
using System.Collections.Immutable;
using System.Runtime.InteropServices;
using FantaSim.Geosphere.Plate.Topology.Contracts.Entities;
using UnifyGeometry;

namespace FantaSim.Geosphere.Plate.Polygonization.Contracts.Products;

/// <summary>
/// Diagnostic result from polygonization validation.
/// RFC-V2-0041 §8.2.
/// </summary>
[StructLayout(LayoutKind.Auto)]
public readonly record struct PolygonizationDiagnostics(
    bool IsValid,
    ImmutableArray<OpenBoundaryDiagnostic> OpenBoundaries,
    ImmutableArray<NonManifoldJunctionDiagnostic> NonManifoldJunctions,
    ImmutableArray<DisconnectedComponentDiagnostic> DisconnectedComponents
)
{
    public static PolygonizationDiagnostics Valid()
        => new(true,
            ImmutableArray<OpenBoundaryDiagnostic>.Empty,
            ImmutableArray<NonManifoldJunctionDiagnostic>.Empty,
            ImmutableArray<DisconnectedComponentDiagnostic>.Empty);
}

/// <summary>
/// Diagnostic for an open (non-closed) boundary.
/// </summary>
[StructLayout(LayoutKind.Auto)]
public readonly record struct OpenBoundaryDiagnostic(
    BoundaryId BoundaryId,
    Point3 OpenEndpoint,
    string Message
);

/// <summary>
/// Diagnostic for a non-manifold junction (invalid topology).
/// </summary>
public readonly record struct NonManifoldJunctionDiagnostic(
    JunctionId JunctionId,
    Point3 Position,
    int IncidentCount,
    string Message
);

/// <summary>
/// Diagnostic for a disconnected topology component.
/// </summary>
public readonly record struct DisconnectedComponentDiagnostic(
    int ComponentIndex,
    ImmutableArray<BoundaryId> Boundaries,
    string Message
);


// --- PATH: contracts/Geosphere.Plate.Polygonization.Contracts/Products/PolygonizationOptions.cs ---
using System.Runtime.InteropServices;

namespace FantaSim.Geosphere.Plate.Polygonization.Contracts.Products;

/// <summary>
/// Winding convention for polygon rings.
/// RFC-V2-0041 §7.
/// </summary>
public enum WindingConvention
{
    /// <summary>Outer rings are CCW, holes are CW (GeoJSON convention).</summary>
    CounterClockwise,

    /// <summary>Outer rings are CW, holes are CCW.</summary>
    Clockwise
}

/// <summary>
/// Options for plate polygonization.
/// RFC-V2-0041 §7.
/// </summary>
[StructLayout(LayoutKind.Auto)]
public readonly record struct PolygonizationOptions(
    WindingConvention Winding = WindingConvention.CounterClockwise,
    double SnapTolerance = 1e-9,
    bool AllowPartialPolygonization = false
);


// --- PATH: contracts/Geosphere.Plate.Polygonization.Contracts/Solvers/IPlatePolygonizer.cs ---
using FantaSim.Geosphere.Plate.Polygonization.Contracts.Products;
using FantaSim.Geosphere.Plate.Topology.Contracts.Derived;
using Plate.TimeDete.Time.Primitives;

namespace FantaSim.Geosphere.Plate.Polygonization.Contracts.Solvers;

/// <summary>
/// Solver for extracting plate polygons from boundary network.
/// RFC-V2-0041 §8.1.
/// </summary>
public interface IPlatePolygonizer
{
    /// <summary>
    /// Extracts all plate polygons at the given tick.
    /// </summary>
    /// <param name="tick">The reconstruction tick.</param>
    /// <param name="topology">The topology state view.</param>
    /// <param name="options">Polygonization options (optional).</param>
    /// <returns>The set of plate polygons.</returns>
    /// <exception cref="PolygonizationException">
    /// Thrown when topology is invalid (open boundaries, non-manifold junctions).
    /// </exception>
    PlatePolygonSet PolygonizeAtTick(
        CanonicalTick tick,
        IPlateTopologyStateView topology,
        PolygonizationOptions? options = null);

    /// <summary>
    /// Extracts boundary-face adjacency map at the given tick.
    /// </summary>
    /// <param name="tick">The reconstruction tick.</param>
    /// <param name="topology">The topology state view.</param>
    /// <param name="options">Polygonization options (optional).</param>
    /// <returns>The boundary-to-face adjacency mapping.</returns>
    BoundaryFaceAdjacencyMap GetBoundaryFaceAdjacency(
        CanonicalTick tick,
        IPlateTopologyStateView topology,
        PolygonizationOptions? options = null);

    /// <summary>
    /// Validates that the topology can be polygonized.
    /// Returns diagnostics without throwing.
    /// </summary>
    /// <param name="tick">The reconstruction tick.</param>
    /// <param name="topology">The topology state view.</param>
    /// <param name="options">Polygonization options (optional).</param>
    /// <returns>Diagnostic result with validation details.</returns>
    PolygonizationDiagnostics Validate(
        CanonicalTick tick,
        IPlateTopologyStateView topology,
        PolygonizationOptions? options = null);
}


// --- PATH: contracts/Geosphere.Plate.Polygonization.Contracts/Solvers/PolygonizationException.cs ---
using FantaSim.Geosphere.Plate.Polygonization.Contracts.Products;

namespace FantaSim.Geosphere.Plate.Polygonization.Contracts.Solvers;

/// <summary>
/// Exception thrown when polygonization fails due to invalid topology.
/// </summary>
public class PolygonizationException : Exception
{
    /// <summary>
    /// Diagnostics about why polygonization failed.
    /// </summary>
    public PolygonizationDiagnostics Diagnostics { get; }

    public PolygonizationException(string message, PolygonizationDiagnostics diagnostics)
        : base(message)
    {
        Diagnostics = diagnostics;
    }

    public PolygonizationException(string message, PolygonizationDiagnostics diagnostics, Exception innerException)
        : base(message, innerException)
    {
        Diagnostics = diagnostics;
    }
}


// --- PATH: contracts/Geosphere.Plate.Reconstruction.Contracts/FeatureId.cs ---
using MessagePack;

namespace FantaSim.Geosphere.Plate.Reconstruction.Contracts;

[MessagePackObject]
public readonly record struct FeatureId
{
    private readonly Guid _value;

    [SerializationConstructor]
    public FeatureId(Guid value)
    {
        _value = value;
    }

    [Key(0)]
    public Guid Value => _value;

    [IgnoreMember]
    public bool IsEmpty => _value == Guid.Empty;

    public static FeatureId Parse(string value)
    {
        if (string.IsNullOrWhiteSpace(value))
            throw new ArgumentException("FeatureId value cannot be null or whitespace.", nameof(value));

        if (!Guid.TryParse(value, out var guid))
            throw new ArgumentException($"Invalid FeatureId format: {value}", nameof(value));

        if (guid == Guid.Empty)
            throw new ArgumentException("FeatureId value cannot be Guid.Empty.", nameof(value));

        return new FeatureId(guid);
    }

    public static bool TryParse(string value, out FeatureId featureId)
    {
        if (!string.IsNullOrWhiteSpace(value) && Guid.TryParse(value, out var guid) && guid != Guid.Empty)
        {
            featureId = new FeatureId(guid);
            return true;
        }

        featureId = default;
        return false;
    }

    public override string ToString() => _value.ToString("D");
}


// --- PATH: contracts/Geosphere.Plate.Reconstruction.Contracts/IFeaturePlateAssigner.cs ---
namespace FantaSim.Geosphere.Plate.Reconstruction.Contracts;

public interface IFeaturePlateAssigner
{
    IReadOnlyList<ReconstructableFeature> AssignPlateProvenance(
        IReadOnlyList<ReconstructableFeature> features,
        IReadOnlyList<PlatePartitionRegion> partition);
}


// --- PATH: contracts/Geosphere.Plate.Reconstruction.Contracts/IPlateFeatureReconstructionSolver.cs ---
using Plate.TimeDete.Time.Primitives;
using FantaSim.Geosphere.Plate.Kinematics.Contracts.Derived;
using FantaSim.Geosphere.Plate.Reconstruction.Contracts.Output;

namespace FantaSim.Geosphere.Plate.Reconstruction.Contracts;

public interface IPlateFeatureReconstructionSolver
{
    IReadOnlyList<ReconstructedFeature> ReconstructFeatures(
        IReadOnlyList<ReconstructableFeature> features,
        IPlateKinematicsStateView kinematics,
        CanonicalTick targetTick,
        ReconstructionOptions? options = null);
}


// --- PATH: contracts/Geosphere.Plate.Reconstruction.Contracts/IPlateReconstructionSolver.cs ---
using Plate.TimeDete.Time.Primitives;
using FantaSim.Geosphere.Plate.Kinematics.Contracts.Derived;
using FantaSim.Geosphere.Plate.Reconstruction.Contracts.Output;
using FantaSim.Geosphere.Plate.Topology.Contracts.Derived;

namespace FantaSim.Geosphere.Plate.Reconstruction.Contracts;

public interface IPlateReconstructionSolver
{
    IReadOnlyList<ReconstructedBoundary> ReconstructBoundaries(
        IPlateTopologyStateView topology,
        IPlateKinematicsStateView kinematics,
        CanonicalTick targetTick,
        ReconstructionOptions? options = null);
}


// --- PATH: contracts/Geosphere.Plate.Reconstruction.Contracts/Output/ReconstructedBoundary.cs ---
using FantaSim.Geosphere.Plate.Topology.Contracts.Entities;
using UnifyGeometry;

namespace FantaSim.Geosphere.Plate.Reconstruction.Contracts.Output;

/// <summary>
/// Reconstructed boundary geometry at a target tick.
///
/// Normative: each output element carries a single PlateId provenance (RFC-V2-0024 §4).
/// </summary>
public readonly record struct ReconstructedBoundary(
    BoundaryId BoundaryId,
    PlateId PlateIdProvenance,
    IGeometry Geometry);


// --- PATH: contracts/Geosphere.Plate.Reconstruction.Contracts/Output/ReconstructedFeature.cs ---
using FantaSim.Geosphere.Plate.Topology.Contracts.Entities;
using UnifyGeometry;

namespace FantaSim.Geosphere.Plate.Reconstruction.Contracts.Output;

public readonly record struct ReconstructedFeature(
    FeatureId FeatureId,
    PlateId PlateIdProvenance,
    IGeometry Geometry);


// --- PATH: contracts/Geosphere.Plate.Reconstruction.Contracts/PlatePartitionRegion.cs ---
using FantaSim.Geosphere.Plate.Topology.Contracts.Entities;
using UnifyGeometry;

namespace FantaSim.Geosphere.Plate.Reconstruction.Contracts;

public sealed record PlatePartitionRegion(
    PlateId PlateId,
    PolygonRegion2 Region);


// --- PATH: contracts/Geosphere.Plate.Reconstruction.Contracts/ReconstructableFeature.cs ---
using FantaSim.Geosphere.Plate.Topology.Contracts.Entities;
using UnifyGeometry;

namespace FantaSim.Geosphere.Plate.Reconstruction.Contracts;

public sealed record ReconstructableFeature(
    FeatureId FeatureId,
    IGeometry Geometry,
    PlateId? PlateIdProvenance);


// --- PATH: contracts/Geosphere.Plate.Reconstruction.Contracts/ReconstructionOptions.cs ---
namespace FantaSim.Geosphere.Plate.Reconstruction.Contracts;

public sealed class ReconstructionOptions
{
    public static readonly ReconstructionOptions Default = new();
}


// --- PATH: contracts/Geosphere.Plate.Runtime.Des.Contracts/IDesRuntimeFactory.cs ---
using FantaSim.Geosphere.Plate.Runtime.Des.Runtime;
using FantaSim.Geosphere.Plate.Topology.Contracts.Identity;

namespace FantaSim.Geosphere.Plate.Runtime.Des;

/// <summary>
/// Factory for creating configured DES Runtimes for specific truth streams.
/// </summary>
public interface IDesRuntimeFactory
{
    /// <summary>
    /// Creates a new DES Runtime instance for the specified stream.
    /// </summary>
    /// <param name="streamIdentity">The identity of the truth stream to simulate.</param>
    /// <returns>A configured runtime instance.</returns>
    IDesRuntime Create(TruthStreamIdentity streamIdentity);
}


// --- PATH: contracts/Geosphere.Plate.Runtime.Des.Contracts/Runtime/IDesRuntime.cs ---
﻿using System.Threading;
using System.Threading.Tasks;
using FantaSim.Geosphere.Plate.Topology.Contracts.Identity;
using Plate.TimeDete.Time.Primitives;

namespace FantaSim.Geosphere.Plate.Runtime.Des.Runtime;

public record DesRunResult(
    int ItemsProcessed,
    int EventsAppended
);

/// <summary>
/// Options for running the DES simulation loop.
/// </summary>
/// <param name="StartTick">The tick to start simulation from.</param>
/// <param name="EndTick">Optional tick to end simulation at.</param>
/// <param name="ScenarioSeed">The scenario seed for deterministic RNG derivation.
/// Required for reproducible event ID generation.</param>
/// <param name="MaxItemsProcessed">Maximum number of work items to process.</param>
/// <param name="MaxEventsAppended">Maximum number of events to append.</param>
public record DesRunOptions(
    CanonicalTick StartTick,
    CanonicalTick? EndTick,
    ulong ScenarioSeed,
    int MaxItemsProcessed = 1000,
    int MaxEventsAppended = 1000
);

public interface IDesRuntime
{
    Task<DesRunResult> RunAsync(
        TruthStreamIdentity stream,
        DesRunOptions options,
        CancellationToken ct = default);
}


// --- PATH: contracts/Geosphere.Plate.Topology.Contracts/Capabilities/ITruthStreamCapabilities.cs ---
using FantaSim.Geosphere.Plate.Topology.Contracts.Identity;

namespace FantaSim.Geosphere.Plate.Topology.Contracts.Capabilities;

/// <summary>
/// Provides queryable capabilities for a truth stream.
///
/// Capabilities are persisted metadata that describe properties of the stream,
/// such as whether tick monotonicity has been enforced since genesis.
/// These capabilities enable safe optimizations in materialization.
///
/// Implementation note: Capabilities should only be set when provably true.
/// If uncertain, the capability should not be set (query returns false).
/// </summary>
public interface ITruthStreamCapabilities
{
    /// <summary>
    /// Checks if the stream has proven tick monotonicity from genesis.
    ///
    /// Returns true only if:
    /// - The stream was created with TickMonotonicityPolicy.Reject, AND
    /// - That policy has been enforced since the first event (genesis)
    ///
    /// If true, tick-based materialization can safely break early on
    /// first event.Tick &gt; targetTick, improving performance.
    ///
    /// If false or uncertain, callers must scan all events for correctness.
    /// </summary>
    /// <param name="stream">The truth stream identity to query.</param>
    /// <param name="cancellationToken">Cancellation token.</param>
    /// <returns>True if tick monotonicity is proven from genesis; false otherwise.</returns>
    ValueTask<bool> IsTickMonotoneFromGenesisAsync(
        TruthStreamIdentity stream,
        CancellationToken cancellationToken = default);
}


// --- PATH: contracts/Geosphere.Plate.Topology.Contracts/Capabilities/StreamCapabilities.cs ---
namespace FantaSim.Geosphere.Plate.Topology.Contracts.Capabilities;

/// <summary>
/// Parsed representation of stream capabilities stored in Meta:Caps.
///
/// Storage format (9 bytes):
/// - Byte 0: Schema version (currently 0x01)
/// - Bytes 1-8: Flags as UInt64 little-endian
///
/// Flag bits:
/// - Bit 0: TickMonotoneFromGenesis
/// - Bit 1: TickPolicyRejectFromGenesis
/// - Bits 2-63: Reserved (must be 0)
/// </summary>
public readonly struct StreamCapabilities : IEquatable<StreamCapabilities>
{
    /// <summary>
    /// Current schema version for capabilities storage.
    /// </summary>
    public const byte CurrentSchemaVersion = 0x01;

    /// <summary>
    /// Storage size in bytes: 1 (version) + 8 (flags).
    /// </summary>
    public const int StorageSize = 9;

    // Flag bit positions
    private const int BitTickMonotoneFromGenesis = 0;
    private const int BitTickPolicyRejectFromGenesis = 1;

    private readonly ulong _flags;

    /// <summary>
    /// Creates capabilities with specified flags.
    /// </summary>
    public StreamCapabilities(ulong flags)
    {
        _flags = flags;
    }

    /// <summary>
    /// Empty capabilities (no flags set).
    /// </summary>
    public static StreamCapabilities None => new(0);

    /// <summary>
    /// Creates capabilities for a genesis stream with Reject tick policy.
    /// Sets both TickMonotoneFromGenesis and TickPolicyRejectFromGenesis.
    /// </summary>
    public static StreamCapabilities GenesisWithRejectPolicy =>
        new((1UL << BitTickMonotoneFromGenesis) | (1UL << BitTickPolicyRejectFromGenesis));

    /// <summary>
    /// True if the stream has proven tick monotonicity from genesis.
    /// </summary>
    public bool IsTickMonotoneFromGenesis => (_flags & (1UL << BitTickMonotoneFromGenesis)) != 0;

    /// <summary>
    /// True if the stream was created with TickMonotonicityPolicy.Reject.
    /// </summary>
    public bool IsTickPolicyRejectFromGenesis => (_flags & (1UL << BitTickPolicyRejectFromGenesis)) != 0;

    /// <summary>
    /// Raw flags value.
    /// </summary>
    public ulong Flags => _flags;

    /// <summary>
    /// Serializes capabilities to bytes.
    /// </summary>
    /// <returns>9-byte array: [version, flags(8 bytes LE)]</returns>
    public byte[] ToBytes()
    {
        var bytes = new byte[StorageSize];
        bytes[0] = CurrentSchemaVersion;
        BitConverter.TryWriteBytes(bytes.AsSpan(1), _flags); // Little-endian on most platforms
        if (!BitConverter.IsLittleEndian)
        {
            // Ensure little-endian
            Array.Reverse(bytes, 1, 8);
        }
        return bytes;
    }

    /// <summary>
    /// Deserializes capabilities from bytes.
    /// </summary>
    /// <param name="bytes">At least 9 bytes.</param>
    /// <returns>Parsed capabilities, or None if invalid/unsupported.</returns>
    public static StreamCapabilities FromBytes(ReadOnlySpan<byte> bytes)
    {
        if (bytes.Length < StorageSize)
            return None;

        var version = bytes[0];
        if (version != CurrentSchemaVersion)
            return None; // Unknown version - treat as no capabilities

        ulong flags;
        if (BitConverter.IsLittleEndian)
        {
            flags = BitConverter.ToUInt64(bytes.Slice(1, 8));
        }
        else
        {
            // Convert from little-endian
            Span<byte> temp = stackalloc byte[8];
            bytes.Slice(1, 8).CopyTo(temp);
            temp.Reverse();
            flags = BitConverter.ToUInt64(temp);
        }

        return new StreamCapabilities(flags);
    }

    /// <summary>
    /// Returns a new capabilities with TickMonotoneFromGenesis set.
    /// </summary>
    public StreamCapabilities WithTickMonotoneFromGenesis() =>
        new(_flags | (1UL << BitTickMonotoneFromGenesis));

    /// <summary>
    /// Returns a new capabilities with TickPolicyRejectFromGenesis set.
    /// </summary>
    public StreamCapabilities WithTickPolicyRejectFromGenesis() =>
        new(_flags | (1UL << BitTickPolicyRejectFromGenesis));

    public bool Equals(StreamCapabilities other) => _flags == other._flags;
    public override bool Equals(object? obj) => obj is StreamCapabilities other && Equals(other);
    public override int GetHashCode() => _flags.GetHashCode();
    public static bool operator ==(StreamCapabilities left, StreamCapabilities right) => left.Equals(right);
    public static bool operator !=(StreamCapabilities left, StreamCapabilities right) => !left.Equals(right);

    public override string ToString() =>
        $"StreamCapabilities(Monotone={IsTickMonotoneFromGenesis}, RejectPolicy={IsTickPolicyRejectFromGenesis})";
}


// --- PATH: contracts/Geosphere.Plate.Topology.Contracts/Capabilities/TickMaterializationMode.cs ---
namespace FantaSim.Geosphere.Plate.Topology.Contracts.Capabilities;

/// <summary>
/// Controls how tick-based materialization iterates through events.
///
/// Background: Events are ordered by Sequence number, but their Tick values
/// (simulation time) may not be monotonic. This creates a tradeoff:
/// - Correctness requires scanning all events if ticks might decrease
/// - Performance benefits from breaking early if ticks are guaranteed monotonic
///
/// This enum controls that tradeoff.
/// </summary>
public enum TickMaterializationMode
{
    /// <summary>
    /// Scan all events and apply those with tick &lt;= targetTick.
    /// Correct for all streams regardless of tick monotonicity.
    /// This is the safest option but may be slower for large streams.
    /// </summary>
    ScanAll = 0,

    /// <summary>
    /// Break iteration on first event where tick &gt; targetTick.
    /// ONLY safe if the stream is proven tick-monotone from genesis.
    /// Using this on a non-monotone stream will produce incorrect results.
    /// </summary>
    BreakOnFirstBeyondTick = 1,

    /// <summary>
    /// Default: automatically choose based on stream capabilities.
    /// - If store can prove tick monotonicity ??BreakOnFirstBeyondTick
    /// - Otherwise ??ScanAll
    ///
    /// This gives optimal performance when safe, and correct results always.
    /// </summary>
    Auto = 2
}


// --- PATH: contracts/Geosphere.Plate.Topology.Contracts/Derived/IDerivedProductGenerator.cs ---
namespace FantaSim.Geosphere.Plate.Topology.Contracts.Derived;

public interface IDerivedProductGenerator<TProduct>
{
    TProduct Generate(IPlateTopologyStateView state);
}


// --- PATH: contracts/Geosphere.Plate.Topology.Contracts/Derived/IPlateTopologySnapshotStore.cs ---
using FantaSim.Geosphere.Plate.Topology.Contracts.Identity;

namespace FantaSim.Geosphere.Plate.Topology.Contracts.Derived;

public interface IPlateTopologySnapshotStore
{
    /// <summary>
    /// Saves a snapshot at a specific (stream, tick) point.
    /// </summary>
    Task SaveSnapshotAsync(PlateTopologySnapshot snapshot, CancellationToken cancellationToken);

    /// <summary>
    /// Gets the snapshot at an exact (stream, tick) key.
    /// Returns null if no snapshot exists at that exact tick.
    /// </summary>
    Task<PlateTopologySnapshot?> GetSnapshotAsync(PlateTopologyMaterializationKey key, CancellationToken cancellationToken);

    /// <summary>
    /// Gets the latest snapshot at or before the specified tick.
    /// This uses SeekForPrev to find the largest tick &lt;= targetTick.
    /// Returns null if no snapshot exists at or before the target tick.
    ///
    /// This is the key method for efficient "deep time" queries:
    /// load a nearby snapshot, then replay only the tail of events.
    /// </summary>
    Task<PlateTopologySnapshot?> GetLatestSnapshotBeforeAsync(
        TruthStreamIdentity stream,
        long targetTick,
        CancellationToken cancellationToken);
}


// --- PATH: contracts/Geosphere.Plate.Topology.Contracts/Derived/IPlateTopologyStateView.cs ---
using PlateEntity = FantaSim.Geosphere.Plate.Topology.Contracts.Entities.Plate;
using BoundaryEntity = FantaSim.Geosphere.Plate.Topology.Contracts.Entities.Boundary;
using JunctionEntity = FantaSim.Geosphere.Plate.Topology.Contracts.Entities.Junction;
using FantaSim.Geosphere.Plate.Topology.Contracts.Entities;
using FantaSim.Geosphere.Plate.Topology.Contracts.Identity;

namespace FantaSim.Geosphere.Plate.Topology.Contracts.Derived;

public interface IPlateTopologyStateView
{
    TruthStreamIdentity Identity { get; }

    IReadOnlyDictionary<PlateId, PlateEntity> Plates { get; }

    IReadOnlyDictionary<BoundaryId, BoundaryEntity> Boundaries { get; }

    IReadOnlyDictionary<JunctionId, JunctionEntity> Junctions { get; }

    long LastEventSequence { get; }
}


// --- PATH: contracts/Geosphere.Plate.Topology.Contracts/Derived/PlateAdjacencyGraph.cs ---
using System.Runtime.InteropServices;
using FantaSim.Geosphere.Plate.Topology.Contracts.Entities;
using FantaSim.Geosphere.Plate.Topology.Contracts.Identity;

namespace FantaSim.Geosphere.Plate.Topology.Contracts.Derived;

[StructLayout(LayoutKind.Auto)]
public readonly record struct PlateAdjacency(
    PlateId PlateId,
    BoundaryType BoundaryType
);

[StructLayout(LayoutKind.Auto)]
public readonly record struct PlateAdjacencyGraph(
    IReadOnlyDictionary<PlateId, List<PlateAdjacency>> Adjacencies
);


// --- PATH: contracts/Geosphere.Plate.Topology.Contracts/Derived/PlateTopologyMaterializationKey.cs ---
using System.Runtime.InteropServices;
using FantaSim.Geosphere.Plate.Topology.Contracts.Identity;

namespace FantaSim.Geosphere.Plate.Topology.Contracts.Derived;

/// <summary>
/// Cache key for materialized topology state.
/// </summary>
/// <remarks>
/// <para>
/// Includes both the target tick and the <b>last sequence at time of materialization</b>.
/// This is critical for correctness with back-in-time events: if an event is later appended
/// with tick <= targetTick, the old cache entry becomes invalid. By including the sequence
/// number, we ensure cache misses when the event stream changes.
/// </para>
/// </remarks>
/// <param name="Stream">The truth stream identity.</param>
/// <param name="Tick">The target simulation tick.</param>
/// <param name="LastSequence">The last event sequence at time of materialization.</param>
[StructLayout(LayoutKind.Auto)]
public readonly record struct PlateTopologyMaterializationKey(
    TruthStreamIdentity Stream,
    long Tick,
    long LastSequence);


// --- PATH: contracts/Geosphere.Plate.Topology.Contracts/Derived/PlateTopologySnapshot.cs ---
using FantaSim.Geosphere.Plate.Topology.Contracts.Entities;
using FantaSim.Geosphere.Plate.Topology.Contracts.Identity;
using PlateEntity = FantaSim.Geosphere.Plate.Topology.Contracts.Entities.Plate;

namespace FantaSim.Geosphere.Plate.Topology.Contracts.Derived;

public readonly record struct PlateTopologySnapshot(
    PlateTopologyMaterializationKey Key,
    long LastEventSequence,
    PlateEntity[] Plates,
    Boundary[] Boundaries,
    Junction[] Junctions);


// --- PATH: contracts/Geosphere.Plate.Topology.Contracts/Determinism/FnvSolverSeedProvider.cs ---
﻿using Plate.TimeDete.Determinism.Abstractions;
using Plate.TimeDete.Time.Primitives;
using FantaSim.Geosphere.Plate.Topology.Contracts.Identity;

namespace FantaSim.Geosphere.Plate.Topology.Contracts.Determinism;

/// <summary>
/// Default implementation of ISolverSeedProvider using FNV-1a hash for seed derivation.
///
/// Derivation algorithm "FNV1a-StreamIdentity-v2":
/// 1. Start with FNV offset basis
/// 2. Mix in scenario seed
/// 3. Mix in stream identity components in canonical order with length-prefixing:
///    VariantId, BranchId, LLevel, Domain, Model
///    Each string is prefixed with its length to prevent collision between
///    (VariantId="a", BranchId="bc") and (VariantId="ab", BranchId="c").
/// 4. Finalize with avalanche function
///
/// This produces well-distributed seeds even for similar inputs.
/// </summary>
public sealed class FnvSolverSeedProvider : ISolverSeedProvider
{
    private const string AlgorithmName = "FNV1a-StreamIdentity-v2";
    private const ulong FnvOffsetBasis = 0xcbf29ce484222325UL;
    private const ulong FnvPrime = 0x100000001b3UL;

    private readonly ISeededRngFactory _rngFactory;

    /// <summary>
    /// Creates a new FnvSolverSeedProvider with the specified RNG factory.
    /// </summary>
    /// <param name="rngFactory">Factory for creating seeded RNG instances.</param>
    public FnvSolverSeedProvider(ISeededRngFactory rngFactory)
    {
        _rngFactory = rngFactory ?? throw new ArgumentNullException(nameof(rngFactory));
    }

    /// <inheritdoc />
    /// <exception cref="ArgumentException">Thrown when stream identity is not valid.</exception>
    public ulong DeriveSeed(ulong scenarioSeed, TruthStreamIdentity stream)
    {
        // Validate stream identity to prevent accidental seed sharing
        if (!stream.IsValid())
        {
            throw new ArgumentException(
                $"TruthStreamIdentity is not valid: {stream}. " +
                "Cannot derive seed from invalid identity as it may cause unintended collisions.",
                nameof(stream));
        }

        // Start with FNV offset and mix in scenario seed
        var hash = FnvOffsetBasis;
        hash = MixUInt64(hash, scenarioSeed);

        // Mix in stream identity components in canonical order with length-prefixing
        // Length-prefix prevents collision: ("a","bc") vs ("ab","c") now differ
        hash = MixLengthPrefixedString(hash, stream.VariantId);
        hash = MixLengthPrefixedString(hash, stream.BranchId);
        hash = MixInt32(hash, stream.LLevel);
        hash = MixLengthPrefixedString(hash, stream.Domain.Value);
        hash = MixLengthPrefixedString(hash, stream.Model);

        // Final avalanche to improve distribution
        return Avalanche(hash);
    }

    /// <inheritdoc />
    public ISeededRng CreateRng(ulong scenarioSeed, TruthStreamIdentity stream)
    {
        var derivedSeed = DeriveSeed(scenarioSeed, stream);
        return _rngFactory.Create(derivedSeed);
    }

    /// <inheritdoc />
    public ISeededRng CreateRngForTick(ulong scenarioSeed, TruthStreamIdentity stream, CanonicalTick tick)
    {
        // First derive the stream-scoped seed
        var streamSeed = DeriveSeed(scenarioSeed, stream);

        // Then mix in the tick value to get a tick-specific seed
        // This ensures each tick gets an independent RNG stream while remaining deterministic
        var tickSeed = MixUInt64(streamSeed, (ulong)tick.Value);
        tickSeed = Avalanche(tickSeed);

        return _rngFactory.Create(tickSeed);
    }

    /// <inheritdoc />
    public SeedDerivationAuditRecord GetSeedAuditRecord(ulong scenarioSeed, TruthStreamIdentity stream)
    {
        var derivedSeed = DeriveSeed(scenarioSeed, stream);
        return new SeedDerivationAuditRecord(
            ScenarioSeed: scenarioSeed,
            StreamIdentity: stream,
            DerivedSeed: derivedSeed,
            DerivationAlgorithm: AlgorithmName
        );
    }

    private static ulong MixUInt64(ulong hash, ulong value)
    {
        // Mix 8 bytes of the value
        for (int i = 0; i < 8; i++)
        {
            hash ^= (value >> (i * 8)) & 0xFF;
            hash *= FnvPrime;
        }
        return hash;
    }

    private static ulong MixInt32(ulong hash, int value)
    {
        // Mix 4 bytes of the value
        for (int i = 0; i < 4; i++)
        {
            hash ^= (uint)((value >> (i * 8)) & 0xFF);
            hash *= FnvPrime;
        }
        return hash;
    }

    /// <summary>
    /// Mix a string with length-prefix to prevent concatenation collisions.
    /// E.g., ("a","bc") vs ("ab","c") will produce different hashes.
    /// </summary>
    private static ulong MixLengthPrefixedString(ulong hash, string value)
    {
        // First mix the length as a 32-bit value
        hash = MixInt32(hash, value.Length);

        // Then mix the characters
        foreach (var c in value)
        {
            hash ^= c;
            hash *= FnvPrime;
        }
        return hash;
    }

    private static ulong Avalanche(ulong hash)
    {
        // Finalization mix (similar to SplitMix64)
        hash = (hash ^ (hash >> 30)) * 0xbf58476d1ce4e5b9UL;
        hash = (hash ^ (hash >> 27)) * 0x94d049bb133111ebUL;
        return hash ^ (hash >> 31);
    }
}


// --- PATH: contracts/Geosphere.Plate.Topology.Contracts/Determinism/ISolverSeedProvider.cs ---
﻿using Plate.TimeDete.Determinism.Abstractions;
using Plate.TimeDete.Time.Primitives;
using FantaSim.Geosphere.Plate.Topology.Contracts.Identity;

namespace FantaSim.Geosphere.Plate.Topology.Contracts.Determinism;

/// <summary>
/// Provides deterministic seed derivation from stream identity for solver implementations.
///
/// Per RFC-099 guidance, solvers require:
/// 1. Deterministic seed derivation tied to stream identity
/// 2. Auditable seed provenance
/// 3. Reproducible RNG streams for identical inputs
///
/// Implementations derive seeds from TruthStreamIdentity components, ensuring that:
/// - Same stream identity + scenario seed ??same RNG sequence
/// - Different streams ??independent RNG sequences
/// - Seed derivation is auditable via GetSeedAuditRecord()
/// </summary>
public interface ISolverSeedProvider
{
    /// <summary>
    /// Derives a solver seed from a scenario seed and truth stream identity.
    ///
    /// The derivation is deterministic: identical inputs always produce identical seeds.
    /// This enables replay determinism when the scenario seed is preserved.
    /// </summary>
    /// <param name="scenarioSeed">Base seed for the scenario (e.g., from world config).</param>
    /// <param name="stream">The truth stream identity to incorporate into seed derivation.</param>
    /// <returns>A derived seed unique to this scenario + stream combination.</returns>
    ulong DeriveSeed(ulong scenarioSeed, TruthStreamIdentity stream);

    /// <summary>
    /// Creates an RNG instance seeded for the specified stream.
    ///
    /// This is a convenience method combining DeriveSeed + factory creation.
    /// </summary>
    /// <param name="scenarioSeed">Base seed for the scenario.</param>
    /// <param name="stream">The truth stream identity.</param>
    /// <returns>A seeded RNG instance for deterministic generation.</returns>
    ISeededRng CreateRng(ulong scenarioSeed, TruthStreamIdentity stream);

    /// <summary>
    /// Creates a tick-scoped RNG instance for deterministic event generation within DES.
    ///
    /// The tick is incorporated into the seed derivation to ensure that:
    /// - Same (scenarioSeed, stream, tick) → same RNG sequence
    /// - Different ticks → independent RNG sequences
    ///
    /// This is critical for DES determinism where multiple events may be generated
    /// at the same tick and must be reproducible across runs.
    /// </summary>
    /// <param name="scenarioSeed">Base seed for the scenario.</param>
    /// <param name="stream">The truth stream identity.</param>
    /// <param name="tick">The current canonical tick.</param>
    /// <returns>A tick-scoped seeded RNG instance for deterministic generation.</returns>
    ISeededRng CreateRngForTick(ulong scenarioSeed, TruthStreamIdentity stream, CanonicalTick tick);

    /// <summary>
    /// Gets an audit record for a seed derivation operation.
    ///
    /// The audit record contains all inputs and the derived output for traceability.
    /// </summary>
    /// <param name="scenarioSeed">Base seed for the scenario.</param>
    /// <param name="stream">The truth stream identity.</param>
    /// <returns>An audit record capturing the derivation.</returns>
    SeedDerivationAuditRecord GetSeedAuditRecord(ulong scenarioSeed, TruthStreamIdentity stream);
}

/// <summary>
/// Audit record for seed derivation operations per RFC-099 traceability requirements.
/// </summary>
/// <param name="ScenarioSeed">The input scenario seed.</param>
/// <param name="StreamIdentity">The truth stream identity used in derivation.</param>
/// <param name="DerivedSeed">The output derived seed.</param>
/// <param name="DerivationAlgorithm">Identifier for the derivation algorithm (for versioning).</param>
public readonly record struct SeedDerivationAuditRecord(
    ulong ScenarioSeed,
    TruthStreamIdentity StreamIdentity,
    ulong DerivedSeed,
    string DerivationAlgorithm
);


// --- PATH: contracts/Geosphere.Plate.Topology.Contracts/Entities/Boundary.cs ---
using UnifyGeometry;

namespace FantaSim.Geosphere.Plate.Topology.Contracts.Entities;

public readonly record struct Boundary(
    BoundaryId BoundaryId,
    PlateId PlateIdLeft,
    PlateId PlateIdRight,
    BoundaryType BoundaryType,
    IGeometry Geometry,
    bool IsRetired,
    string? RetirementReason
);


// --- PATH: contracts/Geosphere.Plate.Topology.Contracts/Entities/BoundaryId.cs ---
using System.Runtime.InteropServices;
using Plate.TimeDete.Determinism.Abstractions;
using MessagePack;

namespace FantaSim.Geosphere.Plate.Topology.Contracts.Entities;

/// <summary>
/// Stable identifier representing a boundary segment/edge between plates per FR-005.
///
/// Each boundary has a type classification and geometric representation.
/// Boundaries separate exactly two plates except for explicitly modeled world edges.
/// Once created, a BoundaryId persists through all topology changes and is never reused
/// even after retirement.
/// </summary>
[StructLayout(LayoutKind.Auto)]
[MessagePackObject]
public readonly record struct BoundaryId
{
    /// <summary>
    /// Internal UUID representation.
    /// </summary>
    private readonly Guid _value;

    /// <summary>
    /// Initializes a new instance of the BoundaryId struct with the specified UUID value.
    /// </summary>
    /// <param name="value">The UUID value.</param>
    [SerializationConstructor]
    public BoundaryId(Guid value)
    {
        _value = value;
    }

    /// <summary>
    /// Gets the underlying UUID value.
    /// </summary>
    [Key(0)]
    public Guid Value => _value;

    /// <summary>
    /// Gets a value indicating whether this BoundaryId is empty/invalid.
    /// </summary>
    [IgnoreMember]
    public bool IsEmpty => _value == Guid.Empty;

    /// <summary>
    /// Creates a new unique BoundaryId using a time-sorted UUIDv7.
    /// </summary>
    /// <returns>A new unique BoundaryId.</returns>
    public static BoundaryId NewId()
    {
        // UUIDv7 layout per RFC 9562:
        // 0-5: 48-bit Unix timestamp in milliseconds (big-endian)
        // 6-7: 16 bits with version (0b0111xxxx xxxxxxxx) and randomness
        // 8-15: 64 bits of randomness with RFC4122 variant (0b10xxxxxx on byte 8)

        var rfcBytes = new byte[16];

        // Timestamp (48 bits, big-endian)
        var timestamp = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds();
        rfcBytes[0] = (byte)((timestamp >> 40) & 0xFF);
        rfcBytes[1] = (byte)((timestamp >> 32) & 0xFF);
        rfcBytes[2] = (byte)((timestamp >> 24) & 0xFF);
        rfcBytes[3] = (byte)((timestamp >> 16) & 0xFF);
        rfcBytes[4] = (byte)((timestamp >> 8) & 0xFF);
        rfcBytes[5] = (byte)(timestamp & 0xFF);

        // Random bytes (10 bytes total, 2 for version field + 8 for rest)
        var randBytes = new byte[10];
        System.Security.Cryptography.RandomNumberGenerator.Fill(randBytes);
        rfcBytes[6] = randBytes[0];
        rfcBytes[7] = randBytes[1];
        Buffer.BlockCopy(randBytes, 2, rfcBytes, 8, 8);

        // Set version to 7 (bits 4-7 of byte 6: 0b0111xxxx)
        rfcBytes[6] = (byte)((rfcBytes[6] & 0x0F) | 0x70);

        // Set RFC4122 variant (bits 6-7 of byte 8: 0b10xxxxxx)
        rfcBytes[8] = (byte)((rfcBytes[8] & 0x3F) | 0x80);

        // Convert RFC4122 byte order to .NET Guid mixed-endian format:
        // Guid: Data1 (4, LE) | Data2 (2, LE) | Data3 (2, LE) | Data4 (8, BE)
        // RFC:  [0-3] (BE)    | [4-5] (BE)    | [6-7] (BE)    | [8-15] (BE)

        var guidBytes = new byte[16];
        guidBytes[0] = rfcBytes[3];
        guidBytes[1] = rfcBytes[2];
        guidBytes[2] = rfcBytes[1];
        guidBytes[3] = rfcBytes[0];
        guidBytes[4] = rfcBytes[5];
        guidBytes[5] = rfcBytes[4];
        guidBytes[6] = rfcBytes[7];
        guidBytes[7] = rfcBytes[6];
        Buffer.BlockCopy(rfcBytes, 8, guidBytes, 8, 8);

        return new BoundaryId(new Guid(guidBytes));
    }

    /// <summary>
    /// Creates a new unique BoundaryId deterministically using a seeded RNG.
    /// Use this overload in solver implementations to ensure replay determinism.
    /// </summary>
    /// <param name="rng">The seeded RNG instance for deterministic generation.</param>
    /// <returns>A new deterministic BoundaryId.</returns>
    public static BoundaryId NewId(ISeededRng rng)
    {
        ArgumentNullException.ThrowIfNull(rng);
        return new BoundaryId(GenerateDeterministicGuid(rng));
    }

    /// <summary>
    /// Generates a UUIDv7-style GUID deterministically using the provided RNG.
    /// Uses RNG for all bits (timestamp + random), maintaining UUIDv7 structure.
    /// </summary>
    private static Guid GenerateDeterministicGuid(ISeededRng rng)
    {
        var rfcBytes = new byte[16];

        // Use RNG for all bytes (deterministic pseudo-timestamp + random)
        var highBits = rng.NextUInt64();
        var lowBits = rng.NextUInt64();

        // Fill bytes from RNG
        rfcBytes[0] = (byte)((highBits >> 40) & 0xFF);
        rfcBytes[1] = (byte)((highBits >> 32) & 0xFF);
        rfcBytes[2] = (byte)((highBits >> 24) & 0xFF);
        rfcBytes[3] = (byte)((highBits >> 16) & 0xFF);
        rfcBytes[4] = (byte)((highBits >> 8) & 0xFF);
        rfcBytes[5] = (byte)(highBits & 0xFF);
        rfcBytes[6] = (byte)((lowBits >> 56) & 0xFF);
        rfcBytes[7] = (byte)((lowBits >> 48) & 0xFF);
        rfcBytes[8] = (byte)((lowBits >> 40) & 0xFF);
        rfcBytes[9] = (byte)((lowBits >> 32) & 0xFF);
        rfcBytes[10] = (byte)((lowBits >> 24) & 0xFF);
        rfcBytes[11] = (byte)((lowBits >> 16) & 0xFF);
        rfcBytes[12] = (byte)((lowBits >> 8) & 0xFF);
        rfcBytes[13] = (byte)(lowBits & 0xFF);
        rfcBytes[14] = (byte)((highBits >> 56) & 0xFF);
        rfcBytes[15] = (byte)((highBits >> 48) & 0xFF);

        // Set version to 7 (bits 4-7 of byte 6: 0b0111xxxx)
        rfcBytes[6] = (byte)((rfcBytes[6] & 0x0F) | 0x70);

        // Set RFC4122 variant (bits 6-7 of byte 8: 0b10xxxxxx)
        rfcBytes[8] = (byte)((rfcBytes[8] & 0x3F) | 0x80);

        // Convert RFC4122 byte order to .NET Guid mixed-endian format
        var guidBytes = new byte[16];
        guidBytes[0] = rfcBytes[3];
        guidBytes[1] = rfcBytes[2];
        guidBytes[2] = rfcBytes[1];
        guidBytes[3] = rfcBytes[0];
        guidBytes[4] = rfcBytes[5];
        guidBytes[5] = rfcBytes[4];
        guidBytes[6] = rfcBytes[7];
        guidBytes[7] = rfcBytes[6];
        Buffer.BlockCopy(rfcBytes, 8, guidBytes, 8, 8);

        return new Guid(guidBytes);
    }

    /// <summary>
    /// Parses a BoundaryId from a string representation.
    /// </summary>
    /// <param name="value">The string representation of the UUID.</param>
    /// <returns>A BoundaryId instance.</returns>
    /// <exception cref="ArgumentException">Thrown when the value is not a valid UUID.</exception>
    public static BoundaryId Parse(string value)
    {
        if (string.IsNullOrWhiteSpace(value))
            throw new ArgumentException("BoundaryId value cannot be null or whitespace.", nameof(value));

        if (!Guid.TryParse(value, out var guid))
            throw new ArgumentException($"Invalid BoundaryId format: {value}", nameof(value));

        if (guid == Guid.Empty)
            throw new ArgumentException("BoundaryId value cannot be Guid.Empty.", nameof(value));

        return new BoundaryId(guid);
    }

    /// <summary>
    /// Tries to parse a BoundaryId from a string representation.
    /// </summary>
    /// <param name="value">The string representation of the UUID.</param>
    /// <param name="boundaryId">The parsed BoundaryId if successful.</param>
    /// <returns>True if parsing succeeded; otherwise, false.</returns>
    public static bool TryParse(string value, out BoundaryId boundaryId)
    {
        if (!string.IsNullOrWhiteSpace(value) && Guid.TryParse(value, out var guid) && guid != Guid.Empty)
        {
            boundaryId = new BoundaryId(guid);
            return true;
        }

        boundaryId = default;
        return false;
    }

    /// <summary>
    /// Returns a string representation of the BoundaryId.
    /// </summary>
    /// <returns>A formatted UUID string.</returns>
    public override string ToString()
    {
        return _value.ToString("D"); // D format: 32 digits with hyphens
    }
}


// --- PATH: contracts/Geosphere.Plate.Topology.Contracts/Entities/BoundaryType.cs ---
namespace FantaSim.Geosphere.Plate.Topology.Contracts.Entities;

/// <summary>
/// Enumeration of boundary type classifications per FR-008.
///
/// Boundary types classify the relative motion between plates along the boundary.
/// This classification is critical for understanding tectonic processes and
/// influences geometry evolution patterns.
/// </summary>
public enum BoundaryType
{
    /// <summary>
    /// Divergent boundary where plates move apart.
    ///
    /// New crust is formed as plates separate (e.g., mid-ocean ridges).
    /// Geometrically characterized by extension and separation.
    /// </summary>
    Divergent,

    /// <summary>
    /// Convergent boundary where plates move toward each other.
    ///
    /// Crust is destroyed as plates collide (e.g., subduction zones, continental collisions).
    /// Geometrically characterized by compression and convergence.
    /// </summary>
    Convergent,

    /// <summary>
    /// Transform boundary where plates slide past each other.
    ///
    /// Crust is neither created nor destroyed (e.g., San Andreas Fault).
    /// Geometrically characterized by lateral motion with minimal convergence/divergence.
    /// </summary>
    Transform
}


// --- PATH: contracts/Geosphere.Plate.Topology.Contracts/Entities/DeterministicIdFactory.cs ---
using Plate.TimeDete.Determinism.Abstractions;
using FantaSim.Geosphere.Plate.Topology.Contracts.Events;

namespace FantaSim.Geosphere.Plate.Topology.Contracts.Entities;

/// <summary>
/// Default implementation of IDeterministicIdFactory using UUIDv7-style format.
///
/// IDs are generated using the RNG stream for the random portion, while maintaining
/// UUIDv7 structure for sortability.
///
/// NOTE: This class should be registered with your DI container and injected where needed.
/// Avoid static singletons at plugin/service boundaries.
/// </summary>
public sealed class DeterministicIdFactory : IDeterministicIdFactory
{
    /// <inheritdoc />
    public PlateId NewPlateId(ISeededRng rng) => PlateId.NewId(rng);

    /// <inheritdoc />
    public BoundaryId NewBoundaryId(ISeededRng rng) => BoundaryId.NewId(rng);

    /// <inheritdoc />
    public JunctionId NewJunctionId(ISeededRng rng) => JunctionId.NewId(rng);

    /// <inheritdoc />
    public EventId NewEventId(ISeededRng rng) => EventId.NewId(rng);
}


// --- PATH: contracts/Geosphere.Plate.Topology.Contracts/Entities/IDeterministicIdFactory.cs ---
using Plate.TimeDete.Determinism.Abstractions;
using FantaSim.Geosphere.Plate.Topology.Contracts.Events;

namespace FantaSim.Geosphere.Plate.Topology.Contracts.Entities;

/// <summary>
/// Factory interface for deterministic ID generation per RFC-V2-0001 and RFC-099 guidance.
///
/// Solver implementations SHOULD use this interface instead of calling NewId() directly
/// to ensure replay determinism. IDs are derived from the provided RNG stream,
/// producing identical IDs on identical replays given the same seed.
///
/// Implementations should be obtained via dependency injection, not static singletons,
/// to maintain plugin boundary hygiene.
/// </summary>
public interface IDeterministicIdFactory
{
    /// <summary>
    /// Creates a new PlateId deterministically using the provided RNG.
    /// </summary>
    /// <param name="rng">The seeded RNG instance for deterministic generation.</param>
    PlateId NewPlateId(ISeededRng rng);

    /// <summary>
    /// Creates a new BoundaryId deterministically using the provided RNG.
    /// </summary>
    /// <param name="rng">The seeded RNG instance for deterministic generation.</param>
    BoundaryId NewBoundaryId(ISeededRng rng);

    /// <summary>
    /// Creates a new JunctionId deterministically using the provided RNG.
    /// </summary>
    /// <param name="rng">The seeded RNG instance for deterministic generation.</param>
    JunctionId NewJunctionId(ISeededRng rng);

    /// <summary>
    /// Creates a new EventId deterministically using the provided RNG.
    /// Essential for RFC-099 solver determinism: event IDs must be reproducible.
    /// </summary>
    /// <param name="rng">The seeded RNG instance for deterministic generation.</param>
    EventId NewEventId(ISeededRng rng);
}


// --- PATH: contracts/Geosphere.Plate.Topology.Contracts/Entities/InvariantViolation.cs ---
namespace FantaSim.Geosphere.Plate.Topology.Contracts.Entities;

public readonly record struct InvariantViolation(
    string Invariant,
    string Message,
    long? Sequence
);


// --- PATH: contracts/Geosphere.Plate.Topology.Contracts/Entities/Junction.cs ---
using System.Collections.Immutable;
using FantaSim.Geosphere.Plate.Topology.Contracts.Numerics;

namespace FantaSim.Geosphere.Plate.Topology.Contracts.Entities;

/// <summary>
/// A junction where boundaries meet on a spherical body surface.
/// </summary>
/// <remarks>
/// <para>
/// <b>Sphere-by-default:</b> Location is stored as a <see cref="SurfacePoint"/>
/// (unit surface normal + radius), not as 2D planar coordinates. This ensures
/// correctness anywhere on the sphere, including poles and antimeridian.
/// </para>
/// <para>
/// BoundaryIds are stored as <see cref="ImmutableArray{T}"/> for determinism
/// and immutability. Arrays compare by reference which causes subtle bugs.
/// </para>
/// </remarks>
public readonly record struct Junction(
    JunctionId JunctionId,
    ImmutableArray<BoundaryId> BoundaryIds,
    SurfacePoint Location,
    bool IsRetired,
    string? RetirementReason
);


// --- PATH: contracts/Geosphere.Plate.Topology.Contracts/Entities/JunctionId.cs ---
using System.Runtime.InteropServices;
using Plate.TimeDete.Determinism.Abstractions;

namespace FantaSim.Geosphere.Plate.Topology.Contracts.Entities;

/// <summary>
/// Stable identifier representing a boundary junction where three or more boundaries meet per FR-005.
///
/// Junctions capture the topological structure of boundary intersections.
/// Once created, a JunctionId persists through all topology changes and is never reused
/// even after retirement.
/// </summary>
[StructLayout(LayoutKind.Auto)]
public readonly record struct JunctionId
{
    /// <summary>
    /// Internal UUID representation.
    /// </summary>
    private readonly Guid _value;

    /// <summary>
    /// Initializes a new instance of the JunctionId struct with the specified UUID value.
    /// </summary>
    /// <param name="value">The UUID value.</param>
    public JunctionId(Guid value)
    {
        _value = value;
    }

    /// <summary>
    /// Gets the underlying UUID value.
    /// </summary>
    public Guid Value => _value;

    /// <summary>
    /// Gets a value indicating whether this JunctionId is empty/invalid.
    /// </summary>
    public bool IsEmpty => _value == Guid.Empty;

    /// <summary>
    /// Creates a new unique JunctionId using a time-sorted UUIDv7.
    /// </summary>
    /// <returns>A new unique JunctionId.</returns>
    public static JunctionId NewId()
    {
        // UUIDv7 layout per RFC 9562:
        // 0-5: 48-bit Unix timestamp in milliseconds (big-endian)
        // 6-7: 16 bits with version (0b0111xxxx xxxxxxxx) and randomness
        // 8-15: 64 bits of randomness with RFC4122 variant (0b10xxxxxx on byte 8)

        var rfcBytes = new byte[16];

        // Timestamp (48 bits, big-endian)
        var timestamp = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds();
        rfcBytes[0] = (byte)((timestamp >> 40) & 0xFF);
        rfcBytes[1] = (byte)((timestamp >> 32) & 0xFF);
        rfcBytes[2] = (byte)((timestamp >> 24) & 0xFF);
        rfcBytes[3] = (byte)((timestamp >> 16) & 0xFF);
        rfcBytes[4] = (byte)((timestamp >> 8) & 0xFF);
        rfcBytes[5] = (byte)(timestamp & 0xFF);

        // Random bytes (10 bytes total, 2 for version field + 8 for rest)
        var randBytes = new byte[10];
        System.Security.Cryptography.RandomNumberGenerator.Fill(randBytes);
        rfcBytes[6] = randBytes[0];
        rfcBytes[7] = randBytes[1];
        Buffer.BlockCopy(randBytes, 2, rfcBytes, 8, 8);

        // Set version to 7 (bits 4-7 of byte 6: 0b0111xxxx)
        rfcBytes[6] = (byte)((rfcBytes[6] & 0x0F) | 0x70);

        // Set RFC4122 variant (bits 6-7 of byte 8: 0b10xxxxxx)
        rfcBytes[8] = (byte)((rfcBytes[8] & 0x3F) | 0x80);

        // Convert RFC4122 byte order to .NET Guid mixed-endian format:
        // Guid: Data1 (4, LE) | Data2 (2, LE) | Data3 (2, LE) | Data4 (8, BE)
        // RFC:  [0-3] (BE)    | [4-5] (BE)    | [6-7] (BE)    | [8-15] (BE)

        var guidBytes = new byte[16];
        guidBytes[0] = rfcBytes[3];
        guidBytes[1] = rfcBytes[2];
        guidBytes[2] = rfcBytes[1];
        guidBytes[3] = rfcBytes[0];
        guidBytes[4] = rfcBytes[5];
        guidBytes[5] = rfcBytes[4];
        guidBytes[6] = rfcBytes[7];
        guidBytes[7] = rfcBytes[6];
        Buffer.BlockCopy(rfcBytes, 8, guidBytes, 8, 8);

        return new JunctionId(new Guid(guidBytes));
    }

    /// <summary>
    /// Creates a new unique JunctionId deterministically using a seeded RNG.
    /// Use this overload in solver implementations to ensure replay determinism.
    /// </summary>
    /// <param name="rng">The seeded RNG instance for deterministic generation.</param>
    /// <returns>A new deterministic JunctionId.</returns>
    public static JunctionId NewId(ISeededRng rng)
    {
        ArgumentNullException.ThrowIfNull(rng);
        return new JunctionId(GenerateDeterministicGuid(rng));
    }

    /// <summary>
    /// Generates a UUIDv7-style GUID deterministically using the provided RNG.
    /// Uses RNG for all bits (timestamp + random), maintaining UUIDv7 structure.
    /// </summary>
    private static Guid GenerateDeterministicGuid(ISeededRng rng)
    {
        var rfcBytes = new byte[16];

        // Use RNG for all bytes (deterministic pseudo-timestamp + random)
        var highBits = rng.NextUInt64();
        var lowBits = rng.NextUInt64();

        // Fill bytes from RNG
        rfcBytes[0] = (byte)((highBits >> 40) & 0xFF);
        rfcBytes[1] = (byte)((highBits >> 32) & 0xFF);
        rfcBytes[2] = (byte)((highBits >> 24) & 0xFF);
        rfcBytes[3] = (byte)((highBits >> 16) & 0xFF);
        rfcBytes[4] = (byte)((highBits >> 8) & 0xFF);
        rfcBytes[5] = (byte)(highBits & 0xFF);
        rfcBytes[6] = (byte)((lowBits >> 56) & 0xFF);
        rfcBytes[7] = (byte)((lowBits >> 48) & 0xFF);
        rfcBytes[8] = (byte)((lowBits >> 40) & 0xFF);
        rfcBytes[9] = (byte)((lowBits >> 32) & 0xFF);
        rfcBytes[10] = (byte)((lowBits >> 24) & 0xFF);
        rfcBytes[11] = (byte)((lowBits >> 16) & 0xFF);
        rfcBytes[12] = (byte)((lowBits >> 8) & 0xFF);
        rfcBytes[13] = (byte)(lowBits & 0xFF);
        rfcBytes[14] = (byte)((highBits >> 56) & 0xFF);
        rfcBytes[15] = (byte)((highBits >> 48) & 0xFF);

        // Set version to 7 (bits 4-7 of byte 6: 0b0111xxxx)
        rfcBytes[6] = (byte)((rfcBytes[6] & 0x0F) | 0x70);

        // Set RFC4122 variant (bits 6-7 of byte 8: 0b10xxxxxx)
        rfcBytes[8] = (byte)((rfcBytes[8] & 0x3F) | 0x80);

        // Convert RFC4122 byte order to .NET Guid mixed-endian format
        var guidBytes = new byte[16];
        guidBytes[0] = rfcBytes[3];
        guidBytes[1] = rfcBytes[2];
        guidBytes[2] = rfcBytes[1];
        guidBytes[3] = rfcBytes[0];
        guidBytes[4] = rfcBytes[5];
        guidBytes[5] = rfcBytes[4];
        guidBytes[6] = rfcBytes[7];
        guidBytes[7] = rfcBytes[6];
        Buffer.BlockCopy(rfcBytes, 8, guidBytes, 8, 8);

        return new Guid(guidBytes);
    }

    /// <summary>
    /// Parses a JunctionId from a string representation.
    /// </summary>
    /// <param name="value">The string representation of the UUID.</param>
    /// <returns>A JunctionId instance.</returns>
    /// <exception cref="ArgumentException">Thrown when the value is not a valid UUID.</exception>
    public static JunctionId Parse(string value)
    {
        if (string.IsNullOrWhiteSpace(value))
            throw new ArgumentException("JunctionId value cannot be null or whitespace.", nameof(value));

        if (!Guid.TryParse(value, out var guid))
            throw new ArgumentException($"Invalid JunctionId format: {value}", nameof(value));

        if (guid == Guid.Empty)
            throw new ArgumentException("JunctionId value cannot be Guid.Empty.", nameof(value));

        return new JunctionId(guid);
    }

    /// <summary>
    /// Tries to parse a JunctionId from a string representation.
    /// </summary>
    /// <param name="value">The string representation of the UUID.</param>
    /// <param name="junctionId">The parsed JunctionId if successful.</param>
    /// <returns>True if parsing succeeded; otherwise, false.</returns>
    public static bool TryParse(string value, out JunctionId junctionId)
    {
        if (!string.IsNullOrWhiteSpace(value) && Guid.TryParse(value, out var guid) && guid != Guid.Empty)
        {
            junctionId = new JunctionId(guid);
            return true;
        }

        junctionId = default;
        return false;
    }

    /// <summary>
    /// Returns a string representation of the JunctionId.
    /// </summary>
    /// <returns>A formatted UUID string.</returns>
    public override string ToString()
    {
        return _value.ToString("D"); // D format: 32 digits with hyphens
    }
}


// --- PATH: contracts/Geosphere.Plate.Topology.Contracts/Entities/Plate.cs ---
namespace FantaSim.Geosphere.Plate.Topology.Contracts.Entities;

public readonly record struct Plate(
    PlateId PlateId,
    bool IsRetired,
    string? RetirementReason
);


// --- PATH: contracts/Geosphere.Plate.Topology.Contracts/Entities/PlateId.cs ---
using System.Runtime.InteropServices;
using Plate.TimeDete.Determinism.Abstractions;
using MessagePack;

namespace FantaSim.Geosphere.Plate.Topology.Contracts.Entities;

/// <summary>
/// Stable identifier representing a tectonic plate identity per FR-005.
///
/// Once created, a PlateId persists through all topology changes and is never reused
/// even after retirement. Implements UUIDv7 for sortability while maintaining uniqueness.
/// </summary>
[StructLayout(LayoutKind.Auto)]
[MessagePackObject]
public readonly record struct PlateId
{
    /// <summary>
    /// Internal UUID representation.
    /// </summary>
    private readonly Guid _value;

    /// <summary>
    /// Initializes a new instance of the PlateId struct with the specified UUID value.
    /// </summary>
    /// <param name="value">The UUID value.</param>
    [SerializationConstructor]
    public PlateId(Guid value)
    {
        _value = value;
    }

    /// <summary>
    /// Gets the underlying UUID value.
    /// </summary>
    [Key(0)]
    public Guid Value => _value;

    /// <summary>
    /// Gets a value indicating whether this PlateId is empty/invalid.
    /// </summary>
    [IgnoreMember]
    public bool IsEmpty => _value == Guid.Empty;

    /// <summary>
    /// Creates a new unique PlateId using a time-sorted UUIDv7.
    /// </summary>
    /// <returns>A new unique PlateId.</returns>
    public static PlateId NewId()
    {
        // UUIDv7 layout per RFC 9562:
        // 0-5: 48-bit Unix timestamp in milliseconds (big-endian)
        // 6-7: 16 bits with version (0b0111xxxx xxxxxxxx) and randomness
        // 8-15: 64 bits of randomness with RFC4122 variant (0b10xxxxxx on byte 8)

        var rfcBytes = new byte[16];

        // Timestamp (48 bits, big-endian)
        var timestamp = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds();
        rfcBytes[0] = (byte)((timestamp >> 40) & 0xFF);
        rfcBytes[1] = (byte)((timestamp >> 32) & 0xFF);
        rfcBytes[2] = (byte)((timestamp >> 24) & 0xFF);
        rfcBytes[3] = (byte)((timestamp >> 16) & 0xFF);
        rfcBytes[4] = (byte)((timestamp >> 8) & 0xFF);
        rfcBytes[5] = (byte)(timestamp & 0xFF);

        // Random bytes (10 bytes total, 2 for version field + 8 for rest)
        var randBytes = new byte[10];
        System.Security.Cryptography.RandomNumberGenerator.Fill(randBytes);
        rfcBytes[6] = randBytes[0];
        rfcBytes[7] = randBytes[1];
        Buffer.BlockCopy(randBytes, 2, rfcBytes, 8, 8);

        // Set version to 7 (bits 4-7 of byte 6: 0b0111xxxx)
        rfcBytes[6] = (byte)((rfcBytes[6] & 0x0F) | 0x70);

        // Set RFC4122 variant (bits 6-7 of byte 8: 0b10xxxxxx)
        rfcBytes[8] = (byte)((rfcBytes[8] & 0x3F) | 0x80);

        // Convert RFC4122 byte order to .NET Guid mixed-endian format:
        // Guid: Data1 (4, LE) | Data2 (2, LE) | Data3 (2, LE) | Data4 (8, BE)
        // RFC:  [0-3] (BE)    | [4-5] (BE)    | [6-7] (BE)    | [8-15] (BE)

        var guidBytes = new byte[16];
        guidBytes[0] = rfcBytes[3];
        guidBytes[1] = rfcBytes[2];
        guidBytes[2] = rfcBytes[1];
        guidBytes[3] = rfcBytes[0];
        guidBytes[4] = rfcBytes[5];
        guidBytes[5] = rfcBytes[4];
        guidBytes[6] = rfcBytes[7];
        guidBytes[7] = rfcBytes[6];
        Buffer.BlockCopy(rfcBytes, 8, guidBytes, 8, 8);

        return new PlateId(new Guid(guidBytes));
    }

    /// <summary>
    /// Creates a new unique PlateId deterministically using a seeded RNG.
    /// Use this overload in solver implementations to ensure replay determinism.
    /// </summary>
    /// <param name="rng">The seeded RNG instance for deterministic generation.</param>
    /// <returns>A new deterministic PlateId.</returns>
    public static PlateId NewId(ISeededRng rng)
    {
        ArgumentNullException.ThrowIfNull(rng);
        return new PlateId(GenerateDeterministicGuid(rng));
    }

    /// <summary>
    /// Generates a UUIDv7-style GUID deterministically using the provided RNG.
    /// Uses RNG for all bits (timestamp + random), maintaining UUIDv7 structure.
    /// </summary>
    private static Guid GenerateDeterministicGuid(ISeededRng rng)
    {
        var rfcBytes = new byte[16];

        // Use RNG for all bytes (deterministic pseudo-timestamp + random)
        var highBits = rng.NextUInt64();
        var lowBits = rng.NextUInt64();

        // Fill bytes from RNG
        rfcBytes[0] = (byte)((highBits >> 40) & 0xFF);
        rfcBytes[1] = (byte)((highBits >> 32) & 0xFF);
        rfcBytes[2] = (byte)((highBits >> 24) & 0xFF);
        rfcBytes[3] = (byte)((highBits >> 16) & 0xFF);
        rfcBytes[4] = (byte)((highBits >> 8) & 0xFF);
        rfcBytes[5] = (byte)(highBits & 0xFF);
        rfcBytes[6] = (byte)((lowBits >> 56) & 0xFF);
        rfcBytes[7] = (byte)((lowBits >> 48) & 0xFF);
        rfcBytes[8] = (byte)((lowBits >> 40) & 0xFF);
        rfcBytes[9] = (byte)((lowBits >> 32) & 0xFF);
        rfcBytes[10] = (byte)((lowBits >> 24) & 0xFF);
        rfcBytes[11] = (byte)((lowBits >> 16) & 0xFF);
        rfcBytes[12] = (byte)((lowBits >> 8) & 0xFF);
        rfcBytes[13] = (byte)(lowBits & 0xFF);
        rfcBytes[14] = (byte)((highBits >> 56) & 0xFF);
        rfcBytes[15] = (byte)((highBits >> 48) & 0xFF);

        // Set version to 7 (bits 4-7 of byte 6: 0b0111xxxx)
        rfcBytes[6] = (byte)((rfcBytes[6] & 0x0F) | 0x70);

        // Set RFC4122 variant (bits 6-7 of byte 8: 0b10xxxxxx)
        rfcBytes[8] = (byte)((rfcBytes[8] & 0x3F) | 0x80);

        // Convert RFC4122 byte order to .NET Guid mixed-endian format
        var guidBytes = new byte[16];
        guidBytes[0] = rfcBytes[3];
        guidBytes[1] = rfcBytes[2];
        guidBytes[2] = rfcBytes[1];
        guidBytes[3] = rfcBytes[0];
        guidBytes[4] = rfcBytes[5];
        guidBytes[5] = rfcBytes[4];
        guidBytes[6] = rfcBytes[7];
        guidBytes[7] = rfcBytes[6];
        Buffer.BlockCopy(rfcBytes, 8, guidBytes, 8, 8);

        return new Guid(guidBytes);
    }

    /// <summary>
    /// Parses a PlateId from a string representation.
    /// </summary>
    /// <param name="value">The string representation of the UUID.</param>
    /// <returns>A PlateId instance.</returns>
    /// <exception cref="ArgumentException">Thrown when the value is not a valid UUID.</exception>
    public static PlateId Parse(string value)
    {
        if (string.IsNullOrWhiteSpace(value))
            throw new ArgumentException("PlateId value cannot be null or whitespace.", nameof(value));

        if (!Guid.TryParse(value, out var guid))
            throw new ArgumentException($"Invalid PlateId format: {value}", nameof(value));

        if (guid == Guid.Empty)
            throw new ArgumentException("PlateId value cannot be Guid.Empty.", nameof(value));

        return new PlateId(guid);
    }

    /// <summary>
    /// Tries to parse a PlateId from a string representation.
    /// </summary>
    /// <param name="value">The string representation of the UUID.</param>
    /// <param name="plateId">The parsed PlateId if successful.</param>
    /// <returns>True if parsing succeeded; otherwise, false.</returns>
    public static bool TryParse(string value, out PlateId plateId)
    {
        if (!string.IsNullOrWhiteSpace(value) && Guid.TryParse(value, out var guid) && guid != Guid.Empty)
        {
            plateId = new PlateId(guid);
            return true;
        }

        plateId = default;
        return false;
    }

    /// <summary>
    /// Returns a string representation of the PlateId.
    /// </summary>
    /// <returns>A formatted UUID string.</returns>
    public override string ToString()
    {
        return _value.ToString("D"); // D format: 32 digits with hyphens
    }
}


// --- PATH: contracts/Geosphere.Plate.Topology.Contracts/Events/BoundaryCreatedEvent.cs ---
using System;
using System.Runtime.InteropServices;
using Plate.TimeDete.Time.Primitives;
using FantaSim.Geosphere.Plate.Topology.Contracts.Entities;
using FantaSim.Geosphere.Plate.Topology.Contracts.Identity;
using UnifyGeometry;
using UnifySerialization.Abstractions;

namespace FantaSim.Geosphere.Plate.Topology.Contracts.Events;

/// <summary>
/// Event representing the creation of a new boundary between two plates per FR-008.
///
/// A boundary separates two plates in the topology. Boundaries are the fundamental
/// edges of the plate boundary graph and have both a type classification (divergent,
/// convergent, transform) and a geometric representation.
/// </summary>
/// <param name="EventId">Unique identifier for this event (UUIDv7).</param>
/// <param name="BoundaryId">The unique identifier of the newly created boundary.</param>
/// <param name="PlateIdLeft">The plate on the left side of this boundary.</param>
/// <param name="PlateIdRight">The plate on the right side of this boundary.</param>
/// <param name="BoundaryType">The type classification of this boundary.</param>
/// <param name="Geometry">The initial geometric representation of this boundary.</param>
/// <param name="Tick">Canonical simulation tick when this event occurred.</param>
/// <param name="Sequence">Ordering within the event stream.</param>
/// <param name="StreamIdentity">The truth stream this event belongs to.</param>
/// <param name="PreviousHash">Hash of the previous event in the chain (empty for genesis).</param>
/// <param name="Hash">Cryptographic hash of this event (computed, not set by callers).</param>
[StructLayout(LayoutKind.Auto)]
[UnifyModel]
public readonly record struct BoundaryCreatedEvent(
    [property: UnifyProperty(0)] Guid EventId,
    [property: UnifyProperty(1)] BoundaryId BoundaryId,
    [property: UnifyProperty(2)] PlateId PlateIdLeft,
    [property: UnifyProperty(3)] PlateId PlateIdRight,
    [property: UnifyProperty(4)] BoundaryType BoundaryType,
    [property: UnifyProperty(5)] IGeometry Geometry,
    [property: UnifyProperty(6)] CanonicalTick Tick,
    [property: UnifyProperty(7)] long Sequence,
    [property: UnifyProperty(8)] TruthStreamIdentity StreamIdentity,
    [property: UnifyProperty(9)] ReadOnlyMemory<byte> PreviousHash,
    [property: UnifyProperty(10)] ReadOnlyMemory<byte> Hash
) : IPlateTopologyEvent
{
    /// <summary>
    /// Gets the event type discriminator for polymorphic deserialization.
    /// </summary>
    string IPlateTopologyEvent.EventType => nameof(BoundaryCreatedEvent);
}


// --- PATH: contracts/Geosphere.Plate.Topology.Contracts/Events/BoundaryGeometryUpdatedEvent.cs ---
using System;
using System.Runtime.InteropServices;
using Plate.TimeDete.Time.Primitives;
using FantaSim.Geosphere.Plate.Topology.Contracts.Entities;
using FantaSim.Geosphere.Plate.Topology.Contracts.Identity;
using UnifyGeometry;
using UnifySerialization.Abstractions;

namespace FantaSim.Geosphere.Plate.Topology.Contracts.Events;

/// <summary>
/// Event representing an update to a boundary's geometric representation per FR-008.
///
/// Boundary geometries evolve due to plate motion and tectonic processes.
/// This event replaces the previous geometry with new geometry, enabling
/// temporal tracking of boundary evolution.
/// </summary>
/// <param name="EventId">Unique identifier for this event (UUIDv7).</param>
/// <param name="BoundaryId">The unique identifier of the boundary whose geometry was updated.</param>
/// <param name="NewGeometry">The new geometric representation of this boundary.</param>
/// <param name="Tick">Canonical simulation tick when this event occurred.</param>
/// <param name="Sequence">Ordering within the event stream.</param>
/// <param name="StreamIdentity">The truth stream this event belongs to.</param>
/// <param name="PreviousHash">Hash of the previous event in the chain (empty for genesis).</param>
/// <param name="Hash">Cryptographic hash of this event (computed, not set by callers).</param>
[StructLayout(LayoutKind.Auto)]
[UnifyModel]
public readonly record struct BoundaryGeometryUpdatedEvent(
    [property: UnifyProperty(0)] Guid EventId,
    [property: UnifyProperty(1)] BoundaryId BoundaryId,
    [property: UnifyProperty(7)] IGeometry NewGeometry,
    [property: UnifyProperty(2)] CanonicalTick Tick,
    [property: UnifyProperty(3)] long Sequence,
    [property: UnifyProperty(4)] TruthStreamIdentity StreamIdentity,
    [property: UnifyProperty(5)] ReadOnlyMemory<byte> PreviousHash,
    [property: UnifyProperty(6)] ReadOnlyMemory<byte> Hash
) : IPlateTopologyEvent
{
    /// <summary>
    /// Gets the event type discriminator for polymorphic deserialization.
    /// </summary>
    string IPlateTopologyEvent.EventType => nameof(BoundaryGeometryUpdatedEvent);
}


// --- PATH: contracts/Geosphere.Plate.Topology.Contracts/Events/BoundaryRetiredEvent.cs ---
using System;
using System.Runtime.InteropServices;
using Plate.TimeDete.Time.Primitives;
using FantaSim.Geosphere.Plate.Topology.Contracts.Entities;
using FantaSim.Geosphere.Plate.Topology.Contracts.Identity;
using UnifySerialization.Abstractions;

namespace FantaSim.Geosphere.Plate.Topology.Contracts.Events;

/// <summary>
/// Event representing the retirement/deletion of a boundary per FR-008.
///
/// Boundary retirement marks the end of a boundary's lifecycle. Retired boundaries
/// no longer participate in the active topology but their identity remains reserved
/// to prevent reuse (per FR-005).
/// </summary>
/// <param name="EventId">Unique identifier for this event (UUIDv7).</param>
/// <param name="BoundaryId">The unique identifier of the retired boundary.</param>
/// <param name="Reason">Optional reason or cause for the retirement.</param>
/// <param name="Tick">Canonical simulation tick when this event occurred.</param>
/// <param name="Sequence">Ordering within the event stream.</param>
/// <param name="StreamIdentity">The truth stream this event belongs to.</param>
/// <param name="PreviousHash">Hash of the previous event in the chain (empty for genesis).</param>
/// <param name="Hash">Cryptographic hash of this event (computed, not set by callers).</param>
[StructLayout(LayoutKind.Auto)]
[UnifyModel]
public readonly record struct BoundaryRetiredEvent(
    [property: UnifyProperty(0)] Guid EventId,
    [property: UnifyProperty(1)] BoundaryId BoundaryId,
    [property: UnifyProperty(7)] string? Reason,
    [property: UnifyProperty(2)] CanonicalTick Tick,
    [property: UnifyProperty(3)] long Sequence,
    [property: UnifyProperty(4)] TruthStreamIdentity StreamIdentity,
    [property: UnifyProperty(5)] ReadOnlyMemory<byte> PreviousHash,
    [property: UnifyProperty(6)] ReadOnlyMemory<byte> Hash
) : IPlateTopologyEvent
{
    /// <summary>
    /// Gets the event type discriminator for polymorphic deserialization.
    /// </summary>
    string IPlateTopologyEvent.EventType => nameof(BoundaryRetiredEvent);
}


// --- PATH: contracts/Geosphere.Plate.Topology.Contracts/Events/BoundaryTypeChangedEvent.cs ---
using System;
using System.Runtime.InteropServices;
using Plate.TimeDete.Time.Primitives;
using FantaSim.Geosphere.Plate.Topology.Contracts.Entities;
using FantaSim.Geosphere.Plate.Topology.Contracts.Identity;
using UnifySerialization.Abstractions;

namespace FantaSim.Geosphere.Plate.Topology.Contracts.Events;

/// <summary>
/// Event representing a change to a boundary's type classification per FR-008.
///
/// Boundary types can change over time due to tectonic evolution. This event
/// tracks the transition from one type to another, preserving historical state.
/// </summary>
/// <param name="EventId">Unique identifier for this event (UUIDv7).</param>
/// <param name="BoundaryId">The unique identifier of the boundary whose type changed.</param>
/// <param name="OldType">The previous boundary type before this change.</param>
/// <param name="NewType">The new boundary type after this change.</param>
/// <param name="Tick">Canonical simulation tick when this event occurred.</param>
/// <param name="Sequence">Ordering within the event stream.</param>
/// <param name="StreamIdentity">The truth stream this event belongs to.</param>
/// <param name="PreviousHash">Hash of the previous event in the chain (empty for genesis).</param>
/// <param name="Hash">Cryptographic hash of this event (computed, not set by callers).</param>
[StructLayout(LayoutKind.Auto)]
[UnifyModel]
public readonly record struct BoundaryTypeChangedEvent(
    [property: UnifyProperty(0)] Guid EventId,
    [property: UnifyProperty(1)] BoundaryId BoundaryId,
    [property: UnifyProperty(7)] BoundaryType OldType,
    [property: UnifyProperty(8)] BoundaryType NewType,
    [property: UnifyProperty(2)] CanonicalTick Tick,
    [property: UnifyProperty(3)] long Sequence,
    [property: UnifyProperty(4)] TruthStreamIdentity StreamIdentity,
    [property: UnifyProperty(5)] ReadOnlyMemory<byte> PreviousHash,
    [property: UnifyProperty(6)] ReadOnlyMemory<byte> Hash
) : IPlateTopologyEvent
{
    /// <summary>
    /// Gets the event type discriminator for polymorphic deserialization.
    /// </summary>
    string IPlateTopologyEvent.EventType => nameof(BoundaryTypeChangedEvent);
}


// --- PATH: contracts/Geosphere.Plate.Topology.Contracts/Events/ConcurrencyConflictException.cs ---
﻿using FantaSim.Geosphere.Plate.Topology.Contracts.Identity;

namespace FantaSim.Geosphere.Plate.Topology.Contracts.Events;

/// <summary>
/// Exception thrown when an optimistic concurrency check fails during event append.
///
/// This indicates that the stream's head state changed between reading the head
/// and attempting to append. The caller should:
/// 1. Re-read the current head
/// 2. Recompute events with updated sequences
/// 3. Retry the append with the new precondition
///
/// Design rationale (RFC-V2-0005 review):
/// - Explicit exception type enables targeted catch/retry logic
/// - Includes both expected and actual state for diagnostics
/// - Follows optimistic concurrency patterns from event sourcing literature
/// </summary>
public sealed class ConcurrencyConflictException : InvalidOperationException
{
    /// <summary>
    /// The stream where the conflict occurred.
    /// </summary>
    public TruthStreamIdentity Stream { get; }

    /// <summary>
    /// The expected head state that was passed to AppendAsync.
    /// </summary>
    public HeadPrecondition Expected { get; }

    /// <summary>
    /// The actual head state found in the store.
    /// </summary>
    public StreamHead Actual { get; }

    /// <summary>
    /// Creates a new concurrency conflict exception.
    /// </summary>
    public ConcurrencyConflictException(
        TruthStreamIdentity stream,
        HeadPrecondition expected,
        StreamHead actual)
        : base(FormatMessage(stream, expected, actual))
    {
        Stream = stream;
        Expected = expected;
        Actual = actual;
    }

    private static string FormatMessage(
        TruthStreamIdentity stream,
        HeadPrecondition expected,
        StreamHead actual)
    {
        return $"Concurrency conflict on stream {stream}: " +
               $"expected head (seq={expected.Sequence}, hash={FormatHash(expected.Hash)}), " +
               $"actual head (seq={actual.Sequence}, hash={FormatHash(actual.Hash)})";
    }

    private static string FormatHash(byte[]? hash)
    {
        if (hash == null || hash.Length == 0)
            return "<null>";
        if (hash.Length < 4)
            return Convert.ToHexString(hash).ToLowerInvariant();
        return Convert.ToHexString(hash.AsSpan(0, 4)).ToLowerInvariant() + "...";
    }
}


// --- PATH: contracts/Geosphere.Plate.Topology.Contracts/Events/EventId.cs ---
using System.Runtime.InteropServices;
using Plate.TimeDete.Determinism.Abstractions;

namespace FantaSim.Geosphere.Plate.Topology.Contracts.Events;

/// <summary>
/// Stable identifier representing an event in the topology stream per FR-006.
///
/// EventIds use UUIDv7 format for sortability. Solvers SHOULD use NewId(ISeededRng)
/// to ensure deterministic replay per RFC-099 guidance.
/// </summary>
[StructLayout(LayoutKind.Auto)]
public readonly record struct EventId
{
    /// <summary>
    /// Internal UUID representation.
    /// </summary>
    private readonly Guid _value;

    /// <summary>
    /// Initializes a new instance of the EventId struct with the specified UUID value.
    /// </summary>
    /// <param name="value">The UUID value.</param>
    public EventId(Guid value)
    {
        _value = value;
    }

    /// <summary>
    /// Gets the underlying UUID value.
    /// </summary>
    public Guid Value => _value;

    /// <summary>
    /// Gets a value indicating whether this EventId is empty/invalid.
    /// </summary>
    public bool IsEmpty => _value == Guid.Empty;

    /// <summary>
    /// Creates a new unique EventId using a time-sorted UUIDv7.
    ///
    /// WARNING: This overload uses system time and cryptographic RNG, producing
    /// non-deterministic IDs. Use NewId(ISeededRng) in solver implementations
    /// for replay determinism.
    /// </summary>
    /// <returns>A new unique EventId.</returns>
    public static EventId NewId()
    {
        // UUIDv7 layout per RFC 9562:
        // 0-5: 48-bit Unix timestamp in milliseconds (big-endian)
        // 6-7: 16 bits with version (0b0111xxxx xxxxxxxx) and randomness
        // 8-15: 64 bits of randomness with RFC4122 variant (0b10xxxxxx on byte 8)

        var rfcBytes = new byte[16];

        // Timestamp (48 bits, big-endian)
        var timestamp = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds();
        rfcBytes[0] = (byte)((timestamp >> 40) & 0xFF);
        rfcBytes[1] = (byte)((timestamp >> 32) & 0xFF);
        rfcBytes[2] = (byte)((timestamp >> 24) & 0xFF);
        rfcBytes[3] = (byte)((timestamp >> 16) & 0xFF);
        rfcBytes[4] = (byte)((timestamp >> 8) & 0xFF);
        rfcBytes[5] = (byte)(timestamp & 0xFF);

        // Random bytes (10 bytes total, 2 for version field + 8 for rest)
        var randBytes = new byte[10];
        System.Security.Cryptography.RandomNumberGenerator.Fill(randBytes);
        rfcBytes[6] = randBytes[0];
        rfcBytes[7] = randBytes[1];
        Buffer.BlockCopy(randBytes, 2, rfcBytes, 8, 8);

        // Set version to 7 (bits 4-7 of byte 6: 0b0111xxxx)
        rfcBytes[6] = (byte)((rfcBytes[6] & 0x0F) | 0x70);

        // Set RFC4122 variant (bits 6-7 of byte 8: 0b10xxxxxx)
        rfcBytes[8] = (byte)((rfcBytes[8] & 0x3F) | 0x80);

        // Convert RFC4122 byte order to .NET Guid mixed-endian format
        var guidBytes = new byte[16];
        guidBytes[0] = rfcBytes[3];
        guidBytes[1] = rfcBytes[2];
        guidBytes[2] = rfcBytes[1];
        guidBytes[3] = rfcBytes[0];
        guidBytes[4] = rfcBytes[5];
        guidBytes[5] = rfcBytes[4];
        guidBytes[6] = rfcBytes[7];
        guidBytes[7] = rfcBytes[6];
        Buffer.BlockCopy(rfcBytes, 8, guidBytes, 8, 8);

        return new EventId(new Guid(guidBytes));
    }

    /// <summary>
    /// Creates a new unique EventId deterministically using a seeded RNG.
    /// Use this overload in solver implementations to ensure replay determinism per RFC-099.
    /// </summary>
    /// <param name="rng">The seeded RNG instance for deterministic generation.</param>
    /// <returns>A new deterministic EventId.</returns>
    public static EventId NewId(ISeededRng rng)
    {
        ArgumentNullException.ThrowIfNull(rng);
        return new EventId(GenerateDeterministicGuid(rng));
    }

    /// <summary>
    /// Generates a UUIDv7-style GUID deterministically using the provided RNG.
    /// Uses RNG for all bits (timestamp + random), maintaining UUIDv7 structure.
    /// </summary>
    private static Guid GenerateDeterministicGuid(ISeededRng rng)
    {
        var rfcBytes = new byte[16];

        // Use RNG for all bytes (deterministic pseudo-timestamp + random)
        var highBits = rng.NextUInt64();
        var lowBits = rng.NextUInt64();

        // Fill bytes from RNG
        rfcBytes[0] = (byte)((highBits >> 40) & 0xFF);
        rfcBytes[1] = (byte)((highBits >> 32) & 0xFF);
        rfcBytes[2] = (byte)((highBits >> 24) & 0xFF);
        rfcBytes[3] = (byte)((highBits >> 16) & 0xFF);
        rfcBytes[4] = (byte)((highBits >> 8) & 0xFF);
        rfcBytes[5] = (byte)(highBits & 0xFF);
        rfcBytes[6] = (byte)((lowBits >> 56) & 0xFF);
        rfcBytes[7] = (byte)((lowBits >> 48) & 0xFF);
        rfcBytes[8] = (byte)((lowBits >> 40) & 0xFF);
        rfcBytes[9] = (byte)((lowBits >> 32) & 0xFF);
        rfcBytes[10] = (byte)((lowBits >> 24) & 0xFF);
        rfcBytes[11] = (byte)((lowBits >> 16) & 0xFF);
        rfcBytes[12] = (byte)((lowBits >> 8) & 0xFF);
        rfcBytes[13] = (byte)(lowBits & 0xFF);
        rfcBytes[14] = (byte)((highBits >> 56) & 0xFF);
        rfcBytes[15] = (byte)((highBits >> 48) & 0xFF);

        // Set version to 7 (bits 4-7 of byte 6: 0b0111xxxx)
        rfcBytes[6] = (byte)((rfcBytes[6] & 0x0F) | 0x70);

        // Set RFC4122 variant (bits 6-7 of byte 8: 0b10xxxxxx)
        rfcBytes[8] = (byte)((rfcBytes[8] & 0x3F) | 0x80);

        // Convert RFC4122 byte order to .NET Guid mixed-endian format
        var guidBytes = new byte[16];
        guidBytes[0] = rfcBytes[3];
        guidBytes[1] = rfcBytes[2];
        guidBytes[2] = rfcBytes[1];
        guidBytes[3] = rfcBytes[0];
        guidBytes[4] = rfcBytes[5];
        guidBytes[5] = rfcBytes[4];
        guidBytes[6] = rfcBytes[7];
        guidBytes[7] = rfcBytes[6];
        Buffer.BlockCopy(rfcBytes, 8, guidBytes, 8, 8);

        return new Guid(guidBytes);
    }

    /// <summary>
    /// Creates an EventId from a raw GUID value.
    /// </summary>
    public static EventId FromGuid(Guid value) => new(value);

    /// <summary>
    /// Parses an EventId from a string representation.
    /// </summary>
    /// <param name="value">The string representation of the UUID.</param>
    /// <returns>An EventId instance.</returns>
    /// <exception cref="ArgumentException">Thrown when the value is not a valid UUID.</exception>
    public static EventId Parse(string value)
    {
        if (string.IsNullOrWhiteSpace(value))
            throw new ArgumentException("EventId value cannot be null or whitespace.", nameof(value));

        if (!Guid.TryParse(value, out var guid))
            throw new ArgumentException($"Invalid EventId format: {value}", nameof(value));

        if (guid == Guid.Empty)
            throw new ArgumentException("EventId value cannot be Guid.Empty.", nameof(value));

        return new EventId(guid);
    }

    /// <summary>
    /// Tries to parse an EventId from a string representation.
    /// </summary>
    /// <param name="value">The string representation of the UUID.</param>
    /// <param name="eventId">The parsed EventId if successful.</param>
    /// <returns>True if parsing succeeded; otherwise, false.</returns>
    public static bool TryParse(string value, out EventId eventId)
    {
        if (!string.IsNullOrWhiteSpace(value) && Guid.TryParse(value, out var guid) && guid != Guid.Empty)
        {
            eventId = new EventId(guid);
            return true;
        }

        eventId = default;
        return false;
    }

    /// <summary>
    /// Implicit conversion from EventId to Guid for backward compatibility.
    /// </summary>
    public static implicit operator Guid(EventId eventId) => eventId._value;

    /// <summary>
    /// Explicit conversion from Guid to EventId.
    /// </summary>
    public static explicit operator EventId(Guid value) => new(value);

    /// <summary>
    /// Returns a string representation of the EventId.
    /// </summary>
    /// <returns>A formatted UUID string.</returns>
    public override string ToString()
    {
        return _value.ToString("D"); // D format: 32 digits with hyphens
    }
}


// --- PATH: contracts/Geosphere.Plate.Topology.Contracts/Events/HeadPrecondition.cs ---
﻿namespace FantaSim.Geosphere.Plate.Topology.Contracts.Events;

/// <summary>
/// Represents an expected head state for optimistic concurrency control.
///
/// Used by <see cref="ITopologyEventStore.AppendAsync"/> to guard against
/// concurrent writers. If the actual head doesn't match, a
/// <see cref="ConcurrencyConflictException"/> is thrown.
///
/// Design rationale (RFC-V2-0005 review):
/// - RocksDB doesn't provide atomic compare-and-swap in basic API
/// - Per-stream locking + precondition check provides in-process safety
/// - Clear upgrade path to TransactionDB for multi-process writers
/// </summary>
public readonly struct HeadPrecondition : IEquatable<HeadPrecondition>
{
    /// <summary>
    /// Hash size in bytes (SHA-256).
    /// </summary>
    public const int HashSizeBytes = 32;

    /// <summary>
    /// Zero hash representing an empty/genesis stream.
    /// </summary>
    public static readonly byte[] ZeroHash = new byte[HashSizeBytes];

    /// <summary>
    /// Precondition for appending to an empty (non-existent) stream.
    /// </summary>
    public static HeadPrecondition Empty => new(-1, ZeroHash);

    private readonly byte[] _hash;

    /// <summary>
    /// Expected head sequence number. Use -1 for empty streams.
    /// </summary>
    public long Sequence { get; }

    /// <summary>
    /// Expected head hash (32 bytes SHA-256).
    /// Returns a defensive copy to prevent mutation.
    /// </summary>
    public byte[] Hash => (byte[])_hash.Clone();

    /// <summary>
    /// Creates a new head precondition.
    /// </summary>
    /// <param name="sequence">Expected sequence number, or -1 for empty stream.</param>
    /// <param name="hash">Expected hash (32 bytes). Will be cloned.</param>
    public HeadPrecondition(long sequence, byte[] hash)
    {
        ArgumentNullException.ThrowIfNull(hash);
        if (hash.Length != HashSizeBytes)
            throw new ArgumentException($"Hash must be {HashSizeBytes} bytes", nameof(hash));

        Sequence = sequence;
        _hash = (byte[])hash.Clone(); // Defensive copy
    }

    /// <summary>
    /// Validates the precondition structure.
    /// </summary>
    public bool IsValid => Sequence >= -1 && _hash is { Length: HashSizeBytes };

    /// <summary>
    /// Internal access to hash without cloning (for comparison only).
    /// </summary>
    internal ReadOnlySpan<byte> HashSpan => _hash.AsSpan();

    public bool Equals(HeadPrecondition other)
    {
        return Sequence == other.Sequence && _hash.AsSpan().SequenceEqual(other._hash);
    }

    public override bool Equals(object? obj) => obj is HeadPrecondition other && Equals(other);

    public override int GetHashCode()
    {
        var hashCode = new HashCode();
        hashCode.Add(Sequence);
        foreach (var b in _hash)
            hashCode.Add(b);
        return hashCode.ToHashCode();
    }

    public static bool operator ==(HeadPrecondition left, HeadPrecondition right) => left.Equals(right);
    public static bool operator !=(HeadPrecondition left, HeadPrecondition right) => !left.Equals(right);
}


// --- PATH: contracts/Geosphere.Plate.Topology.Contracts/Events/IPlateTopologyEvent.cs ---
using System;
using Plate.TimeDete.Time.Primitives;
using FantaSim.Geosphere.Plate.Topology.Contracts.Identity;

namespace FantaSim.Geosphere.Plate.Topology.Contracts.Events;

/// <summary>
/// Base interface for all plate topology events per FR-006, FR-015.
///
/// Events represent immutable changes to plate topology truth. Each event contains
/// all information required to reconstruct topology state without external
/// dependencies or solver execution.
///
/// Event envelope structure:
/// - EventId: Unique identifier for the event (UUIDv7 for sortability)
/// - EventType: Discriminator for polymorphic deserialization
/// - Tick: Canonical simulation time (RFC-V2-0010)
/// - Sequence: Ordering within stream (deterministic replay)
/// - StreamIdentity: Which truth stream this belongs to
///
/// Concrete event types (per FR-008):
/// - Creation events: PlateCreated, BoundaryCreated, JunctionCreated
/// - Lifecycle events: BoundaryRetired, JunctionRetired, PlateRetired (optional)
/// - State change events: BoundaryTypeChanged, BoundaryGeometryUpdated, JunctionUpdated
/// - Topology evolution (future): PlateSplit, PlateMerge, BoundaryReSegmented
/// </summary>
public interface IPlateTopologyEvent
{
    /// <summary>
    /// Gets the unique identifier for this event.
    ///
    /// Uses UUIDv7 for time-sorted uniqueness, supporting efficient indexing and
    /// debugging of event streams. The event ID must be stable and unique across
    /// all events in all streams.
    /// </summary>
    Guid EventId { get; }

    /// <summary>
    /// Gets the event type discriminator for polymorphic deserialization.
    ///
    /// This string identifies the concrete event type and is used by serializers
    /// to reconstruct the correct event implementation from stored bytes.
    /// Event types should be stable and well-documented for compatibility.
    ///
    /// Examples: "PlateCreated", "BoundaryCreated", "JunctionCreated",
    /// "BoundaryTypeChanged", "BoundaryGeometryUpdated", "BoundaryRetired",
    /// "JunctionUpdated", "JunctionRetired", "PlateRetired"
    /// </summary>
    string EventType { get; }

    /// <summary>
    /// Gets the canonical simulation tick when this event occurred.
    ///
    /// Per RFC-V2-0010, all events are indexed by CanonicalTick. This is the
    /// absolute, monotonic, unitless time coordinate for the simulation.
    /// Tick 0 is world genesis; negative ticks are invalid.
    ///
    /// For deterministic replay, the tick must be preserved exactly as
    /// emitted by the solver.
    /// </summary>
    CanonicalTick Tick { get; }

    /// <summary>
    /// Gets the sequence number of this event within its stream.
    ///
    /// Events within a stream are ordered by this sequence number for deterministic
    /// replay per FR-001 and FR-012. The sequence must be monotonically increasing
    /// within each stream identity, starting from zero or a configured offset.
    ///
    /// Sequence ordering is critical for:
    /// - Replay determinism (SC-001)
    /// - Conflict detection and resolution
    /// - Stream versioning and branching
    /// </summary>
    long Sequence { get; }

    /// <summary>
    /// Gets the truth stream identity this event belongs to.
    ///
    /// Per FR-001 and FR-014, events are isolated by the canonical identity tuple
    /// (VariantId, BranchId, L, Domain, M). Events from different stream identities
    /// are independent and must not interfere with each other.
    ///
    /// This enables:
    /// - Multiple world variants (e.g., "science", "wuxing")
    /// - Branches for parallel exploration
    /// - Governance at different L-levels
    /// - Multiple models/governing equations (M0, M1, ...)
    /// </summary>
    TruthStreamIdentity StreamIdentity { get; }

    /// <summary>
    /// Gets the hash of the previous event in the chain.
    ///
    /// This field establishes a cryptographic chain across events in a stream.
    /// For the genesis event (first event in a stream), this is empty.
    /// For all subsequent events, this must equal the Hash of the preceding event.
    ///
    /// This enables:
    /// - Tamper detection (any modification breaks the chain)
    /// - Deterministic verification of event ordering
    /// - Efficient integrity checks without replaying full history
    /// </summary>
    ReadOnlyMemory<byte> PreviousHash { get; }

    /// <summary>
    /// Gets the cryptographic hash of this event.
    ///
    /// The hash is computed over a canonical preimage that includes:
    /// - Tick (canonical simulation time)
    /// - StreamIdentity (truth stream tuple)
    /// - PreviousHash (chain link to prior event)
    /// - Payload bytes (event-specific data, MessagePack-encoded)
    ///
    /// The Hash field itself is NOT included in the preimage (would be circular).
    /// Algorithm: SHA-256 (producing 32 bytes).
    ///
    /// This field is computed, never set by callers directly.
    /// </summary>
    ReadOnlyMemory<byte> Hash { get; }
}


// --- PATH: contracts/Geosphere.Plate.Topology.Contracts/Events/ITopologyEventStore.cs ---
﻿using FantaSim.Geosphere.Plate.Topology.Contracts.Identity;

namespace FantaSim.Geosphere.Plate.Topology.Contracts.Events;

/// <summary>
/// Policy for handling tick monotonicity violations during event append.
///
/// In an event-sourced system, the Sequence number is the primary ordering key.
/// However, the Tick (simulation time) may sometimes decrease due to:
/// - Undo/redo operations
/// - Parallel processing with late arrivals
/// - Clock corrections in simulation
///
/// This policy controls how the event store handles cases where
/// Tick decreases while Sequence increases.
/// </summary>
public enum TickMonotonicityPolicy
{
    /// <summary>
    /// Allow tick to decrease without any action.
    /// This is the default policy for backward compatibility.
    /// The event store orders by Sequence, not Tick, so this is safe.
    /// </summary>
    Allow = 0,

    /// <summary>
    /// Warn when tick decreases but still allow the append.
    /// Implementations should log a warning for monitoring.
    /// </summary>
    Warn = 1,

    /// <summary>
    /// Reject the append if tick decreases.
    /// Throws an InvalidOperationException.
    /// Use this for strict simulation timelines that should never go backward.
    /// </summary>
    Reject = 2
}

/// <summary>
/// Options for appending events to a topology event store.
/// </summary>
public sealed class AppendOptions
{
    /// <summary>
    /// Default options with backward-compatible behavior.
    /// </summary>
    public static readonly AppendOptions Default = new();

    /// <summary>
    /// Policy for handling tick monotonicity violations.
    /// Default is <see cref="TickMonotonicityPolicy.Allow"/>.
    /// </summary>
    public TickMonotonicityPolicy TickPolicy { get; init; } = TickMonotonicityPolicy.Allow;

    /// <summary>
    /// Optional expected head precondition for optimistic concurrency control.
    ///
    /// When set, the append will fail with <see cref="ConcurrencyConflictException"/>
    /// if the actual stream head doesn't match this precondition.
    ///
    /// Use <see cref="HeadPrecondition.Empty"/> for appending to a new/empty stream.
    /// Use <see cref="StreamHead.ToPrecondition"/> from <see cref="ITopologyEventStore.GetHeadAsync"/>
    /// for appending to an existing stream.
    ///
    /// When null (default), no concurrency check is performed. This is backward-compatible
    /// but not recommended for production use with concurrent writers.
    /// </summary>
    public HeadPrecondition? ExpectedHead { get; init; }
}

/// <summary>
/// Contract interface for topology event store per FR-001, FR-012, FR-014.
///
/// Defines operations for appending and reading topology events from a persistent
/// event store. The contract ensures deterministic replay by ordering events by
/// Sequence within isolated streams identified by TruthStreamIdentity.
///
/// Implementations must ensure:
/// - Events are appended atomically per stream
/// - Events are read in Sequence order within a stream
/// - Streams are fully isolated by TruthStreamIdentity
/// - No cross-stream dependencies in read/write operations
/// </summary>
public interface ITopologyEventStore
{
    /// <summary>
    /// Appends a batch of events to the specified stream.
    ///
    /// All events must have the same StreamIdentity matching the stream parameter.
    /// Events must have monotonically increasing Sequence numbers for the stream.
    /// The operation should be atomic: either all events succeed or none are persisted.
    ///
    /// Sequence numbers and StreamIdentity are used for deterministic replay,
    /// ensuring events are replayed in the exact order they were appended per SC-001.
    ///
    /// Note: Tick monotonicity is NOT enforced by default. Ticks may decrease while
    /// sequences increase. Use the overload with AppendOptions to control tick policy.
    /// </summary>
    /// <param name="stream">
    /// The truth stream identity where events will be appended.
    /// Stream isolation is enforced: events from different streams are independent.
    /// </param>
    /// <param name="events">
    /// The events to append. Each event must have a matching StreamIdentity
    /// and a unique Sequence within the stream.
    /// </param>
    /// <param name="cancellationToken">
    /// Token to cancel the operation.
    /// </param>
    /// <returns>
    /// Task representing the asynchronous append operation.
    /// </returns>
    Task AppendAsync(
        TruthStreamIdentity stream,
        IEnumerable<IPlateTopologyEvent> events,
        CancellationToken cancellationToken
    );

    /// <summary>
    /// Appends a batch of events to the specified stream with custom options.
    ///
    /// All events must have the same StreamIdentity matching the stream parameter.
    /// Events must have monotonically increasing Sequence numbers for the stream.
    /// The operation should be atomic: either all events succeed or none are persisted.
    /// </summary>
    /// <param name="stream">
    /// The truth stream identity where events will be appended.
    /// </param>
    /// <param name="events">
    /// The events to append.
    /// </param>
    /// <param name="options">
    /// Options controlling append behavior, including tick monotonicity policy.
    /// </param>
    /// <param name="cancellationToken">
    /// Token to cancel the operation.
    /// </param>
    Task AppendAsync(
        TruthStreamIdentity stream,
        IEnumerable<IPlateTopologyEvent> events,
        AppendOptions options,
        CancellationToken cancellationToken
    );

    /// <summary>
    /// Reads events from a stream starting from a specific Sequence number.
    ///
    /// Events are returned in ascending Sequence order, which is required for
    /// deterministic replay per FR-012 and SC-001. The stream identity isolates
    /// reads to only events belonging to that stream.
    /// </summary>
    /// <param name="stream">
    /// The truth stream identity to read from.
    /// Stream isolation is enforced: only events from this stream are returned.
    /// </param>
    /// <param name="fromSequenceInclusive">
    /// The starting Sequence number (inclusive). Events with Sequence >= this value
    /// are returned. Use 0 to read from the beginning of the stream.
    /// </param>
    /// <param name="cancellationToken">
    /// Token to cancel the asynchronous enumeration.
    /// </param>
    /// <returns>
    /// Async enumerable of events in Sequence order.
    /// </returns>
    IAsyncEnumerable<IPlateTopologyEvent> ReadAsync(
        TruthStreamIdentity stream,
        long fromSequenceInclusive,
        CancellationToken cancellationToken
    );

    /// <summary>
    /// Gets the highest Sequence number for a stream.
    ///
    /// Useful for determining the current stream version before appending new events.
    /// The Sequence number is monotonically increasing within each stream identity,
    /// and streams are fully isolated from each other.
    /// </summary>
    /// <param name="stream">
    /// The truth stream identity to query.
    /// Stream isolation is enforced: only sequences from this stream are considered.
    /// </param>
    /// <param name="cancellationToken">
    /// Token to cancel the operation.
    /// </param>
    /// <returns>
    /// The highest Sequence number, or null if the stream is empty or does not exist.
    /// </returns>
    Task<long?> GetLastSequenceAsync(
        TruthStreamIdentity stream,
        CancellationToken cancellationToken
    );

    /// <summary>
    /// Gets the current head state (sequence + hash) of a stream.
    ///
    /// Use this method to obtain the precondition for optimistic concurrency control.
    /// The returned <see cref="StreamHead"/> can be converted to a <see cref="HeadPrecondition"/>
    /// via <see cref="StreamHead.ToPrecondition"/> and passed to <see cref="AppendOptions.ExpectedHead"/>.
    ///
    /// Design rationale (RFC-V2-0005 review):
    /// - Returns both sequence AND hash to enable full concurrency check
    /// - Hash comparison catches scenarios where sequence matches but content differs (corruption)
    /// - Per-stream locking in implementation ensures read-modify-write atomicity in-process
    /// </summary>
    /// <param name="stream">
    /// The truth stream identity to query.
    /// </param>
    /// <param name="cancellationToken">
    /// Token to cancel the operation.
    /// </param>
    /// <returns>
    /// The current head state, or <see cref="StreamHead.Empty"/> if stream doesn't exist.
    /// </returns>
    Task<StreamHead> GetHeadAsync(
        TruthStreamIdentity stream,
        CancellationToken cancellationToken
    );
}


// --- PATH: contracts/Geosphere.Plate.Topology.Contracts/Events/JunctionCreatedEvent.cs ---
using System;
using System.Collections.Immutable;
using System.Runtime.InteropServices;
using Plate.TimeDete.Time.Primitives;
using FantaSim.Geosphere.Plate.Topology.Contracts.Entities;
using FantaSim.Geosphere.Plate.Topology.Contracts.Identity;
using FantaSim.Geosphere.Plate.Topology.Contracts.Numerics;
using UnifySerialization.Abstractions;

namespace FantaSim.Geosphere.Plate.Topology.Contracts.Events;

/// <summary>
/// Event representing the creation of a new junction where boundaries meet per FR-008.
///
/// Junctions are the nodes of the plate boundary graph where three or more boundaries
/// converge. Junctions have a spatial location on the spherical body surface and track
/// which boundaries meet at that location.
/// </summary>
/// <remarks>
/// <para>
/// <b>Sphere-by-default:</b> Location is a <see cref="SurfacePoint"/> (unit surface normal
/// + radius), not a 2D planar point. This ensures correctness anywhere on the sphere.
/// </para>
/// </remarks>
/// <param name="EventId">Unique identifier for this event (UUIDv7).</param>
/// <param name="JunctionId">The unique identifier of the newly created junction.</param>
/// <param name="BoundaryIds">The list of boundaries meeting at this junction.</param>
/// <param name="Location">The surface point location of this junction.</param>
/// <param name="Tick">Canonical simulation tick when this event occurred.</param>
/// <param name="Sequence">Ordering within the event stream.</param>
/// <param name="StreamIdentity">The truth stream this event belongs to.</param>
/// <param name="PreviousHash">Hash of the previous event in the chain (empty for genesis).</param>
/// <param name="Hash">Cryptographic hash of this event (computed, not set by callers).</param>
[StructLayout(LayoutKind.Auto)]
[UnifyModel]
public readonly record struct JunctionCreatedEvent(
    [property: UnifyProperty(0)] Guid EventId,
    [property: UnifyProperty(1)] JunctionId JunctionId,
    [property: UnifyProperty(7)] ImmutableArray<BoundaryId> BoundaryIds,
    [property: UnifyProperty(8)] SurfacePoint Location,
    [property: UnifyProperty(2)] CanonicalTick Tick,
    [property: UnifyProperty(3)] long Sequence,
    [property: UnifyProperty(4)] TruthStreamIdentity StreamIdentity,
    [property: UnifyProperty(5)] ReadOnlyMemory<byte> PreviousHash,
    [property: UnifyProperty(6)] ReadOnlyMemory<byte> Hash
) : IPlateTopologyEvent
{
    /// <summary>
    /// Gets the event type discriminator for polymorphic deserialization.
    /// </summary>
    string IPlateTopologyEvent.EventType => nameof(JunctionCreatedEvent);
}


// --- PATH: contracts/Geosphere.Plate.Topology.Contracts/Events/JunctionRetiredEvent.cs ---
using System;
using System.Runtime.InteropServices;
using Plate.TimeDete.Time.Primitives;
using FantaSim.Geosphere.Plate.Topology.Contracts.Entities;
using FantaSim.Geosphere.Plate.Topology.Contracts.Identity;
using UnifySerialization.Abstractions;

namespace FantaSim.Geosphere.Plate.Topology.Contracts.Events;

/// <summary>
/// Event representing the retirement of a junction per FR-008.
///
/// Junction retirement marks the end of a junction's lifecycle. Retired junctions
/// no longer participate in the active topology but their identity remains reserved
/// to prevent reuse (per FR-005).
/// </summary>
/// <param name="EventId">Unique identifier for this event (UUIDv7).</param>
/// <param name="JunctionId">The unique identifier of the retired junction.</param>
/// <param name="Reason">Optional reason or cause for the retirement.</param>
/// <param name="Tick">Canonical simulation tick when this event occurred.</param>
/// <param name="Sequence">Ordering within the event stream.</param>
/// <param name="StreamIdentity">The truth stream this event belongs to.</param>
/// <param name="PreviousHash">Hash of the previous event in the chain (empty for genesis).</param>
/// <param name="Hash">Cryptographic hash of this event (computed, not set by callers).</param>
[StructLayout(LayoutKind.Auto)]
[UnifyModel]
public readonly record struct JunctionRetiredEvent(
    [property: UnifyProperty(0)] Guid EventId,
    [property: UnifyProperty(1)] JunctionId JunctionId,
    [property: UnifyProperty(7)] string? Reason,
    [property: UnifyProperty(2)] CanonicalTick Tick,
    [property: UnifyProperty(3)] long Sequence,
    [property: UnifyProperty(4)] TruthStreamIdentity StreamIdentity,
    [property: UnifyProperty(5)] ReadOnlyMemory<byte> PreviousHash,
    [property: UnifyProperty(6)] ReadOnlyMemory<byte> Hash
) : IPlateTopologyEvent
{
    /// <summary>
    /// Gets the event type discriminator for polymorphic deserialization.
    /// </summary>
    string IPlateTopologyEvent.EventType => nameof(JunctionRetiredEvent);
}


// --- PATH: contracts/Geosphere.Plate.Topology.Contracts/Events/JunctionUpdatedEvent.cs ---
using System;
using System.Collections.Immutable;
using System.Runtime.InteropServices;
using Plate.TimeDete.Time.Primitives;
using FantaSim.Geosphere.Plate.Topology.Contracts.Entities;
using FantaSim.Geosphere.Plate.Topology.Contracts.Identity;
using FantaSim.Geosphere.Plate.Topology.Contracts.Numerics;
using UnifySerialization.Abstractions;

namespace FantaSim.Geosphere.Plate.Topology.Contracts.Events;

/// <summary>
/// Event representing an update to a junction per FR-016.
///
/// Junction updates capture changes to which boundaries meet at a junction
/// and/or changes to the junction's spatial location. Per FR-016, junction
/// updates must be explicit when connected boundaries change.
/// </summary>
/// <remarks>
/// <para>
/// <b>Sphere-by-default:</b> Location is a <see cref="SurfacePoint"/> (unit surface normal
/// + radius), not a 2D planar point. This ensures correctness anywhere on the sphere.
/// </para>
/// </remarks>
/// <param name="EventId">Unique identifier for this event (UUIDv7).</param>
/// <param name="JunctionId">The unique identifier of the junction being updated.</param>
/// <param name="NewBoundaryIds">The updated list of boundaries meeting at this junction.</param>
/// <param name="NewLocation">The new surface point location of this junction (optional).</param>
/// <param name="Tick">Canonical simulation tick when this event occurred.</param>
/// <param name="Sequence">Ordering within the event stream.</param>
/// <param name="StreamIdentity">The truth stream this event belongs to.</param>
/// <param name="PreviousHash">Hash of the previous event in the chain (empty for genesis).</param>
/// <param name="Hash">Cryptographic hash of this event (computed, not set by callers).</param>
[StructLayout(LayoutKind.Auto)]
[UnifyModel]
public readonly record struct JunctionUpdatedEvent(
    [property: UnifyProperty(0)] Guid EventId,
    [property: UnifyProperty(1)] JunctionId JunctionId,
    [property: UnifyProperty(7)] ImmutableArray<BoundaryId> NewBoundaryIds,
    [property: UnifyProperty(8)] SurfacePoint? NewLocation,
    [property: UnifyProperty(2)] CanonicalTick Tick,
    [property: UnifyProperty(3)] long Sequence,
    [property: UnifyProperty(4)] TruthStreamIdentity StreamIdentity,
    [property: UnifyProperty(5)] ReadOnlyMemory<byte> PreviousHash,
    [property: UnifyProperty(6)] ReadOnlyMemory<byte> Hash
) : IPlateTopologyEvent
{
    /// <summary>
    /// Gets the event type discriminator for polymorphic deserialization.
    /// </summary>
    string IPlateTopologyEvent.EventType => nameof(JunctionUpdatedEvent);
}


// --- PATH: contracts/Geosphere.Plate.Topology.Contracts/Events/PlateCreatedEvent.cs ---
using System;
using System.Runtime.InteropServices;
using Plate.TimeDete.Time.Primitives;
using FantaSim.Geosphere.Plate.Topology.Contracts.Entities;
using FantaSim.Geosphere.Plate.Topology.Contracts.Identity;
using UnifySerialization.Abstractions;

namespace FantaSim.Geosphere.Plate.Topology.Contracts.Events;

/// <summary>
/// Event representing the creation of a new tectonic plate per FR-008.
///
/// Creation events establish the existence of a plate in the topology.
/// Once created, a plate is uniquely identified by its PlateId and persists
/// through all subsequent topology changes until retirement.
/// </summary>
/// <param name="EventId">Unique identifier for this event (UUIDv7).</param>
/// <param name="PlateId">The unique identifier of the newly created plate.</param>
/// <param name="Tick">Canonical simulation tick when this event occurred.</param>
/// <param name="Sequence">Ordering within the event stream.</param>
/// <param name="StreamIdentity">The truth stream this event belongs to.</param>
/// <param name="PreviousHash">Hash of the previous event in the chain (empty for genesis).</param>
/// <param name="Hash">Cryptographic hash of this event (computed, not set by callers).</param>
[StructLayout(LayoutKind.Auto)]
[UnifyModel]
public readonly record struct PlateCreatedEvent(
    [property: UnifyProperty(0)] Guid EventId,
    [property: UnifyProperty(1)] PlateId PlateId,
    [property: UnifyProperty(2)] CanonicalTick Tick,
    [property: UnifyProperty(3)] long Sequence,
    [property: UnifyProperty(4)] TruthStreamIdentity StreamIdentity,
    [property: UnifyProperty(5)] ReadOnlyMemory<byte> PreviousHash,
    [property: UnifyProperty(6)] ReadOnlyMemory<byte> Hash
) : IPlateTopologyEvent
{
    /// <summary>
    /// Gets the event type discriminator for polymorphic deserialization.
    /// </summary>
    string IPlateTopologyEvent.EventType => nameof(PlateCreatedEvent);
}


// --- PATH: contracts/Geosphere.Plate.Topology.Contracts/Events/PlateRetiredEvent.cs ---
using System;
using System.Runtime.InteropServices;
using Plate.TimeDete.Time.Primitives;
using FantaSim.Geosphere.Plate.Topology.Contracts.Entities;
using FantaSim.Geosphere.Plate.Topology.Contracts.Identity;
using UnifySerialization.Abstractions;

namespace FantaSim.Geosphere.Plate.Topology.Contracts.Events;

/// <summary>
/// Event representing the retirement of a plate per FR-008 (optional but recommended).
///
/// Plate retirement marks the end of a plate's lifecycle. Retired plates
/// no longer participate in the active topology but their identity remains reserved
/// to prevent reuse (per FR-005).
/// </summary>
/// <param name="EventId">Unique identifier for this event (UUIDv7).</param>
/// <param name="PlateId">The unique identifier of the retired plate.</param>
/// <param name="Reason">Optional reason or cause for the retirement.</param>
/// <param name="Tick">Canonical simulation tick when this event occurred.</param>
/// <param name="Sequence">Ordering within the event stream.</param>
/// <param name="StreamIdentity">The truth stream this event belongs to.</param>
/// <param name="PreviousHash">Hash of the previous event in the chain (empty for genesis).</param>
/// <param name="Hash">Cryptographic hash of this event (computed, not set by callers).</param>
[StructLayout(LayoutKind.Auto)]
[UnifyModel]
public readonly record struct PlateRetiredEvent(
    [property: UnifyProperty(0)] Guid EventId,
    [property: UnifyProperty(1)] PlateId PlateId,
    [property: UnifyProperty(7)] string? Reason,
    [property: UnifyProperty(2)] CanonicalTick Tick,
    [property: UnifyProperty(3)] long Sequence,
    [property: UnifyProperty(4)] TruthStreamIdentity StreamIdentity,
    [property: UnifyProperty(5)] ReadOnlyMemory<byte> PreviousHash,
    [property: UnifyProperty(6)] ReadOnlyMemory<byte> Hash
) : IPlateTopologyEvent
{
    /// <summary>
    /// Gets the event type discriminator for polymorphic deserialization.
    /// </summary>
    string IPlateTopologyEvent.EventType => nameof(PlateRetiredEvent);
}


// --- PATH: contracts/Geosphere.Plate.Topology.Contracts/Events/StreamHead.cs ---
﻿namespace FantaSim.Geosphere.Plate.Topology.Contracts.Events;

/// <summary>
/// Represents the current head state of an event stream per RFC-V2-0004.
///
/// Contains sequence, hash, and tick which together uniquely identify
/// the stream state. Used for optimistic concurrency control via
/// <see cref="HeadPrecondition"/>.
///
/// RFC-V2-0004 specifies head metadata as {lastSeq, lastHash, lastTick}.
/// </summary>
public readonly struct StreamHead : IEquatable<StreamHead>
{
    /// <summary>
    /// Hash size in bytes (SHA-256).
    /// </summary>
    public const int HashSizeBytes = 32;

    /// <summary>
    /// Zero hash representing an empty/genesis stream.
    /// </summary>
    public static readonly byte[] ZeroHash = new byte[HashSizeBytes];

    /// <summary>
    /// Head state for an empty (non-existent) stream.
    /// </summary>
    public static StreamHead Empty => new(-1, ZeroHash, -1);

    private readonly byte[] _hash;

    /// <summary>
    /// The highest sequence number in the stream, or -1 if empty.
    /// </summary>
    public long Sequence { get; }

    /// <summary>
    /// The hash of the last event record, or zero hash if empty.
    /// Returns a defensive copy to prevent mutation.
    /// </summary>
    public byte[] Hash => (byte[])_hash.Clone();

    /// <summary>
    /// The tick of the last event, or -1 if empty.
    /// Per RFC-V2-0004, this is stored in head metadata for fast access.
    /// </summary>
    public long LastTick { get; }

    /// <summary>
    /// Creates a new stream head state.
    /// </summary>
    /// <param name="sequence">The highest sequence number, or -1 if empty.</param>
    /// <param name="hash">The hash of the last event record (32 bytes). Will be cloned.</param>
    /// <param name="lastTick">The tick of the last event, or -1 if empty.</param>
    public StreamHead(long sequence, byte[] hash, long lastTick)
    {
        ArgumentNullException.ThrowIfNull(hash);
        if (hash.Length != HashSizeBytes)
            throw new ArgumentException($"Hash must be {HashSizeBytes} bytes", nameof(hash));

        Sequence = sequence;
        _hash = (byte[])hash.Clone(); // Defensive copy
        LastTick = lastTick;
    }

    /// <summary>
    /// Creates a new stream head state (backward-compatible overload without tick).
    /// LastTick will be set to -1 (unknown).
    /// </summary>
    [Obsolete("Use the overload with lastTick parameter for RFC-V2-0004 compliance")]
    public StreamHead(long sequence, byte[] hash) : this(sequence, hash, -1)
    {
    }

    /// <summary>
    /// Whether this represents an empty stream.
    /// </summary>
    public bool IsEmpty => Sequence == -1;

    /// <summary>
    /// Converts to a <see cref="HeadPrecondition"/> for use in append operations.
    /// </summary>
    public HeadPrecondition ToPrecondition() => new(Sequence, _hash);

    /// <summary>
    /// Internal access to hash without cloning (for comparison only).
    /// </summary>
    internal ReadOnlySpan<byte> HashSpan => _hash.AsSpan();

    public bool Equals(StreamHead other)
    {
        return Sequence == other.Sequence &&
               LastTick == other.LastTick &&
               _hash.AsSpan().SequenceEqual(other._hash);
    }

    public override bool Equals(object? obj) => obj is StreamHead other && Equals(other);

    public override int GetHashCode()
    {
        var hashCode = new HashCode();
        hashCode.Add(Sequence);
        hashCode.Add(LastTick);
        foreach (var b in _hash)
            hashCode.Add(b);
        return hashCode.ToHashCode();
    }

    public static bool operator ==(StreamHead left, StreamHead right) => left.Equals(right);
    public static bool operator !=(StreamHead left, StreamHead right) => !left.Equals(right);
}


// --- PATH: contracts/Geosphere.Plate.Topology.Contracts/Identity/Domain.cs ---
using System;
using System.Runtime.InteropServices;

namespace FantaSim.Geosphere.Plate.Topology.Contracts.Identity;

/// <summary>
/// Stable domain identifier for truth streams.
///
/// Domains SHOULD be stable and specific (e.g., "geo.plates").
/// Domain identifiers are case-sensitive and must follow a dot-notation convention.
/// </summary>
[StructLayout(LayoutKind.Auto)]
public readonly record struct Domain
{
    private readonly string _value;

    public static readonly Domain GeoPlatesTopology = Parse("geo.plates.topology");

    public static readonly Domain GeoPlatesKinematics = Parse("geo.plates.kinematics");

    /// <summary>
    /// The domain identifier value (e.g., "geo.plates").
    /// </summary>
    public string Value => _value;

    /// <summary>
    /// Private constructor to enforce validation via Parse.
    /// </summary>
    private Domain(string value)
    {
        _value = value;
    }

    /// <summary>
    /// Gets a value indicating whether this domain is empty/default.
    /// </summary>
    public bool IsEmpty => string.IsNullOrEmpty(_value);

    /// <summary>
    /// Parses a domain identifier string into a Domain struct.
    /// Valid domain identifiers are non-empty and contain only alphanumeric characters, dots, and underscores.
    /// </summary>
    /// <param name="value">The domain identifier string to parse.</param>
    /// <returns>A Domain struct.</returns>
    /// <exception cref="ArgumentException">Thrown when the value is null, empty, whitespace, or contains invalid characters.</exception>
    public static Domain Parse(string value)
    {
        if (string.IsNullOrWhiteSpace(value))
            throw new ArgumentException("Domain identifier cannot be null, empty, or whitespace.", nameof(value));

        // Validate format: alphanumeric, dots, underscores only
        foreach (char c in value)
        {
            if (!char.IsLetterOrDigit(c) && c != '.' && c != '_')
                throw new ArgumentException($"Domain identifier contains invalid character: '{c}'. Only alphanumeric characters, dots, and underscores are allowed.", nameof(value));
        }

        // Prevent consecutive dots or leading/trailing dots
        if (value.IndexOf("..", StringComparison.Ordinal) >= 0 || value.StartsWith('.') || value.EndsWith('.'))
            throw new ArgumentException("Domain identifier cannot contain consecutive dots, or start/end with a dot.", nameof(value));

        return new Domain(value);
    }

    /// <summary>
    /// Attempts to parse a domain identifier string into a Domain struct.
    /// </summary>
    /// <param name="value">The domain identifier string to parse.</param>
    /// <param name="domain">When this method returns, contains the parsed Domain if parsing succeeded.</param>
    /// <returns>true if parsing succeeded; false otherwise.</returns>
    public static bool TryParse(string value, out Domain domain)
    {
        try
        {
            domain = Parse(value);
            return true;
        }
        catch
        {
            domain = default;
            return false;
        }
    }

    /// <summary>
    /// Returns the string representation of the domain identifier.
    /// </summary>
    public override string ToString()
    {
        return _value ?? string.Empty;
    }

    /// <summary>
    /// Validates that the domain identifier is well-formed.
    /// Applies the same validation rules as Parse():
    /// - Non-empty and non-whitespace
    /// - Contains only alphanumeric characters, dots, and underscores
    /// - No consecutive dots, leading dots, or trailing dots
    /// </summary>
    public bool IsValid()
    {
        if (string.IsNullOrWhiteSpace(_value))
            return false;

        // Check for invalid characters
        foreach (char c in _value)
        {
            if (!char.IsLetterOrDigit(c) && c != '.' && c != '_')
                return false;
        }

        // Check for consecutive dots or leading/trailing dots
        if (_value.IndexOf("..", StringComparison.Ordinal) >= 0 || _value.StartsWith('.') || _value.EndsWith('.'))
            return false;

        return true;
    }

    /// <summary>
    /// Implicit conversion from Domain to string for convenience.
    /// </summary>
    public static implicit operator string(Domain domain) => domain._value;

    /// <summary>
    /// Explicit conversion from string to Domain (throws on invalid input).
    /// </summary>
    public static explicit operator Domain(string value) => Parse(value);

    /// <summary>
    /// Equality comparison for Domain structs.
    /// </summary>
    public bool Equals(Domain other)
    {
        return string.Equals(_value, other._value, StringComparison.Ordinal);
    }

    /// <summary>
    /// Hash code computation for Domain structs.
    /// </summary>
    public override int GetHashCode()
    {
        return _value?.GetHashCode(StringComparison.Ordinal) ?? 0;
    }
}


// --- PATH: contracts/Geosphere.Plate.Topology.Contracts/Identity/GuidOrdering.cs ---
using System;
using System.Collections.Generic;

namespace FantaSim.Geosphere.Plate.Topology.Contracts.Identity;

/// <summary>
/// Deterministic Guid ordering helper using RFC 4122 byte order.
/// </summary>
public static class GuidOrdering
{
    public static IComparer<Guid> Rfc4122Comparer { get; } = Comparer<Guid>.Create(CompareRfc4122);

    public static int CompareRfc4122(Guid a, Guid b)
    {
        Span<byte> aLe = stackalloc byte[16];
        Span<byte> bLe = stackalloc byte[16];

        a.TryWriteBytes(aLe);
        b.TryWriteBytes(bLe);

        for (var i = 0; i < 16; i++)
        {
            var ab = GetRfc4122ByteAt(aLe, i);
            var bb = GetRfc4122ByteAt(bLe, i);

            if (ab < bb)
                return -1;
            if (ab > bb)
                return 1;
        }

        return 0;
    }

    private static byte GetRfc4122ByteAt(ReadOnlySpan<byte> littleEndianGuidBytes, int index)
    {
        return index switch
        {
            0 => littleEndianGuidBytes[3],
            1 => littleEndianGuidBytes[2],
            2 => littleEndianGuidBytes[1],
            3 => littleEndianGuidBytes[0],
            4 => littleEndianGuidBytes[5],
            5 => littleEndianGuidBytes[4],
            6 => littleEndianGuidBytes[7],
            7 => littleEndianGuidBytes[6],
            _ => littleEndianGuidBytes[index]
        };
    }
}


// --- PATH: contracts/Geosphere.Plate.Topology.Contracts/Identity/TruthStreamIdentity.cs ---
using System;
using System.Runtime.InteropServices;
using FantaSim.Geosphere.Plate.Topology.Contracts.Entities;
using UnifySerialization.Abstractions;

namespace FantaSim.Geosphere.Plate.Topology.Contracts.Identity;

/// <summary>
/// Uniquely identifies a stream of truth events in the system.
///
/// A truth stream is the authoritative sequence of events for a specific domain
/// within a specific world variant and branch. It forms the primary key for
/// event storage and retrieval.
/// </summary>
/// <param name="VariantId">The world variant (e.g. "main", "experimental-1").</param>
/// <param name="BranchId">The branch within the variant (e.g. "trunk", "scenario-a").</param>
/// <param name="LLevel">The truth L-level (see RFC-086: L×R×M Axis Model; R is not part of stream identity).</param>
/// <param name="Domain">Stable domain identifier for routing and storage (dot-notation, e.g. "geo.plates.topology").</param>
/// <param name="Model">The model identifier (e.g. "M0").</param>
[StructLayout(LayoutKind.Auto)]
[UnifyModel]
public readonly record struct TruthStreamIdentity(
    [property: UnifyProperty(0)] string VariantId,
    [property: UnifyProperty(1)] string BranchId,
    [property: UnifyProperty(2)] int LLevel,
    [property: UnifyProperty(3)] Domain Domain,
    [property: UnifyProperty(4)] string Model
)
{
    /// <summary>
    /// Returns a string representation of the identity in standard URN format.
    /// Format: urn:fantasim:{VariantId}:{BranchId}:L{LLevel}:{Domain}:{Model}
    /// </summary>
    public override string ToString() =>
        $"urn:fantasim:{VariantId}:{BranchId}:L{LLevel}:{Domain}:{NormalizeModel(Model)}";

    /// <summary>
    /// Parses a URN string into a TruthStreamIdentity.
    /// </summary>
    public static TruthStreamIdentity Parse(string urn)
    {
        if (!TryParse(urn, out var identity))
        {
            throw new FormatException($"Invalid TruthStreamIdentity URN: {urn}");
        }
        return identity;
    }

    public static bool TryParse(string urn, out TruthStreamIdentity identity)
    {
        identity = default;
        if (string.IsNullOrWhiteSpace(urn) || !urn.StartsWith("urn:fantasim:", StringComparison.Ordinal))
        {
            return false;
        }

        var parts = urn.Substring("urn:fantasim:".Length).Split(':');
        if (parts.Length != 5)
        {
            return false;
        }

        if (!parts[2].StartsWith("L", StringComparison.Ordinal) || !int.TryParse(parts[2].Substring(1), out var lLevel))
        {
            return false;
        }

        if (!Domain.TryParse(parts[3], out var domain))
        {
            return false;
        }

        var model = NormalizeModel(parts[4]);
        identity = new TruthStreamIdentity(parts[0], parts[1], lLevel, domain, model);
        return true;
    }

    /// <summary>
    /// Returns the deterministic stream key for this identity.
    /// Format: {VariantId}:{BranchId}:L{LLevel}:{Domain}:{Model}
    /// </summary>
    public string ToStreamKey() =>
        $"{VariantId}:{BranchId}:L{LLevel}:{Domain}:{NormalizeModel(Model)}";

    /// <summary>
    /// Returns the canonical event stream identity string for fingerprinting.
    /// Format: S:{streamKey}:Events
    ///
    /// This format is per RFC-V2-0006 §5.3 for use in InputFingerprint computation.
    /// </summary>
    public string ToEventStreamIdString() =>
        $"S:{ToStreamKey()}:Events";

    private static string NormalizeModel(string model)
    {
        if (string.IsNullOrWhiteSpace(model))
            return model;

        var allDigits = true;
        foreach (var c in model)
        {
            if (!char.IsDigit(c))
            {
                allDigits = false;
                break;
            }
        }

        if (allDigits)
            return "M" + model;

        if (model[0] == 'm')
            return "M" + model.Substring(1);

        return model;
    }

    /// <summary>
    /// Validates that the identity components are well-formed.
    /// </summary>
    public bool IsValid()
    {
        return !string.IsNullOrWhiteSpace(VariantId) &&
               !string.IsNullOrWhiteSpace(BranchId) &&
               LLevel >= 0 &&
               !Domain.IsEmpty &&
               !string.IsNullOrWhiteSpace(Model);
    }
}


// --- PATH: contracts/Geosphere.Plate.Topology.Contracts/Numerics/DoublePrecision.cs ---
using System;
using System.Runtime.InteropServices;
using MessagePack;

namespace FantaSim.Geosphere.Plate.Topology.Contracts.Numerics;

[StructLayout(LayoutKind.Auto)]
[MessagePackObject]
public readonly record struct Vector3d(
    [property: Key(0)] double X,
    [property: Key(1)] double Y,
    [property: Key(2)] double Z)
{
    public static Vector3d Zero => new(0, 0, 0);
    public static Vector3d UnitX => new(1, 0, 0);
    public static Vector3d UnitY => new(0, 1, 0);
    public static Vector3d UnitZ => new(0, 0, 1);

    public double Length() => Math.Sqrt(X * X + Y * Y + Z * Z);
    public double LengthSquared() => X * X + Y * Y + Z * Z;

    public double Dot(Vector3d other) => X * other.X + Y * other.Y + Z * other.Z;

    public Vector3d Cross(Vector3d other) => new(
        Y * other.Z - Z * other.Y,
        Z * other.X - X * other.Z,
        X * other.Y - Y * other.X);

    public Vector3d Normalize()
    {
        var len = Length();
        return len > double.Epsilon ? this / len : Zero;
    }

    public static Vector3d operator +(Vector3d a, Vector3d b) => new(a.X + b.X, a.Y + b.Y, a.Z + b.Z);
    public static Vector3d operator -(Vector3d a) => new(-a.X, -a.Y, -a.Z);
    public static Vector3d operator -(Vector3d a, Vector3d b) => new(a.X - b.X, a.Y - b.Y, a.Z - b.Z);
    public static Vector3d operator *(Vector3d a, double d) => new(a.X * d, a.Y * d, a.Z * d);
    public static Vector3d operator /(Vector3d a, double d) => new(a.X / d, a.Y / d, a.Z / d);
}

[StructLayout(LayoutKind.Auto)]
[MessagePackObject]
public readonly record struct Quaterniond(
    [property: Key(0)] double X,
    [property: Key(1)] double Y,
    [property: Key(2)] double Z,
    [property: Key(3)] double W)
{
    public static Quaterniond Identity => new(0, 0, 0, 1);

    public Quaterniond Conjugate()
        => new(-X, -Y, -Z, W);

    public Quaterniond Inverse()
    {
        var norm = (X * X) + (Y * Y) + (Z * Z) + (W * W);
        if (norm == 0d)
            return Identity;

        var c = Conjugate();
        return new Quaterniond(c.X / norm, c.Y / norm, c.Z / norm, c.W / norm);
    }

    public static Quaterniond Multiply(Quaterniond a, Quaterniond b)
    {
        return new Quaterniond(
            (a.W * b.X) + (a.X * b.W) + (a.Y * b.Z) - (a.Z * b.Y),
            (a.W * b.Y) - (a.X * b.Z) + (a.Y * b.W) + (a.Z * b.X),
            (a.W * b.Z) + (a.X * b.Y) - (a.Y * b.X) + (a.Z * b.W),
            (a.W * b.W) - (a.X * b.X) - (a.Y * b.Y) - (a.Z * b.Z));
    }

    public static Quaterniond FromAxisAngle(Vector3d axis, double angle)
    {
        double halfAngle = angle * 0.5;
        double s = Math.Sin(halfAngle);
        double c = Math.Cos(halfAngle);
        return new Quaterniond(axis.X * s, axis.Y * s, axis.Z * s, c);
    }

    public static double Angle(Quaterniond a, Quaterniond b)
    {
        double dot = a.X * b.X + a.Y * b.Y + a.Z * b.Z + a.W * b.W;
        return Math.Acos(Math.Min(Math.Abs(dot), 1.0)) * 2.0;
    }
}


// --- PATH: contracts/Geosphere.Plate.Topology.Contracts/Numerics/Frame3.cs ---
using System;
using System.Runtime.InteropServices;
using MessagePack;

namespace FantaSim.Geosphere.Plate.Topology.Contracts.Numerics;

/// <summary>
/// A 3D orthonormal frame for local tangent-plane calculations on a sphere.
/// </summary>
/// <remarks>
/// <para>
/// Frame3 provides a local coordinate system at a point on a sphere's surface:
/// </para>
/// <list type="bullet">
///   <item><b>Origin</b>: The surface point (unit vector from body center)</item>
///   <item><b>Up</b>: Unit normal pointing away from body center (same as Origin for unit sphere)</item>
///   <item><b>North</b>: Unit tangent vector pointing toward geographic north</item>
///   <item><b>East</b>: Unit tangent vector pointing toward geographic east</item>
/// </list>
/// <para>
/// This frame enables stable angle computations on the sphere surface by projecting
/// 3D vectors onto the local tangent plane (North/East basis).
/// </para>
/// <para>
/// <b>Determinism:</b> Frame construction is deterministic for the same surface point.
/// North is defined as the projection of the global +Z axis onto the tangent plane.
/// </para>
/// </remarks>
[StructLayout(LayoutKind.Auto)]
[MessagePackObject]
public readonly record struct Frame3(
    [property: Key(0)] UnitVector3d Origin,
    [property: Key(1)] UnitVector3d North,
    [property: Key(2)] UnitVector3d East,
    [property: Key(3)] UnitVector3d Up)
{
    /// <summary>
    /// Creates a Frame3 from a surface normal (unit vector pointing outward from body center).
    /// </summary>
    /// <remarks>
    /// For a unit sphere, the surface point IS the normal vector.
    /// North is computed as the projection of global +Z onto the tangent plane.
    /// This is deterministic except at the poles where +Z is parallel to Up.
    /// </remarks>
    public static Frame3 CreateFromSurfaceNormal(UnitVector3d normal)
    {
        // Up is the surface normal (pointing outward from body center)
        var up = normal;

        // North: projection of global +Z onto tangent plane
        // At poles, use global +X as fallback for North
        var globalZ = UnitVector3d.UnitZ.ToVector3d();
        var northVector = globalZ - up.ToVector3d() * up.Dot(globalZ);

        UnitVector3d north;
        var northLen = northVector.Length();
        if (northLen > 1e-10)
        {
            // Normal case: project +Z onto tangent plane
            north = new UnitVector3d(
                northVector.X / northLen,
                northVector.Y / northLen,
                northVector.Z / northLen);
        }
        else
        {
            // At poles (+Z or -Z), use +X as North
            north = UnitVector3d.UnitX;
        }

        // East = Up × North (ensures right-handed frame: North × East = Up)
        var eastVector = up.Cross(north);
        var eastLen = eastVector.Length();

        // This should always be ~1 since up and north are orthogonal
        var east = eastLen > 1e-10
            ? UnitVector3d.FromVector3d(eastVector)!.Value
            : UnitVector3d.UnitY; // Fallback, should not happen

        return new Frame3(normal, north, east, up);
    }

    /// <summary>
    /// Projects a 3D vector onto the tangent plane, returning (north, east) components.
    /// </summary>
    /// <param name="v">The vector to project.</param>
    /// <returns>2D vector in tangent plane (x = north component, y = east component).</returns>
    public Vector2d ProjectToTangentPlane(Vector3d v)
    {
        return new Vector2d(
            North.Dot(v),  // north component
            East.Dot(v)    // east component
        );
    }

    /// <summary>
    /// Projects a 3D vector onto the tangent plane, returning (north, east) components.
    /// </summary>
    public Vector2d ProjectToTangentPlane(UnitVector3d v)
    {
        return new Vector2d(
            North.Dot(v),
            East.Dot(v)
        );
    }

    /// <summary>
    /// Computes the angle of a direction vector in the tangent plane.
    /// </summary>
    /// <param name="direction">A 3D direction vector (need not be tangent).</param>
    /// <returns>Angle in radians, measured CCW from North.</returns>
    /// <remarks>
    /// This is the correct way to compute cyclic ordering around a junction on a sphere.
    /// The angle is measured in the local tangent plane, not in some global coordinate system.
    /// </remarks>
    public double ComputeTangentAngle(Vector3d direction)
    {
        var projected = ProjectToTangentPlane(direction);
        return Math.Atan2(projected.Y, projected.X);  // angle from North, CCW positive
    }

    /// <summary>
    /// Computes the angle of a unit direction in the tangent plane.
    /// </summary>
    /// <param name="direction">A unit direction.</param>
    /// <returns>Angle in radians, measured CCW from North.</returns>
    public double ComputeTangentAngle(UnitVector3d direction)
    {
        var projected = ProjectToTangentPlane(direction);
        return Math.Atan2(projected.Y, projected.X);
    }

    /// <summary>
    /// Converts a tangent-plane angle back to a 3D unit direction.
    /// </summary>
    /// <param name="angle">Angle in tangent plane (radians, CCW from North).</param>
    /// <returns>Unit vector in the tangent plane at the given angle.</returns>
    public UnitVector3d TangentAngleToDirection(double angle)
    {
        var cosA = Math.Cos(angle);
        var sinA = Math.Sin(angle);

        // direction = cos(angle) * North + sin(angle) * East
        var dx = cosA * North.X + sinA * East.X;
        var dy = cosA * North.Y + sinA * East.Y;
        var dz = cosA * North.Z + sinA * East.Z;

        // Should already be unit length, but normalize for safety
        return UnitVector3d.FromComponents(dx, dy, dz) ?? North;
    }

    public override string ToString() =>
        $"Frame3(Origin={Origin}, N={North}, E={East}, U={Up})";
}

/// <summary>
/// 2D vector in a tangent plane (north/east components).
/// </summary>
[StructLayout(LayoutKind.Auto)]
[MessagePackObject]
public readonly record struct Vector2d(
    [property: Key(0)] double X,  // North component
    [property: Key(1)] double Y)  // East component
{
    public static Vector2d Zero => new(0, 0);

    public double Length() => Math.Sqrt(X * X + Y * Y);
    public double LengthSquared() => X * X + Y * Y;

    public Vector2d Normalize()
    {
        var len = Length();
        return len > double.Epsilon ? new Vector2d(X / len, Y / len) : Zero;
    }

    public double Dot(Vector2d other) => X * other.X + Y * other.Y;

    public double Angle() => Math.Atan2(Y, X);

    public static Vector2d operator +(Vector2d a, Vector2d b) => new(a.X + b.X, a.Y + b.Y);
    public static Vector2d operator -(Vector2d a, Vector2d b) => new(a.X - b.X, a.Y - b.Y);
    public static Vector2d operator -(Vector2d v) => new(-v.X, -v.Y);
    public static Vector2d operator *(Vector2d v, double d) => new(v.X * d, v.Y * d);
    public static Vector2d operator /(Vector2d v, double d) => new(v.X / d, v.Y / d);

    public override string ToString() => $"V2({X:G6}, {Y:G6})";
}


// --- PATH: contracts/Geosphere.Plate.Topology.Contracts/Numerics/SphericalGeometry.cs ---
using System;
using UnifyGeometry;

namespace FantaSim.Geosphere.Plate.Topology.Contracts.Numerics;

/// <summary>
/// Spherical geometry calculations for polygon area and orientation.
/// </summary>
/// <remarks>
/// <para>
/// These methods implement correct spherical geometry (not planar approximations)
/// for computing polygon areas and orientations on a sphere.
/// </para>
/// <para>
/// <b>Spherical polygon area:</b> Uses the spherical excess formula (Girard's theorem).
/// The area of a spherical polygon is R² × E, where E is the spherical excess.
/// </para>
/// <para>
/// <b>Ring orientation:</b> The sign of the spherical excess indicates orientation:
/// positive = CCW (interior on left), negative = CW (interior on right).
/// </para>
/// </remarks>
public static class SphericalGeometry
{
    /// <summary>
    /// Computes the signed area of a spherical polygon ring.
    /// </summary>
    /// <param name="ring">The polygon ring as a closed polyline on the unit sphere.</param>
    /// <returns>Signed area in steradians. Positive for CCW orientation.</returns>
    public static double ComputeSignedSphericalArea(Polyline3 ring)
    {
        if (ring == null || ring.PointCount < 3)
            return 0.0;

        var points = ring.Points;
        var n = points.Length;

        // Ensure the ring is closed (first == last)
        bool isClosed = n > 1 &&
            Math.Abs(points[0].X - points[n - 1].X) < 1e-10 &&
            Math.Abs(points[0].Y - points[n - 1].Y) < 1e-10 &&
            Math.Abs(points[0].Z - points[n - 1].Z) < 1e-10;

        // If closed, skip the duplicate last point for calculation
        var vertexCount = isClosed ? n - 1 : n;

        if (vertexCount < 3)
            return 0.0;

        // Normalize all points to unit sphere
        var unitPoints = new UnitVector3d[vertexCount];
        for (int i = 0; i < vertexCount; i++)
        {
            var p = points[i];
            var unit = UnitVector3d.FromComponents(p.X, p.Y, p.Z);
            if (!unit.HasValue)
                return 0.0; // Degenerate case
            unitPoints[i] = unit.Value;
        }

        // Compute spherical excess using the angle sum method
        // E = sum(angles) - (n-2)*π
        double angleSum = 0.0;

        for (int i = 0; i < vertexCount; i++)
        {
            var prev = unitPoints[(i - 1 + vertexCount) % vertexCount];
            var curr = unitPoints[i];
            var next = unitPoints[(i + 1) % vertexCount];

            // Compute the interior angle at this vertex
            var angle = ComputeSphericalAngle(prev, curr, next);
            angleSum += angle;
        }

        // Spherical excess
        double sphericalExcess = angleSum - (vertexCount - 2) * Math.PI;

        // Return signed area (sign indicates orientation)
        return sphericalExcess;
    }

    /// <summary>
    /// Computes the absolute area of a spherical polygon ring.
    /// </summary>
    /// <param name="ring">The polygon ring as a closed polyline on the unit sphere.</param>
    /// <returns>Absolute area in steradians.</returns>
    public static double ComputeSphericalArea(Polyline3 ring)
    {
        return Math.Abs(ComputeSignedSphericalArea(ring));
    }

    /// <summary>
    /// Determines the orientation of a spherical polygon ring.
    /// </summary>
    /// <param name="ring">The polygon ring as a closed polyline on the unit sphere.</param>
    /// <returns>True if CCW (positive area), false if CW (negative area).</returns>
    public static bool IsCounterClockwise(Polyline3 ring)
    {
        return ComputeSignedSphericalArea(ring) > 0;
    }

    /// <summary>
    /// Computes the spherical angle at vertex B given three points on the unit sphere.
    /// </summary>
    /// <param name="a">Previous vertex.</param>
    /// <param name="b">Current vertex (where angle is measured).</param>
    /// <param name="c">Next vertex.</param>
    /// <returns>Interior angle in radians.</returns>
    private static double ComputeSphericalAngle(UnitVector3d a, UnitVector3d b, UnitVector3d c)
    {
        // The spherical angle at B is the angle between the two great circle arcs BA and BC
        // This is the dihedral angle between the planes (O,B,A) and (O,B,C)

        // Normal to plane OBA: b × a
        var normalOBA = b.Cross(a);

        // Normal to plane OBC: b × c
        var normalOBC = b.Cross(c);

        // The angle between the two planes is the angle between their normals
        // But we need to be careful about the sign/direction

        // Normalize the normals
        var lenOBA = normalOBA.Length();
        var lenOBC = normalOBC.Length();

        if (lenOBA < 1e-10 || lenOBC < 1e-10)
            return Math.PI; // Degenerate case

        var n1 = normalOBA / lenOBA;
        var n2 = normalOBC / lenOBC;

        // Angle between normals
        var cosAngle = n1.Dot(n2);
        cosAngle = Math.Clamp(cosAngle, -1.0, 1.0);
        var angle = Math.Acos(cosAngle);

        // Determine sign: check if c is on the "positive" side of plane OBA
        // This gives us the interior vs exterior angle
        var handedness = n1.Dot(c.ToVector3d());
        if (handedness < 0)
        {
            // We got the exterior angle, flip to interior
            angle = 2 * Math.PI - angle;
        }

        return angle;
    }

    /// <summary>
    /// Computes the spherical excess using the l'Huilier formula for a triangle.
    /// More numerically stable for small triangles.
    /// </summary>
    /// <param name="a">First vertex of the triangle.</param>
    /// <param name="b">Second vertex.</param>
    /// <param name="c">Third vertex.</param>
    /// <returns>Spherical excess (signed area for unit sphere).</returns>
    public static double ComputeTriangleSphericalExcess(UnitVector3d a, UnitVector3d b, UnitVector3d c)
    {
        // Side lengths (central angles)
        var a_len = b.AngleTo(c);  // side opposite to A
        var b_len = a.AngleTo(c);  // side opposite to B
        var c_len = a.AngleTo(b);  // side opposite to C

        // Semi-perimeter
        var s = (a_len + b_len + c_len) / 2.0;

        // l'Huilier's formula for spherical excess
        // tan(E/4) = sqrt(tan(s/2) * tan((s-a)/2) * tan((s-b)/2) * tan((s-c)/2))

        var tanS2 = Math.Tan(s / 2.0);
        var tanSa2 = Math.Tan((s - a_len) / 2.0);
        var tanSb2 = Math.Tan((s - b_len) / 2.0);
        var tanSc2 = Math.Tan((s - c_len) / 2.0);

        var product = tanS2 * tanSa2 * tanSb2 * tanSc2;

        // Ensure product is non-negative (can be slightly negative due to numerical errors)
        product = Math.Max(0.0, product);

        var tanE4 = Math.Sqrt(product);
        var E = 4.0 * Math.Atan(tanE4);

        // Determine sign using orientation
        var orientation = ComputeTriangleOrientation(a, b, c);
        return E * orientation;
    }

    /// <summary>
    /// Computes the orientation of a spherical triangle.
    /// </summary>
    /// <returns>+1 for CCW, -1 for CW, 0 for degenerate.</returns>
    private static double ComputeTriangleOrientation(UnitVector3d a, UnitVector3d b, UnitVector3d c)
    {
        // The scalar triple product (a × b) · c gives the signed volume
        var crossAB = a.Cross(b);
        var triple = crossAB.Dot(c.ToVector3d());

        if (Math.Abs(triple) < 1e-15)
            return 0.0;

        return triple > 0 ? 1.0 : -1.0;
    }

    /// <summary>
    /// Great circle interpolation (slerp) between two points on the unit sphere.
    /// </summary>
    /// <param name="a">Start point.</param>
    /// <param name="b">End point.</param>
    /// <param name="t">Interpolation parameter (0 = a, 1 = b).</param>
    /// <returns>Interpolated point on the great circle.</returns>
    public static UnitVector3d Slerp(UnitVector3d a, UnitVector3d b, double t)
    {
        var angle = a.AngleTo(b);

        if (angle < 1e-10)
            return a;

        var sinAngle = Math.Sin(angle);
        var w1 = Math.Sin((1 - t) * angle) / sinAngle;
        var w2 = Math.Sin(t * angle) / sinAngle;

        var nx = w1 * a.X + w2 * b.X;
        var ny = w1 * a.Y + w2 * b.Y;
        var nz = w1 * a.Z + w2 * b.Z;

        // Result should be unit length, normalize for safety
        return UnitVector3d.FromComponents(nx, ny, nz) ?? a;
    }

    /// <summary>
    /// Creates a great circle arc as a polyline with the specified number of segments.
    /// </summary>
    /// <param name="start">Start point on unit sphere.</param>
    /// <param name="end">End point on unit sphere.</param>
    /// <param name="segments">Number of segments (>= 1).</param>
    /// <returns>Polyline3 representing the great circle arc.</returns>
    public static Polyline3 CreateGreatCircleArc(UnitVector3d start, UnitVector3d end, int segments)
    {
        if (segments < 1)
            segments = 1;

        var points = new Point3[segments + 1];

        for (int i = 0; i <= segments; i++)
        {
            var t = (double)i / segments;
            var point = Slerp(start, end, t);
            points[i] = new Point3(point.X, point.Y, point.Z);
        }

        return new Polyline3(points);
    }

    /// <summary>
    /// Converts latitude/longitude (degrees) to a unit surface point.
    /// </summary>
    public static UnitVector3d LatLonToUnitVector(double latitudeDeg, double longitudeDeg)
    {
        var latRad = latitudeDeg * Math.PI / 180.0;
        var lonRad = longitudeDeg * Math.PI / 180.0;

        var cosLat = Math.Cos(latRad);
        var x = cosLat * Math.Cos(lonRad);
        var y = cosLat * Math.Sin(lonRad);
        var z = Math.Sin(latRad);

        // UnitVector3d.Create validates normalization
        return UnitVector3d.Create(x, y, z);
    }

    /// <summary>
    /// Converts a unit surface point to latitude/longitude (degrees).
    /// </summary>
    /// <returns>(latitude, longitude) in degrees. Longitude in [-180, 180].</returns>
    public static (double LatitudeDeg, double LongitudeDeg) UnitVectorToLatLon(UnitVector3d v)
    {
        var latDeg = Math.Asin(v.Z) * 180.0 / Math.PI;
        var lonDeg = Math.Atan2(v.Y, v.X) * 180.0 / Math.PI;
        return (latDeg, lonDeg);
    }
}


// --- PATH: contracts/Geosphere.Plate.Topology.Contracts/Numerics/SurfacePoint.cs ---
﻿using System;
using System.Runtime.InteropServices;
using MessagePack;

namespace FantaSim.Geosphere.Plate.Topology.Contracts.Numerics;

/// <summary>
/// A point on a spherical body surface, represented as a unit surface normal + optional radius.
/// </summary>
/// <remarks>
/// <para>
/// SurfacePoint is the sphere-native representation of location for truth topology entities.
/// Unlike <see cref="Point2"/> which assumes a planar projection, SurfacePoint is valid
/// anywhere on a sphere (no singularity at poles, no "dateline" wraparound issues).
/// </para>
/// <para>
/// For a unit sphere, the surface point IS the unit vector from the body center.
/// For a body with radius R, the actual 3D position would be <c>Normal * Radius</c>.
/// </para>
/// <para>
/// <b>Sphere-by-default:</b> This type replaces Point2 as the canonical location representation
/// in truth topology. Any 2D chart coordinates (latitude/longitude, map projections) are
/// treated as derived products, not truth.
/// </para>
/// </remarks>
[StructLayout(LayoutKind.Auto)]
[MessagePackObject]
public readonly record struct SurfacePoint(
    [property: Key(0)] UnitVector3d Normal,
    [property: Key(1)] double Radius)
{
    /// <summary>
    /// Creates a SurfacePoint on a unit sphere (radius = 1.0).
    /// </summary>
    public static SurfacePoint UnitSphere(UnitVector3d normal) => new(normal, 1.0);

    /// <summary>
    /// Creates a SurfacePoint from latitude/longitude (degrees) on unit sphere.
    /// </summary>
    /// <param name="latitudeDeg">Latitude in degrees (-90 to 90).</param>
    /// <param name="longitudeDeg">Longitude in degrees (-180 to 180 or 0 to 360).</param>
    public static SurfacePoint FromLatLon(double latitudeDeg, double longitudeDeg)
    {
        var latRad = latitudeDeg * Math.PI / 180.0;
        var lonRad = longitudeDeg * Math.PI / 180.0;

        var cosLat = Math.Cos(latRad);
        var x = cosLat * Math.Cos(lonRad);
        var y = cosLat * Math.Sin(lonRad);
        var z = Math.Sin(latRad);

        // UnitVector3d.Create validates normalization
        return UnitSphere(UnitVector3d.Create(x, y, z));
    }

    /// <summary>
    /// Converts this surface point to a position vector (for compatibility with existing code).
    /// </summary>
    public Vector3d ToPositionVector() => new(
        Normal.X * Radius,
        Normal.Y * Radius,
        Normal.Z * Radius);

    /// <summary>
    /// Converts this surface point to a Point3 (Cartesian body-frame position).
    /// This is the canonical conversion for geometry operations.
    /// </summary>
    public UnifyGeometry.Point3 ToPoint3() => new(
        Normal.X * Radius,
        Normal.Y * Radius,
        Normal.Z * Radius);

    /// <summary>
    /// Creates a local tangent frame at this surface point.
    /// </summary>
    public Frame3 CreateTangentFrame() => Normal.CreateTangentFrame();

    /// <summary>
    /// Great-circle distance to another surface point on the same sphere.
    /// </summary>
    /// <param name="other">The other surface point (must be on same radius sphere).</param>
    /// <returns>Central angle in radians.</returns>
    public double GreatCircleAngleTo(SurfacePoint other)
    {
        return Normal.AngleTo(other.Normal);
    }

    /// <summary>
    /// Great-circle distance to another surface point (arc length).
    /// </summary>
    public double GreatCircleDistanceTo(SurfacePoint other)
    {
        return Radius * GreatCircleAngleTo(other);
    }

    /// <summary>
    /// Spherical interpolation (slerp) to another point on the same sphere.
    /// </summary>
    /// <param name="other">Target point.</param>
    /// <param name="t">Interpolation factor (0 = this, 1 = other).</param>
    public SurfacePoint SlerpTo(SurfacePoint other, double t)
    {
        // Compute angle between the two normals
        var angle = Normal.AngleTo(other.Normal);

        if (angle < 1e-10)
            return this;  // Points are the same

        // slerp formula: (sin((1-t)*angle) * a + sin(t*angle) * b) / sin(angle)
        var sinAngle = Math.Sin(angle);
        var w1 = Math.Sin((1 - t) * angle) / sinAngle;
        var w2 = Math.Sin(t * angle) / sinAngle;

        var nx = w1 * Normal.X + w2 * other.Normal.X;
        var ny = w1 * Normal.Y + w2 * other.Normal.Y;
        var nz = w1 * Normal.Z + w2 * other.Normal.Z;

        // Result should be unit length, but normalize for safety
        var resultNormal = UnitVector3d.FromComponents(nx, ny, nz)!.Value;
        return new SurfacePoint(resultNormal, Radius);
    }

    /// <summary>
    /// Gets latitude in degrees (-90 to 90).
    /// </summary>
    [MessagePack.IgnoreMember]
    public double LatitudeDeg => Math.Asin(Normal.Z) * 180.0 / Math.PI;

    /// <summary>
    /// Gets longitude in degrees (-180 to 180).
    /// </summary>
    [MessagePack.IgnoreMember]
    public double LongitudeDeg
    {
        get
        {
            var lon = Math.Atan2(Normal.Y, Normal.X) * 180.0 / Math.PI;
            return lon > 180 ? lon - 360 : lon;
        }
    }

    public override string ToString() =>
        $"SurfacePoint(Lat={LatitudeDeg:F6}°, Lon={LongitudeDeg:F6}°, R={Radius:G6})";
}


// --- PATH: contracts/Geosphere.Plate.Topology.Contracts/Numerics/UnitVector3d.cs ---
using System;
using System.Runtime.InteropServices;
using MessagePack;

namespace FantaSim.Geosphere.Plate.Topology.Contracts.Numerics;

/// <summary>
/// A validated unit vector on the unit sphere (or body surface).
/// </summary>
/// <remarks>
/// <para>
/// This type represents a direction on a sphere's surface. It is guaranteed to be
/// normalized (length ≈ 1) at construction time. Use this for:
/// </para>
/// <list type="bullet">
///   <item>Surface normals / surface points on unit sphere</item>
///   <item>Rotation axes</item>
///   <item>Direction vectors in 3D space</item>
/// </list>
/// <para>
/// Unlike <see cref="Point3"/> which represents a position, UnitVector3d represents
/// a direction. This distinction prevents "point vs vector" confusion bugs.
/// </para>
/// </remarks>
[StructLayout(LayoutKind.Auto)]
[MessagePackObject]
public readonly record struct UnitVector3d(
    [property: Key(0)] double X,
    [property: Key(1)] double Y,
    [property: Key(2)] double Z)
{
    private const double NormalizationTolerance = 1e-10;

    /// <summary>Unit vector along +X axis.</summary>
    public static UnitVector3d UnitX => new(1, 0, 0);

    /// <summary>Unit vector along +Y axis.</summary>
    public static UnitVector3d UnitY => new(0, 1, 0);

    /// <summary>Unit vector along +Z axis.</summary>
    public static UnitVector3d UnitZ => new(0, 0, 1);

    /// <summary>
    /// Creates a UnitVector3d from components, validating normalization.
    /// </summary>
    /// <exception cref="ArgumentException">If the vector is not unit length within tolerance.</exception>
    public static UnitVector3d Create(double x, double y, double z)
    {
        var len = Math.Sqrt(x * x + y * y + z * z);
        if (Math.Abs(len - 1.0) > NormalizationTolerance)
        {
            throw new ArgumentException(
                $"Vector ({x}, {y}, {z}) is not unit length (length={len}). " +
                "Use FromVector3d() to normalize, or ensure inputs are pre-normalized.",
                nameof(x));
        }
        return new UnitVector3d(x, y, z);
    }

    /// <summary>
    /// Creates a UnitVector3d by normalizing a Vector3d.
    /// Returns null if the vector is zero-length.
    /// </summary>
    public static UnitVector3d? FromVector3d(Vector3d v)
    {
        var len = v.Length();
        if (len < double.Epsilon)
            return null;
        return new UnitVector3d(v.X / len, v.Y / len, v.Z / len);
    }

    /// <summary>
    /// Creates a UnitVector3d by normalizing raw components.
    /// Returns null if the vector is zero-length.
    /// </summary>
    public static UnitVector3d? FromComponents(double x, double y, double z)
    {
        var len = Math.Sqrt(x * x + y * y + z * z);
        if (len < double.Epsilon)
            return null;
        return new UnitVector3d(x / len, y / len, z / len);
    }

    /// <summary>Converts to a free Vector3d.</summary>
    public Vector3d ToVector3d() => new(X, Y, Z);

    /// <summary>Dot product with another unit vector.</summary>
    public double Dot(UnitVector3d other) => X * other.X + Y * other.Y + Z * other.Z;

    /// <summary>Dot product with a free vector.</summary>
    public double Dot(Vector3d v) => X * v.X + Y * v.Y + Z * v.Z;

    /// <summary>Cross product with another unit vector (returns free vector).</summary>
    public Vector3d Cross(UnitVector3d other) => new(
        Y * other.Z - Z * other.Y,
        Z * other.X - X * other.Z,
        X * other.Y - Y * other.X);

    /// <summary>Cross product with a free vector.</summary>
    public Vector3d Cross(Vector3d v) => new(
        Y * v.Z - Z * v.Y,
        Z * v.X - X * v.Z,
        X * v.Y - Y * v.X);

    /// <summary>Angle between this and another unit vector (radians).</summary>
    public double AngleTo(UnitVector3d other)
    {
        var dot = Dot(other);
        // Clamp to [-1, 1] to avoid NaN from floating-point errors
        return Math.Acos(Math.Clamp(dot, -1.0, 1.0));
    }

    /// <summary>
    /// Creates a local tangent frame at this surface point.
    /// Frame has: Up = this vector, North/East = tangent basis.
    /// </summary>
    public Frame3 CreateTangentFrame() => Frame3.CreateFromSurfaceNormal(this);

    public override string ToString() => $"U({X:G9}, {Y:G9}, {Z:G9})";
}


// --- PATH: contracts/Geosphere.Plate.Topology.Contracts/Simulation/IPlateMotionSolver.cs ---
namespace FantaSim.Geosphere.Plate.Topology.Contracts.Simulation;

/// <summary>
/// Solver interface for plate tectonics simulation.
/// Implementations must be stateless and deterministic.
/// </summary>
public interface IPlateMotionSolver : ISolver<PlateMotionInput, PlateMotionResult>
{
    /// <summary>
    /// Calculate plate motions for a single time step.
    /// </summary>
    /// <param name="topology">Current plate mechanics snapshot (immutable).</param>
    /// <param name="dt">Time delta in seconds.</param>
    /// <returns>Motion result containing deltas and events.</returns>
    PlateMotionResult Calculate(PlateMechanicsSnapshot topology, float dt);

    // Explicit interface implementation to satisfy ISolver
    PlateMotionResult ISolver<PlateMotionInput, PlateMotionResult>.Calculate(PlateMotionInput input)
    {
        return Calculate(input.Snapshot, input.TimeDeltaS);
    }
}


// --- PATH: contracts/Geosphere.Plate.Topology.Contracts/Simulation/ISolver.cs ---
namespace FantaSim.Geosphere.Plate.Topology.Contracts.Simulation;

/// <summary>
/// Generic interface for all pure solvers.
/// Implementations must be stateless and deterministic.
/// </summary>
/// <typeparam name="TInput">Immutable input snapshot type.</typeparam>
/// <typeparam name="TOutput">Immutable output result type.</typeparam>
public interface ISolver<in TInput, out TOutput>
{
    /// <summary>
    /// Calculate results for the given input.
    /// </summary>
    /// <param name="input">Immutable input data.</param>
    /// <returns>Computed results.</returns>
    TOutput Calculate(TInput input);

    /// <summary>
    /// Metadata about this solver implementation.
    /// </summary>
    SolverMetadata Metadata { get; }
}


// --- PATH: contracts/Geosphere.Plate.Topology.Contracts/Simulation/PlateMotionInput.cs ---
using System;
using System.Runtime.InteropServices;
using FantaSim.Geosphere.Plate.Topology.Contracts.Entities;
using FantaSim.Geosphere.Plate.Topology.Contracts.Numerics;
using MessagePack;

namespace FantaSim.Geosphere.Plate.Topology.Contracts.Simulation;

public enum PlateType
{
    Oceanic,
    Continental
}

[StructLayout(LayoutKind.Auto)]
[MessagePackObject]
public readonly record struct PlateSnapshot
{
    [Key(0)] public required PlateId PlateId { get; init; }
    [Key(1)] public required Vector3d Position { get; init; }      // Center of mass
    [Key(2)] public required Quaterniond Rotation { get; init; }   // Orientation
    [Key(3)] public required double MassKg { get; init; }
    [Key(4)] public required double AreaM2 { get; init; }
    [Key(5)] public required PlateType Type { get; init; }
}

[StructLayout(LayoutKind.Auto)]
[MessagePackObject]
public readonly record struct BoundarySnapshot
{
    [Key(0)] public required BoundaryId BoundaryId { get; init; }
    [Key(1)] public required PlateId PlateA { get; init; }
    [Key(2)] public required PlateId PlateB { get; init; }
    [Key(3)] public required BoundaryType Type { get; init; }
    [Key(4)] public required PlateId SubductingPlate { get; init; } // If Convergent
    // Geometry would be here, but using simplified representation for now
}

/// <summary>
/// Immutable snapshot of plate topology mechanics for solver input.
/// </summary>
[StructLayout(LayoutKind.Auto)]
[MessagePackObject]
public readonly record struct PlateMechanicsSnapshot
{
    [Key(0)] public required PlateSnapshot[] Plates { get; init; }
    [Key(1)] public required BoundarySnapshot[] Boundaries { get; init; }
    [Key(2)] public required double CurrentTimeS { get; init; }
}

[StructLayout(LayoutKind.Auto)]
[MessagePackObject]
public readonly record struct PlateMotionInput
{
    [Key(0)] public required PlateMechanicsSnapshot Snapshot { get; init; }
    [Key(1)] public required float TimeDeltaS { get; init; }
}


// --- PATH: contracts/Geosphere.Plate.Topology.Contracts/Simulation/PlateMotionResult.cs ---
using System;
using System.Runtime.InteropServices;
using FantaSim.Geosphere.Plate.Topology.Contracts.Entities;
using FantaSim.Geosphere.Plate.Topology.Contracts.Numerics;
using MessagePack;

namespace FantaSim.Geosphere.Plate.Topology.Contracts.Simulation;

[StructLayout(LayoutKind.Auto)]
[MessagePackObject]
public readonly record struct PlateMotion
{
    [Key(0)] public required PlateId PlateId { get; init; }
    [Key(1)] public required Vector3d DeltaPosition { get; init; }
    [Key(2)] public required Quaterniond DeltaRotation { get; init; }
    [Key(3)] public required Vector3d Force { get; init; }
    [Key(4)] public required Vector3d Torque { get; init; }
}

[StructLayout(LayoutKind.Auto)]
[MessagePackObject]
public readonly record struct RiftEvent
{
    [Key(0)] public required BoundaryId BoundaryId { get; init; }
    [Key(1)] public required PlateId PlateA { get; init; }
    [Key(2)] public required PlateId PlateB { get; init; }
}

[StructLayout(LayoutKind.Auto)]
[MessagePackObject]
public readonly record struct CollisionEvent
{
    [Key(0)] public required PlateId PlateA { get; init; }
    [Key(1)] public required PlateId PlateB { get; init; }
    [Key(2)] public required Vector3d Location { get; init; }
}

[StructLayout(LayoutKind.Auto)]
[MessagePackObject]
public readonly record struct ComputationMetrics
{
    [Key(0)] public required double ComputeTimeMs { get; init; }
    [Key(1)] public required int IterationCount { get; init; }
    [Key(2)] public required double ConvergenceError { get; init; }
}

/// <summary>
/// Solver output: computed motions and topology changes.
/// </summary>
[StructLayout(LayoutKind.Auto)]
[MessagePackObject]
public readonly record struct PlateMotionResult
{
    [Key(0)] public required PlateMotion[] PlateMotions { get; init; }
    [Key(1)] public required RiftEvent[] NewRifts { get; init; }
    [Key(2)] public required CollisionEvent[] NewCollisions { get; init; }
    [Key(3)] public required ComputationMetrics Metrics { get; init; }
}


// --- PATH: contracts/Geosphere.Plate.Topology.Contracts/Simulation/SolverMetadata.cs ---
namespace FantaSim.Geosphere.Plate.Topology.Contracts.Simulation;

/// <summary>
/// Metadata about a solver implementation.
/// </summary>
public readonly record struct SolverMetadata
{
    /// <summary>Human-readable name (e.g., "Reference", "SIMD_v2").</summary>
    public required string Name { get; init; }

    /// <summary>Version for tracking changes.</summary>
    public required string Version { get; init; }

    /// <summary>Brief description of the implementation approach.</summary>
    public required string Description { get; init; }

    /// <summary>Expected complexity class (e.g., "O(n²)", "O(n log n)").</summary>
    public required string Complexity { get; init; }
}


// --- PATH: contracts/Geosphere.Plate.Velocity.Contracts/AngularVelocity3d.cs ---
using System.Runtime.InteropServices;
using MessagePack;

namespace FantaSim.Geosphere.Plate.Velocity.Contracts;

/// <summary>
/// Double-precision 3D angular velocity for plate rotation.
/// Represented as axis-angle: direction × angular rate (radians per canonical tick).
/// </summary>
/// <remarks>
/// <para>
/// The vector direction is the rotation axis (right-hand rule).
/// The vector magnitude is the angular rate in radians per tick.
/// </para>
/// <para>
/// Linear velocity at a point p is computed as v = ω × p (cross product).
/// </para>
/// </remarks>
[MessagePackObject]
[StructLayout(LayoutKind.Sequential)]
public readonly record struct AngularVelocity3d(
    [property: Key(0)] double X,
    [property: Key(1)] double Y,
    [property: Key(2)] double Z)
{
    /// <summary>Zero angular velocity (no rotation).</summary>
    public static AngularVelocity3d Zero => new(0, 0, 0);

    /// <summary>Angular rate (magnitude) in radians per tick.</summary>
    public double Rate() => Math.Sqrt(X * X + Y * Y + Z * Z);

    /// <summary>Squared rate (avoids sqrt for comparisons).</summary>
    public double RateSquared() => X * X + Y * Y + Z * Z;

    /// <summary>
    /// Returns the rotation axis as a unit vector.
    /// Returns zero vector if angular velocity is zero.
    /// </summary>
    public (double AxisX, double AxisY, double AxisZ) GetAxis()
    {
        var rate = Rate();
        if (rate < double.Epsilon)
            return (0, 0, 0);
        return (X / rate, Y / rate, Z / rate);
    }

    /// <summary>
    /// Computes linear velocity at a point using v = ω × p.
    /// </summary>
    /// <param name="pointX">X coordinate of the point (body frame).</param>
    /// <param name="pointY">Y coordinate of the point (body frame).</param>
    /// <param name="pointZ">Z coordinate of the point (body frame).</param>
    /// <returns>Linear velocity at the point.</returns>
    public Velocity3d GetLinearVelocityAt(double pointX, double pointY, double pointZ)
    {
        // v = ω × p (cross product)
        return new Velocity3d(
            Y * pointZ - Z * pointY,
            Z * pointX - X * pointZ,
            X * pointY - Y * pointX);
    }

    public static AngularVelocity3d operator +(AngularVelocity3d a, AngularVelocity3d b)
        => new(a.X + b.X, a.Y + b.Y, a.Z + b.Z);

    public static AngularVelocity3d operator -(AngularVelocity3d a, AngularVelocity3d b)
        => new(a.X - b.X, a.Y - b.Y, a.Z - b.Z);

    public static AngularVelocity3d operator -(AngularVelocity3d v)
        => new(-v.X, -v.Y, -v.Z);

    public static AngularVelocity3d operator *(AngularVelocity3d v, double scalar)
        => new(v.X * scalar, v.Y * scalar, v.Z * scalar);

    public static AngularVelocity3d operator *(double scalar, AngularVelocity3d v)
        => new(v.X * scalar, v.Y * scalar, v.Z * scalar);

    public static AngularVelocity3d operator /(AngularVelocity3d v, double scalar)
        => new(v.X / scalar, v.Y / scalar, v.Z / scalar);

    public override string ToString() => $"AngularVelocity3d({X:G6}, {Y:G6}, {Z:G6})";
}


// --- PATH: contracts/Geosphere.Plate.Velocity.Contracts/BoundarySamplingSpec.cs ---
using System.Runtime.InteropServices;

namespace FantaSim.Geosphere.Plate.Velocity.Contracts;

/// <summary>
/// Sampling specification for boundary velocity analysis.
/// </summary>
/// <remarks>
/// <para>
/// Controls how many samples are taken along a boundary and the sampling strategy.
/// </para>
/// </remarks>
[StructLayout(LayoutKind.Auto)]
public record struct BoundarySamplingSpec(
    int SampleCount,
    SamplingMode Mode,
    bool IncludeEndpoints = true
);


// --- PATH: contracts/Geosphere.Plate.Velocity.Contracts/BoundaryVelocityCollection.cs ---
using System.Collections.Immutable;
using System.Runtime.InteropServices;
using MessagePack;
using Plate.TimeDete.Time.Primitives;

namespace FantaSim.Geosphere.Plate.Velocity.Contracts;

/// <summary>
/// Batch output of boundary velocity analysis for all boundaries at a tick (RFC-V2-0034 §10.3).
/// </summary>
[MessagePackObject]
[StructLayout(LayoutKind.Sequential)]
public readonly record struct BoundaryVelocityCollection(
    [property: Key(0)] CanonicalTick Tick,
    [property: Key(1)] ImmutableArray<BoundaryVelocityProfile> Profiles,
    [property: Key(2)] string SolverId
);


// --- PATH: contracts/Geosphere.Plate.Velocity.Contracts/BoundaryVelocityProfile.cs ---
using System.Collections.Immutable;
using System.Runtime.InteropServices;
using MessagePack;
using FantaSim.Geosphere.Plate.Topology.Contracts.Entities;

namespace FantaSim.Geosphere.Plate.Velocity.Contracts;

/// <summary>
/// Per-boundary velocity profile with aggregated statistics (RFC-V2-0034 §10.2).
/// </summary>
[MessagePackObject]
[StructLayout(LayoutKind.Sequential)]
public readonly record struct BoundaryVelocityProfile(
    [property: Key(0)] BoundaryId BoundaryId,
    [property: Key(1)] int SampleCount,
    [property: Key(2)] double MinNormalRate,
    [property: Key(3)] double MaxNormalRate,
    [property: Key(4)] double MeanNormalRate,
    [property: Key(5)] double MeanSlipRate,
    [property: Key(6)] int MinSampleIndex,
    [property: Key(7)] int MaxSampleIndex
);


// --- PATH: contracts/Geosphere.Plate.Velocity.Contracts/BoundaryVelocitySample.cs ---
﻿using System.Runtime.InteropServices;
using MessagePack;
using FantaSim.Geosphere.Plate.Topology.Contracts.Numerics;

namespace FantaSim.Geosphere.Plate.Velocity.Contracts;

/// <summary>
/// Per-sample velocity data for boundary analysis (RFC-V2-0034 §10.1).
/// </summary>
[MessagePackObject]
[StructLayout(LayoutKind.Sequential)]
public readonly record struct BoundaryVelocitySample(
    [property: Key(0)] Vector3d Position,
    [property: Key(1)] Velocity3d RelativeVelocity,
    [property: Key(2)] Vector3d Tangent,
    [property: Key(3)] Vector3d Normal,
    [property: Key(4)] double TangentialRate,
    [property: Key(5)] double NormalRate,
    [property: Key(6)] int SampleIndex
);


// --- PATH: contracts/Geosphere.Plate.Velocity.Contracts/IBoundaryVelocitySolver.cs ---
using Plate.TimeDete.Time.Primitives;
using FantaSim.Geosphere.Plate.Kinematics.Contracts.Derived;
using FantaSim.Geosphere.Plate.Topology.Contracts.Derived;
using FantaSim.Geosphere.Plate.Topology.Contracts.Entities;

namespace FantaSim.Geosphere.Plate.Velocity.Contracts;

/// <summary>
/// Solves boundary velocity analysis for plate boundaries.
/// </summary>
/// <remarks>
/// <para>
/// <b>RFC-V2-0034:</b> Computes relative velocities and rates along plate boundaries,
/// producing per-sample data and per-boundary aggregate statistics.
/// </para>
/// <para>
/// <b>Normal orientation:</b> The normal vector is computed as n₀ = normalize(cross(p, t))
/// where p is the position and t is the tangent. For boundaries where left→right indicates
/// convergence (per boundary metadata), the normal is flipped to ensure positive values
/// indicate convergence and negative values indicate divergence.
/// </para>
/// <para>
/// <b>Determinism:</b> Same inputs MUST produce identical outputs. The AnalyzeAllBoundaries
/// method sorts profiles by BoundaryId.Value for deterministic ordering.
/// </para>
/// <para>
/// <b>Fallback:</b> Returns zero rates when kinematics data is missing for either plate.
/// This matches the fallback policy from RFC-V2-0033.
/// </para>
/// </remarks>
public interface IBoundaryVelocitySolver
{
    /// <summary>
    /// Analyzes a single boundary, producing per-sample velocities and per-boundary aggregates.
    /// </summary>
    /// <param name="boundary">The boundary to analyze.</param>
    /// <param name="sampling">Sampling specification.</param>
    /// <param name="tick">The target simulation time.</param>
    /// <param name="topology">The topology state view.</param>
    /// <param name="kinematics">The kinematics state view.</param>
    /// <returns>Velocity profile with samples and aggregates for the boundary.</returns>
    BoundaryVelocityProfile AnalyzeBoundary(
        Boundary boundary,
        BoundarySamplingSpec sampling,
        CanonicalTick tick,
        IPlateTopologyStateView topology,
        IPlateKinematicsStateView kinematics);

    /// <summary>
    /// Analyzes all boundaries at a tick, producing deterministic ordering by BoundaryId.
    /// </summary>
    /// <param name="boundaries">The boundaries to analyze.</param>
    /// <param name="sampling">Sampling specification.</param>
    /// <param name="tick">The target simulation time.</param>
    /// <param name="topology">The topology state view.</param>
    /// <param name="kinematics">The kinematics state view.</param>
    /// <returns>Collection of velocity profiles sorted by BoundaryId.</returns>
    BoundaryVelocityCollection AnalyzeAllBoundaries(
        IEnumerable<Boundary> boundaries,
        BoundarySamplingSpec sampling,
        CanonicalTick tick,
        IPlateTopologyStateView topology,
        IPlateKinematicsStateView kinematics);
}


// --- PATH: contracts/Geosphere.Plate.Velocity.Contracts/IPlateVelocitySolver.cs ---
using Plate.TimeDete.Time.Primitives;
using FantaSim.Geosphere.Plate.Kinematics.Contracts.Derived;
using FantaSim.Geosphere.Plate.Topology.Contracts.Entities;
using FantaSim.Geosphere.Plate.Topology.Contracts.Numerics;

namespace FantaSim.Geosphere.Plate.Velocity.Contracts;

/// <summary>
/// Computes plate velocities from kinematics truth.
/// </summary>
/// <remarks>
/// <para>
/// <b>RFC-V2-0033:</b> Velocity products are derived outputs computed from kinematics truth.
/// They are recomputable, emit no truth events, and may be cached.
/// </para>
/// <para>
/// <b>Determinism:</b> Same inputs MUST produce identical outputs.
/// Suitable for Solver Lab corpus verification.
/// </para>
/// <para>
/// <b>Fallback:</b> If kinematics data is missing for a plate at the requested tick,
/// implementations MUST return zero velocity (not throw). This matches the reconstruction
/// solver fallback policy (RFC-V2-0024).
/// </para>
/// <para>
/// <b>Point frame semantics:</b> The input point is expected to be in body frame at the
/// target tick (i.e., already reconstructed to that tick). This keeps the velocity solver
/// independent from the reconstruction solver.
/// </para>
/// </remarks>
public interface IPlateVelocitySolver
{
    /// <summary>
    /// Computes the absolute velocity of a point anchored to a plate.
    /// </summary>
    /// <param name="kinematics">The kinematics state view to query rotations from.</param>
    /// <param name="plateId">The plate the point is anchored to.</param>
    /// <param name="point">The position on the sphere (body frame at target tick).</param>
    /// <param name="tick">The target simulation time.</param>
    /// <returns>Velocity vector in body-frame units per tick.</returns>
    /// <remarks>
    /// Returns <see cref="Velocity3d.Zero"/> if kinematics data is missing.
    /// </remarks>
    Velocity3d GetAbsoluteVelocity(
        IPlateKinematicsStateView kinematics,
        PlateId plateId,
        Vector3d point,
        CanonicalTick tick);

    /// <summary>
    /// Computes the velocity of a point on plate A relative to plate B.
    /// </summary>
    /// <param name="kinematics">The kinematics state view to query rotations from.</param>
    /// <param name="plateIdA">The plate the point is anchored to.</param>
    /// <param name="plateIdB">The reference plate.</param>
    /// <param name="point">The position on the sphere (body frame at target tick).</param>
    /// <param name="tick">The target simulation time.</param>
    /// <returns>Relative velocity vector (vA - vB at the same point).</returns>
    /// <remarks>
    /// Returns <see cref="Velocity3d.Zero"/> if kinematics data is missing for either plate.
    /// </remarks>
    Velocity3d GetRelativeVelocity(
        IPlateKinematicsStateView kinematics,
        PlateId plateIdA,
        PlateId plateIdB,
        Vector3d point,
        CanonicalTick tick);

    /// <summary>
    /// Computes the angular velocity of a plate.
    /// </summary>
    /// <param name="kinematics">The kinematics state view to query rotations from.</param>
    /// <param name="plateId">The plate.</param>
    /// <param name="tick">The target simulation time.</param>
    /// <returns>Angular velocity (axis × rate in radians per tick).</returns>
    /// <remarks>
    /// Returns <see cref="AngularVelocity3d.Zero"/> if kinematics data is missing.
    /// </remarks>
    AngularVelocity3d GetAngularVelocity(
        IPlateKinematicsStateView kinematics,
        PlateId plateId,
        CanonicalTick tick);
}


// --- PATH: contracts/Geosphere.Plate.Velocity.Contracts/SamplingMode.cs ---
namespace FantaSim.Geosphere.Plate.Velocity.Contracts;

/// <summary>
/// Sampling mode for boundary velocity analysis.
/// </summary>
public enum SamplingMode
{
    /// <summary>Sample along geodesic arc length on the sphere.</summary>
    ArcLength,

    /// <summary>Sample along straight chords between vertices.</summary>
    ChordLength
}


// --- PATH: contracts/Geosphere.Plate.Velocity.Contracts/Velocity3d.cs ---
﻿using System.Runtime.InteropServices;
using MessagePack;
using FantaSim.Geosphere.Plate.Topology.Contracts.Numerics;

namespace FantaSim.Geosphere.Plate.Velocity.Contracts;

/// <summary>
/// Double-precision 3D velocity vector for plate motion.
/// Units: body-frame distance units per canonical tick.
/// </summary>
/// <remarks>
/// <para>
/// This type represents linear velocity in simulation units.
/// UI layers may convert to display units (e.g., cm/year) for presentation.
/// </para>
/// </remarks>
[MessagePackObject]
[StructLayout(LayoutKind.Sequential)]
public readonly record struct Velocity3d(
    [property: Key(0)] double X,
    [property: Key(1)] double Y,
    [property: Key(2)] double Z)
{
    /// <summary>Zero velocity (stationary).</summary>
    public static Velocity3d Zero => new(0, 0, 0);

    /// <summary>Magnitude (speed) of velocity.</summary>
    public double Magnitude() => Math.Sqrt(X * X + Y * Y + Z * Z);

    /// <summary>Squared magnitude (avoids sqrt for comparisons).</summary>
    public double MagnitudeSquared() => X * X + Y * Y + Z * Z;

    /// <summary>Dot product with a direction vector.</summary>
    public double Dot(Vector3d direction) => X * direction.X + Y * direction.Y + Z * direction.Z;

    public static Velocity3d operator +(Velocity3d a, Velocity3d b)
        => new(a.X + b.X, a.Y + b.Y, a.Z + b.Z);

    public static Velocity3d operator -(Velocity3d a, Velocity3d b)
        => new(a.X - b.X, a.Y - b.Y, a.Z - b.Z);

    public static Velocity3d operator -(Velocity3d v)
        => new(-v.X, -v.Y, -v.Z);

    public static Velocity3d operator *(Velocity3d v, double scalar)
        => new(v.X * scalar, v.Y * scalar, v.Z * scalar);

    public static Velocity3d operator *(double scalar, Velocity3d v)
        => new(v.X * scalar, v.Y * scalar, v.Z * scalar);

    public static Velocity3d operator /(Velocity3d v, double scalar)
        => new(v.X / scalar, v.Y / scalar, v.Z / scalar);

    public override string ToString() => $"Velocity3d({X:G6}, {Y:G6}, {Z:G6})";
}


// --- PATH: contracts/Raster.Contracts/Export/IRasterSequenceExporter.cs ---
namespace FantaSim.Raster.Contracts.Export;

/// <summary>
/// Exports raster sequences to various formats.
/// RFC-V2-0028 §4.
/// </summary>
public interface IRasterSequenceExporter
{
    /// <summary>
    /// Exports a raster sequence according to the specification.
    /// </summary>
    /// <param name="sequence">The raster sequence to export.</param>
    /// <param name="spec">Export specification.</param>
    /// <param name="cancellationToken">Cancellation token.</param>
    Task<RasterExportResult> ExportAsync(
        IRasterSequence sequence,
        RasterExportSpec spec,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// Gets the supported export formats.
    /// </summary>
    IReadOnlyCollection<RasterExportFormat> SupportedFormats { get; }
}

/// <summary>
/// Result of a raster export operation.
/// </summary>
public readonly record struct RasterExportResult(
    bool Success,
    IReadOnlyList<string> OutputFiles,
    IReadOnlyList<RasterExportError> Errors,
    int FramesExported
)
{
    public static RasterExportResult Empty => new(true, Array.Empty<string>(), Array.Empty<RasterExportError>(), 0);

    public static RasterExportResult Failed(params RasterExportError[] errors)
        => new(false, Array.Empty<string>(), errors, 0);

    public static RasterExportResult Succeeded(IReadOnlyList<string> files, int frames)
        => new(true, files, Array.Empty<RasterExportError>(), frames);
}

/// <summary>
/// Error during raster export.
/// </summary>
public readonly record struct RasterExportError(
    string Code,
    string Message,
    string? FilePath = null
)
{
    public static RasterExportError IOError(string message, string? path = null)
        => new("IO_ERROR", message, path);

    public static RasterExportError FormatError(string message, string? path = null)
        => new("FORMAT_ERROR", message, path);

    public static RasterExportError MissingFrame(string message, string? path = null)
        => new("MISSING_FRAME", message, path);

    public static RasterExportError InvalidSpec(string message)
        => new("INVALID_SPEC", message, null);
}


// --- PATH: contracts/Raster.Contracts/Export/RasterExportFormat.cs ---
namespace FantaSim.Raster.Contracts.Export;

/// <summary>
/// Output format for raster sequence exports.
/// RFC-V2-0028 §4.
/// </summary>
public enum RasterExportFormat
{
    /// <summary>GeoTIFF format (.tif)</summary>
    GeoTiff,

    /// <summary>PNG image with world file (.png + .pgw)</summary>
    PngWithWorldFile,

    /// <summary>NetCDF format (.nc)</summary>
    NetCDF,

    /// <summary>Raw binary with header (.bin + .hdr)</summary>
    RawBinary,

    /// <summary>CSV with lat/lon/value columns</summary>
    Csv
}


// --- PATH: contracts/Raster.Contracts/Export/RasterExportSpec.cs ---
using System.Runtime.InteropServices;
using MessagePack;
using Plate.TimeDete.Time.Primitives;

namespace FantaSim.Raster.Contracts.Export;

/// <summary>
/// Specification for exporting a raster sequence over a tick range.
/// RFC-V2-0028 §4.
/// </summary>
[StructLayout(LayoutKind.Auto)]
[MessagePackObject]
public readonly record struct RasterExportSpec(
    [property: Key(0)] string SequenceId,
    [property: Key(1)] CanonicalTick StartTick,
    [property: Key(2)] CanonicalTick EndTick,
    [property: Key(3)] int TickStep,
    [property: Key(4)] RasterExportFormat Format,
    [property: Key(5)] RasterQueryOptions QueryOptions,
    [property: Key(6)] string OutputDirectory,
    [property: Key(7)] string FileNameTemplate
)
{
    /// <summary>
    /// Validates the export specification.
    /// </summary>
    public bool IsValid(out string? error)
    {
        if (string.IsNullOrWhiteSpace(SequenceId))
        {
            error = "SequenceId is required";
            return false;
        }

        if (EndTick < StartTick)
        {
            error = "EndTick must be >= StartTick";
            return false;
        }

        if (TickStep <= 0)
        {
            error = "TickStep must be > 0";
            return false;
        }

        if (string.IsNullOrWhiteSpace(OutputDirectory))
        {
            error = "OutputDirectory is required";
            return false;
        }

        if (string.IsNullOrWhiteSpace(FileNameTemplate))
        {
            error = "FileNameTemplate is required";
            return false;
        }

        error = null;
        return true;
    }

    /// <summary>
    /// Gets the ticks to export based on StartTick, EndTick, and TickStep.
    /// </summary>
    public IEnumerable<CanonicalTick> GetExportTicks()
    {
        for (var tick = StartTick.Value; tick <= EndTick.Value; tick += TickStep)
        {
            yield return new CanonicalTick(tick);
        }
    }

    /// <summary>
    /// Generates the output filename for a specific tick.
    /// Template supports: {tick}, {sequenceId}, {format}
    /// </summary>
    public string GetOutputFileName(CanonicalTick tick)
    {
        var fileName = FileNameTemplate
            .Replace("{tick}", tick.Value.ToString(), StringComparison.Ordinal)
            .Replace("{sequenceId}", SequenceId, StringComparison.Ordinal)
            .Replace("{format}", Format.ToString().ToLowerInvariant(), StringComparison.Ordinal);

        return fileName;
    }
}


// --- PATH: contracts/Raster.Contracts/IRasterFrame.cs ---
using Plate.TimeDete.Time.Primitives;

namespace FantaSim.Raster.Contracts;

/// <summary>
/// A single raster frame at a specific tick.
/// RFC-V2-0028 §2.
/// </summary>
public interface IRasterFrame
{
    /// <summary>
    /// The tick this raster frame represents.
    /// </summary>
    CanonicalTick Tick { get; }

    /// <summary>
    /// Width of the raster in pixels (columns).
    /// </summary>
    int Width { get; }

    /// <summary>
    /// Height of the raster in pixels (rows).
    /// </summary>
    int Height { get; }

    /// <summary>
    /// Geographic bounds of this raster frame.
    /// </summary>
    RasterBounds Bounds { get; }

    /// <summary>
    /// Data type of cell values.
    /// </summary>
    RasterDataType DataType { get; }

    /// <summary>
    /// No-data value (null if not specified).
    /// </summary>
    double? NoDataValue { get; }

    /// <summary>
    /// Gets the raw pixel data as a read-only span of bytes.
    /// The data is row-major order (row by row, left to right).
    /// </summary>
    ReadOnlySpan<byte> GetRawData();

    /// <summary>
    /// Gets the value at a specific cell as a double.
    /// Returns null if the cell contains the no-data value.
    /// </summary>
    /// <param name="row">Row index (0-based, top to bottom).</param>
    /// <param name="col">Column index (0-based, left to right).</param>
    double? GetValue(int row, int col);

    /// <summary>
    /// Gets the value at a specific geographic coordinate.
    /// Returns null if out of bounds or no-data.
    /// Uses bilinear interpolation within the cell.
    /// </summary>
    /// <param name="longitude">Longitude in degrees.</param>
    /// <param name="latitude">Latitude in degrees.</param>
    double? GetValueAt(double longitude, double latitude);
}


// --- PATH: contracts/Raster.Contracts/IRasterSequence.cs ---
using System.Collections.Immutable;
using Plate.TimeDete.Time.Primitives;

namespace FantaSim.Raster.Contracts;

/// <summary>
/// Time-dependent raster sequence queryable by tick.
/// RFC-V2-0028 ¡±2.
/// </summary>
public interface IRasterSequence
{
    /// <summary>
    /// Unique identifier for this raster sequence.
    /// </summary>
    string SequenceId { get; }

    /// <summary>
    /// Human-readable name/description.
    /// </summary>
    string DisplayName { get; }

    /// <summary>
    /// All available ticks in this sequence (sorted ascending).
    /// </summary>
    ImmutableArray<CanonicalTick> AvailableTicks { get; }

    /// <summary>
    /// Minimum tick available.
    /// </summary>
    CanonicalTick MinTick => AvailableTicks.IsDefaultOrEmpty ? CanonicalTick.Genesis : AvailableTicks[0];

    /// <summary>
    /// Maximum tick available.
    /// </summary>
    CanonicalTick MaxTick => AvailableTicks.IsDefaultOrEmpty ? CanonicalTick.MaxValue : AvailableTicks[AvailableTicks.Length - 1];

    /// <summary>
    /// Gets the raster frame at a specific tick.
    /// Returns null if no frame exists at exactly this tick.
    /// </summary>
    /// <param name="tick">The target tick.</param>
    IRasterFrame? GetFrameAt(CanonicalTick tick);

    /// <summary>
    /// Queries the sequence for a raster at the target tick.
    /// Per RFC-V2-0028 ¡±3.1, selects the nearest frame at or before the target tick
    /// when interpolation is disabled.
    /// </summary>
    /// <param name="tick">The target tick.</param>
    /// <param name="options">Query options (interpolation, etc.).</param>
    RasterQueryResult QueryAt(CanonicalTick tick, RasterQueryOptions? options = null);

    /// <summary>
    /// Gets all frames in the specified tick range (inclusive).
    /// </summary>
    /// <param name="startTick">Start tick (inclusive).</param>
    /// <param name="endTick">End tick (inclusive).</param>
    IEnumerable<IRasterFrame> GetFramesInRange(CanonicalTick startTick, CanonicalTick endTick);

    /// <summary>
    /// Common raster metadata (consistent across all frames).
    /// </summary>
    RasterMetadata Metadata { get; }
}


// --- PATH: contracts/Raster.Contracts/InterpolationMethod.cs ---
namespace FantaSim.Raster.Contracts;

/// <summary>
/// Interpolation method for deriving raster values between frames.
/// RFC-V2-0028 §3.1.
/// </summary>
public enum InterpolationMethod
{
    /// <summary>
    /// Nearest neighbor - use the closest frame without interpolation.
    /// Default behavior per RFC-V2-0028.
    /// </summary>
    NearestNeighbor,

    /// <summary>
    /// Linear interpolation between two frames.
    /// </summary>
    Linear,

    /// <summary>
    /// Cubic interpolation for smoother transitions.
    /// </summary>
    Cubic
}


// --- PATH: contracts/Raster.Contracts/Loading/IRasterSequenceLoader.cs ---
using FantaSim.Geosphere.Plate.Datasets.Contracts.Manifest;
using FantaSim.Geosphere.Plate.Datasets.Contracts.Loading;

namespace FantaSim.Raster.Contracts.Loading;

/// <summary>
/// Loads raster sequences from dataset assets.
/// RFC-V2-0028 §2.
/// </summary>
public interface IRasterSequenceLoader
{
    /// <summary>
    /// Checks if this loader can handle the given asset format.
    /// </summary>
    bool CanLoad(string format);

    /// <summary>
    /// Loads a raster sequence from a dataset asset.
    /// </summary>
    /// <param name="asset">The raster sequence asset from the manifest.</param>
    /// <param name="dataset">The parent dataset for resolving paths.</param>
    /// <param name="cancellationToken">Cancellation token.</param>
    Task<IRasterSequence> LoadAsync(
        RasterSequenceAsset asset,
        IPlatesDataset dataset,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// Supported file formats (e.g., "geotiff", "netcdf", "asc").
    /// </summary>
    IReadOnlyCollection<string> SupportedFormats { get; }
}

/// <summary>
/// Registry for raster sequence loaders.
/// </summary>
public interface IRasterSequenceLoaderRegistry
{
    /// <summary>
    /// Registers a loader for specific formats.
    /// </summary>
    void Register(IRasterSequenceLoader loader);

    /// <summary>
    /// Gets the appropriate loader for a format.
    /// </summary>
    /// <returns>The loader, or null if no loader supports the format.</returns>
    IRasterSequenceLoader? GetLoader(string format);
}


// --- PATH: contracts/Raster.Contracts/Masking/IMaskedRasterSequence.cs ---
namespace FantaSim.Raster.Contracts.Masking;

/// <summary>
/// A raster sequence that applies masking/cookie-cutting to frames.
/// RFC-V2-0028 ¡±3.3 - Derived transform for masking rasters.
/// </summary>
/// <remarks>
/// This interface is domain-agnostic. It does not reference plate polygons or topology.
/// For plate-specific masked sequences, use the composition layer
/// (Geosphere.Plate.Raster.Masking plugin).
/// </remarks>
public interface IMaskedRasterSequence : IRasterSequence
{
    /// <summary>
    /// The underlying (unmasked) raster sequence.
    /// </summary>
    IRasterSequence SourceSequence { get; }

    /// <summary>
    /// The mask applied to each frame.
    /// </summary>
    IRasterMask Mask { get; }
}

/// <summary>
/// Generic factory for creating masked raster sequences.
/// Domain-agnostic - does not reference plates/topology.
/// </summary>
/// <remarks>
/// For plate-specific masking, use <c>IPlateRasterMaskFactory</c> from the
/// Geosphere.Plate.Raster.Masking plugin.
/// </remarks>
public interface IRasterMaskFactory
{
    /// <summary>
    /// Creates a masked sequence using geographic bounds.
    /// </summary>
    IMaskedRasterSequence CreateBoundsMaskedSequence(
        IRasterSequence source,
        RasterBounds bounds);

    /// <summary>
    /// Creates a masked sequence using a custom mask.
    /// </summary>
    IMaskedRasterSequence CreateCustomMaskedSequence(
        IRasterSequence source,
        IRasterMask mask,
        double noDataValue = double.NaN);
}


// --- PATH: contracts/Raster.Contracts/Masking/IRasterMask.cs ---
using System.Runtime.InteropServices;
using MessagePack;

namespace FantaSim.Raster.Contracts.Masking;

/// <summary>
/// Current schema version for mask specifications.
/// Increment when the serialization format changes in a breaking way.
/// </summary>
public static class MaskSpecVersions
{
    /// <summary>
    /// Version 1: Initial schema with Bounds and IncludeInterior.
    /// </summary>
    public const int BoundsMaskSpecV1 = 1;
}

/// <summary>
/// A mask that can be applied to a raster frame.
/// RFC-V2-0028 ��3.3 - Cookie-cutting / masking.
/// </summary>
/// <remarks>
/// This interface is domain-agnostic. Plate-specific masking implementations
/// live in the composition layer (Geosphere.Plate.Raster.Masking plugin).
/// </remarks>
public interface IRasterMask
{
    /// <summary>
    /// Applies the mask to a raster frame, returning the masked data.
    /// Pixels outside the mask are set to the no-data value.
    /// </summary>
    /// <param name="sourceFrame">The source raster frame to mask.</param>
    /// <param name="noDataValue">Value to use for masked-out pixels.</param>
    IRasterFrame ApplyMask(IRasterFrame sourceFrame, double noDataValue);

    /// <summary>
    /// Checks if a point is inside the mask region.
    /// </summary>
    bool Contains(double longitude, double latitude);
}

/// <summary>
/// Mask specification using a geographic bounds rectangle.
/// Domain-agnostic - suitable for any coordinate system.
/// </summary>
/// <remarks>
/// <para>
/// This is a pure data record with no behavior - safe for serialization and caching.
/// </para>
/// <para>
/// SchemaVersion is included to support cache invalidation when the spec format evolves.
/// When computing cache keys, include SchemaVersion in the params hash.
/// </para>
/// </remarks>
[StructLayout(LayoutKind.Auto)]
[MessagePackObject]
public readonly record struct BoundsMaskSpec(
    [property: Key(0)] int SchemaVersion,
    [property: Key(1)] RasterBounds Bounds,
    [property: Key(2)] bool IncludeInterior
)
{
    /// <summary>
    /// Mask that includes points inside the bounds.
    /// </summary>
    public static BoundsMaskSpec Include(RasterBounds bounds)
        => new(MaskSpecVersions.BoundsMaskSpecV1, bounds, true);

    /// <summary>
    /// Mask that excludes points inside the bounds.
    /// </summary>
    public static BoundsMaskSpec Exclude(RasterBounds bounds)
        => new(MaskSpecVersions.BoundsMaskSpecV1, bounds, false);
}


// --- PATH: contracts/Raster.Contracts/Masking/ITickBoundRasterMaskFactory.cs ---
using Plate.TimeDete.Time.Primitives;

namespace FantaSim.Raster.Contracts.Masking;

/// <summary>
/// Factory that creates tick-specific raster masks.
/// This is the preferred pattern for time-varying masks (e.g., plate polygons that change over time).
/// RFC-V2-0028 ¡±3.3.
/// </summary>
/// <remarks>
/// <para>
/// Use this interface when the mask geometry depends on the tick (e.g., reconstructed plate polygons).
/// The factory encapsulates the logic for obtaining tick-appropriate geometry, keeping callers simple.
/// </para>
/// <para>
/// For static masks (bounds, fixed regions), use <see cref="IRasterMask"/> directly.
/// </para>
/// </remarks>
public interface ITickBoundRasterMaskFactory
{
    /// <summary>
    /// Creates a mask for the specified tick.
    /// </summary>
    /// <param name="tick">The tick for which to create the mask.</param>
    /// <returns>A mask appropriate for the given tick.</returns>
    IRasterMask CreateMask(CanonicalTick tick);
}


// --- PATH: contracts/Raster.Contracts/RasterBounds.cs ---
using System.Runtime.InteropServices;
using MessagePack;
using UnifyGeometry;

namespace FantaSim.Raster.Contracts;

/// <summary>
/// Geographic bounds of a raster dataset.
/// </summary>
[StructLayout(LayoutKind.Auto)]
[MessagePackObject]
public readonly record struct RasterBounds(
    [property: Key(0)] double MinLongitude,
    [property: Key(1)] double MaxLongitude,
    [property: Key(2)] double MinLatitude,
    [property: Key(3)] double MaxLatitude
)
{
    /// <summary>
    /// Width of the bounds in degrees.
    /// </summary>
    [IgnoreMember]
    public double Width => MaxLongitude - MinLongitude;

    /// <summary>
    /// Height of the bounds in degrees.
    /// </summary>
    [IgnoreMember]
    public double Height => MaxLatitude - MinLatitude;

    /// <summary>
    /// Checks if a point is within these bounds.
    /// </summary>
    public bool Contains(double longitude, double latitude)
        => longitude >= MinLongitude && longitude <= MaxLongitude
        && latitude >= MinLatitude && latitude <= MaxLatitude;

    /// <summary>
    /// Checks if a point is within these bounds.
    /// </summary>
    public bool Contains(Point2 point)
        => Contains(point.X, point.Y);

    /// <summary>
    /// Global bounds (-180 to 180, -90 to 90).
    /// </summary>
    public static RasterBounds Global => new(-180.0, 180.0, -90.0, 90.0);
}


// --- PATH: contracts/Raster.Contracts/RasterDataType.cs ---
namespace FantaSim.Raster.Contracts;

/// <summary>
/// Data type of raster cell values.
/// RFC-V2-0028 §3.1.
/// </summary>
public enum RasterDataType
{
    /// <summary>8-bit unsigned integer.</summary>
    UInt8,

    /// <summary>16-bit unsigned integer.</summary>
    UInt16,

    /// <summary>32-bit unsigned integer.</summary>
    UInt32,

    /// <summary>8-bit signed integer.</summary>
    Int8,

    /// <summary>16-bit signed integer.</summary>
    Int16,

    /// <summary>32-bit signed integer.</summary>
    Int32,

    /// <summary>32-bit IEEE float.</summary>
    Float32,

    /// <summary>64-bit IEEE double.</summary>
    Float64
}


// --- PATH: contracts/Raster.Contracts/RasterMetadata.cs ---
using System.Runtime.InteropServices;
using MessagePack;

namespace FantaSim.Raster.Contracts;

/// <summary>
/// Metadata for a raster sequence (consistent across all frames).
/// </summary>
[StructLayout(LayoutKind.Auto)]
[MessagePackObject]
public readonly record struct RasterMetadata(
    [property: Key(0)] int Width,
    [property: Key(1)] int Height,
    [property: Key(2)] RasterBounds Bounds,
    [property: Key(3)] RasterDataType DataType,
    [property: Key(4)] double? NoDataValue,
    [property: Key(5)] string? CoordinateSystem,
    [property: Key(6)] string? Units
)
{
    /// <summary>
    /// Cell width in degrees.
    /// </summary>
    [IgnoreMember]
    public double CellWidth => Bounds.Width / Width;

    /// <summary>
    /// Cell height in degrees.
    /// </summary>
    [IgnoreMember]
    public double CellHeight => Bounds.Height / Height;

    /// <summary>
    /// Total number of cells.
    /// </summary>
    [IgnoreMember]
    public int CellCount => Width * Height;

    /// <summary>
    /// Size of each cell in bytes.
    /// </summary>
    [IgnoreMember]
    public int BytesPerCell => DataType switch
    {
        RasterDataType.UInt8 or RasterDataType.Int8 => 1,
        RasterDataType.UInt16 or RasterDataType.Int16 => 2,
        RasterDataType.UInt32 or RasterDataType.Int32 or RasterDataType.Float32 => 4,
        RasterDataType.Float64 => 8,
        _ => 4
    };

    /// <summary>
    /// Total size of raster data in bytes.
    /// </summary>
    [IgnoreMember]
    public int DataSizeBytes => CellCount * BytesPerCell;
}


// --- PATH: contracts/Raster.Contracts/RasterQueryOptions.cs ---
using System.Runtime.InteropServices;
using MessagePack;

namespace FantaSim.Raster.Contracts;

/// <summary>
/// Options for raster sequence queries.
/// RFC-V2-0028 §3.1.
/// </summary>
[StructLayout(LayoutKind.Auto)]
[MessagePackObject]
public readonly record struct RasterQueryOptions(
    [property: Key(0)] InterpolationMethod Interpolation,
    [property: Key(1)] RasterBounds? ClipBounds,
    [property: Key(2)] double? NoDataValue
)
{
    /// <summary>
    /// Default options: nearest neighbor, no clipping, use raster's no-data value.
    /// </summary>
    public static RasterQueryOptions Default => new(
        InterpolationMethod.NearestNeighbor,
        null,
        null
    );

    /// <summary>
    /// Creates options with linear interpolation enabled.
    /// </summary>
    public static RasterQueryOptions WithLinearInterpolation(RasterBounds? clipBounds = null)
        => new(InterpolationMethod.Linear, clipBounds, null);

    /// <summary>
    /// Creates options with nearest neighbor (no interpolation).
    /// </summary>
    public static RasterQueryOptions WithNearestNeighbor(RasterBounds? clipBounds = null)
        => new(InterpolationMethod.NearestNeighbor, clipBounds, null);
}


// --- PATH: contracts/Raster.Contracts/RasterQueryResult.cs ---
using System.Runtime.InteropServices;
using MessagePack;
using Plate.TimeDete.Time.Primitives;

namespace FantaSim.Raster.Contracts;

/// <summary>
/// Result of a raster sequence query at a specific tick.
/// RFC-V2-0028 §3.1.
/// </summary>
[StructLayout(LayoutKind.Auto)]
[MessagePackObject]
public readonly record struct RasterQueryResult(
    [property: Key(0)] CanonicalTick TargetTick,
    [property: Key(1)] CanonicalTick? SourceFrameTick,
    [property: Key(2)] bool IsInterpolated,
    [property: Key(3)] double? InterpolationWeight,
    [property: Key(4)] RasterFrameData? FrameData
)
{
    /// <summary>
    /// True if a valid result was found.
    /// </summary>
    [IgnoreMember]
    public bool HasData => FrameData.HasValue;

    /// <summary>
    /// Creates a result for an exact frame match (no interpolation).
    /// </summary>
    public static RasterQueryResult Exact(CanonicalTick tick, RasterFrameData data)
        => new(tick, tick, false, null, data);

    /// <summary>
    /// Creates a result for an interpolated value between two frames.
    /// </summary>
    public static RasterQueryResult Interpolated(
        CanonicalTick targetTick,
        CanonicalTick sourceFrameTick,
        double weight,
        RasterFrameData data)
        => new(targetTick, sourceFrameTick, true, weight, data);

    /// <summary>
    /// Creates a "not found" result.
    /// </summary>
    public static RasterQueryResult NotFound(CanonicalTick targetTick)
        => new(targetTick, null, false, null, null);
}

/// <summary>
/// Serializable raster frame data returned from queries.
/// </summary>
[StructLayout(LayoutKind.Auto)]
[MessagePackObject]
public readonly record struct RasterFrameData(
    [property: Key(0)] int Width,
    [property: Key(1)] int Height,
    [property: Key(2)] RasterBounds Bounds,
    [property: Key(3)] RasterDataType DataType,
    [property: Key(4)] double? NoDataValue,
    [property: Key(5)] byte[] RawData
);


// --- PATH: contracts/Raster.Contracts/Rendering/IRasterPalette.cs ---
namespace FantaSim.Raster.Contracts.Rendering;

/// <summary>
/// Defines a color palette for raster visualization.
/// Maps raster values to colors.
/// RFC-V2-0028 §3.2 - Styling.
/// </summary>
public interface IRasterPalette
{
    /// <summary>
    /// Gets the palette name.
    /// </summary>
    string Name { get; }

    /// <summary>
    /// Gets a color for a given raster value.
    /// </summary>
    /// <param name="value">The raster value to map.</param>
    /// <returns>The color as ARGB (Alpha, Red, Green, Blue).</returns>
    uint GetColor(double value);

    /// <summary>
    /// Gets a color for a normalized value (0-1).
    /// </summary>
    /// <param name="normalizedValue">The normalized value (0-1).</param>
    /// <returns>The color as ARGB (Alpha, Red, Green, Blue).</returns>
    uint GetColorForNormalized(double normalizedValue);

    /// <summary>
    /// Gets the color for no-data values.
    /// </summary>
    uint NoDataColor { get; }

    /// <summary>
    /// Whether the palette supports continuous value mapping.
    /// </summary>
    bool IsContinuous { get; }
}

/// <summary>
/// Predefined palette types.
/// </summary>
public static class RasterPalettes
{
    /// <summary>
    /// Traditional age grid palette (blue to red).
    /// </summary>
    public static readonly IRasterPalette AgeGrid = new AgeGridPalette();

    /// <summary>
    /// Elevation palette (blue to white to brown).
    /// </summary>
    public static readonly IRasterPalette Elevation = new ElevationPalette();

    /// <summary>
    /// Grayscale palette.
    /// </summary>
    public static readonly IRasterPalette Grayscale = new GrayscalePalette();

    /// <summary>
    /// Viridis palette (perceptually uniform).
    /// </summary>
    public static readonly IRasterPalette Viridis = new ViridisPalette();

    private sealed class AgeGridPalette : IRasterPalette
    {
        public string Name => "AgeGrid";
        public uint NoDataColor => 0xFF000000; // Black with full alpha

        public bool IsContinuous => true;

        public uint GetColor(double value)
        {
            // Map value to 0-1 range (assuming 0-200 Ma for age grids)
            var normalized = Math.Clamp(value / 200.0, 0.0, 1.0);
            return GetColorForNormalized(normalized);
        }

        public uint GetColorForNormalized(double normalized)
        {
            // Blue (young) to Red (old) gradient
            var n = Math.Clamp(normalized, 0.0, 1.0);
            var r = (byte)(n * 255);
            var g = (byte)(0);
            var b = (byte)((1 - n) * 255);
            return (uint)((255 << 24) | (r << 16) | (g << 8) | b);
        }
    }

    private sealed class ElevationPalette : IRasterPalette
    {
        public string Name => "Elevation";
        public uint NoDataColor => 0xFF00FF00; // Green with full alpha

        public bool IsContinuous => true;

        public uint GetColor(double value)
        {
            // Map value to 0-1 range (assuming -11000 to 8848 meters)
            var normalized = Math.Clamp((value + 11000) / 19848.0, 0.0, 1.0);
            return GetColorForNormalized(normalized);
        }

        public uint GetColorForNormalized(double normalized)
        {
            var n = Math.Clamp(normalized, 0.0, 1.0);
            byte r, g, b;

            if (n < 0.5)
            {
                // Blue to white (ocean)
                var t = n * 2;
                r = g = b = (byte)(t * 255);
            }
            else
            {
                // White to brown (land)
                var t = (n - 0.5) * 2;
                r = (byte)(139 + (255 - 139) * (1 - t));
                g = (byte)(69 + (255 - 69) * (1 - t));
                b = (byte)(19 + (255 - 19) * (1 - t));
            }

            return (uint)((255 << 24) | (r << 16) | (g << 8) | b);
        }
    }

    private sealed class GrayscalePalette : IRasterPalette
    {
        public string Name => "Grayscale";
        public uint NoDataColor => 0xFF000000; // Black with full alpha

        public bool IsContinuous => true;

        public uint GetColor(double value)
        {
            var normalized = Math.Clamp(value, 0.0, 1.0);
            return GetColorForNormalized(normalized);
        }

        public uint GetColorForNormalized(double normalized)
        {
            var n = Math.Clamp(normalized, 0.0, 1.0);
            var gray = (byte)(n * 255);
            return (uint)((255 << 24) | (gray << 16) | (gray << 8) | gray);
        }
    }

    private sealed class ViridisPalette : IRasterPalette
    {
        public string Name => "Viridis";
        public uint NoDataColor => 0xFF000000; // Black with full alpha

        public bool IsContinuous => true;

        public uint GetColor(double value)
        {
            var normalized = Math.Clamp(value, 0.0, 1.0);
            return GetColorForNormalized(normalized);
        }

        public uint GetColorForNormalized(double normalized)
        {
            // Simplified viridis approximation
            var n = Math.Clamp(normalized, 0.0, 1.0);
            byte r, g, b;

            if (n < 0.25)
            {
                var t = n * 4;
                r = (byte)(68 + (33 - 68) * t);
                g = (byte)(1 + (144 - 1) * t);
                b = (byte)(84 + (140 - 84) * t);
            }
            else if (n < 0.5)
            {
                var t = (n - 0.25) * 4;
                r = (byte)(33 + (59 - 33) * t);
                g = (byte)(144 + (82 - 144) * t);
                b = (byte)(140 + (81 - 140) * t);
            }
            else if (n < 0.75)
            {
                var t = (n - 0.5) * 4;
                r = (byte)(59 + (253 - 59) * t);
                g = (byte)(82 + (231 - 82) * t);
                b = (byte)(81 + (37 - 81) * t);
            }
            else
            {
                var t = (n - 0.75) * 4;
                r = (byte)(253 + (253 - 253) * t);
                g = (byte)(231 + (191 - 231) * t);
                b = (byte)(37 + (111 - 37) * t);
            }

            return (uint)((255 << 24) | (r << 16) | (g << 8) | b);
        }
    }
}


// --- PATH: contracts/Raster.Contracts/Rendering/IRasterSequenceRenderer.cs ---
using Plate.TimeDete.Time.Primitives;

namespace FantaSim.Raster.Contracts.Rendering;

/// <summary>
/// Renders raster sequences for visualization.
/// Integrates with the rendering pipeline for map/cartography layers.
/// RFC-V2-0028 compliant.
/// </summary>
public interface IRasterSequenceRenderer
{
    /// <summary>
    /// Renders a raster frame at the specified tick.
    /// </summary>
    /// <param name="sequence">The raster sequence to render.</param>
    /// <param name="tick">The tick to render at.</param>
    /// <param name="options">Rendering options.</param>
    /// <param name="cancellationToken">Cancellation token.</param>
    /// <returns>The rendered image data.</returns>
    Task<RasterRenderResult> RenderAsync(
        IRasterSequence sequence,
        CanonicalTick tick,
        RasterRenderOptions? options = null,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// Renders a specific frame.
    /// </summary>
    /// <param name="frame">The frame to render.</param>
    /// <param name="options">Rendering options.</param>
    /// <param name="cancellationToken">Cancellation token.</param>
    /// <returns>The rendered image data.</returns>
    Task<RasterRenderResult> RenderFrameAsync(
        IRasterFrame frame,
        RasterRenderOptions? options = null,
        CancellationToken cancellationToken = default);
}

/// <summary>
/// Result of a raster render operation.
/// </summary>
public readonly record struct RasterRenderResult(
    int Width,
    int Height,
    byte[] ImageData,
    string Format,
    RasterRenderMetadata Metadata
)
{
    /// <summary>
    /// Creates a failed render result.
    /// </summary>
    public static RasterRenderResult Failed(string error)
        => new(0, 0, Array.Empty<byte>(), "none", new RasterRenderMetadata(error));
}

/// <summary>
/// Metadata about a render operation.
/// </summary>
public readonly record struct RasterRenderMetadata(
    string? ErrorMessage = null,
    int? FrameIndex = null,
    double? RenderTimeMs = null
);

/// <summary>
/// Options for rendering raster sequences.
/// RFC-V2-0028 §3.2 - Styling.
/// </summary>
public class RasterRenderOptions
{
    /// <summary>
    /// Default render options.
    /// </summary>
    public static readonly RasterRenderOptions Default = new();

    /// <summary>
    /// Color palette to use for rendering.
    /// </summary>
    public IRasterPalette? Palette { get; set; }

    /// <summary>
    /// Opacity (0.0 to 1.0).
    /// </summary>
    public double Opacity { get; set; } = 1.0;

    /// <summary>
    /// Minimum value for color mapping (auto if null).
    /// </summary>
    public double? MinValue { get; set; }

    /// <summary>
    /// Maximum value for color mapping (auto if null).
    /// </summary>
    public double? MaxValue { get; set; }

    /// <summary>
    /// Output image format (e.g., "png", "jpeg", "webp").
    /// </summary>
    public string OutputFormat { get; set; } = "png";

    /// <summary>
    /// Whether to interpolate between pixels.
    /// </summary>
    public bool Interpolate { get; set; } = true;

    /// <summary>
    /// Whether to apply anti-aliasing.
    /// </summary>
    public bool AntiAlias { get; set; } = true;

    /// <summary>
    /// Custom color for no-data values (ARGB format).
    /// </summary>
    public uint? NoDataColor { get; set; }

    /// <summary>
    /// Creates a copy of this options instance.
    /// </summary>
    public RasterRenderOptions Clone()
    {
        return new RasterRenderOptions
        {
            Palette = Palette,
            Opacity = Opacity,
            MinValue = MinValue,
            MaxValue = MaxValue,
            OutputFormat = OutputFormat,
            Interpolate = Interpolate,
            AntiAlias = AntiAlias,
            NoDataColor = NoDataColor
        };
    }
}


// --- PATH: contracts/Space.Stellar.Contracts/Constants/AstronomicalConstants.cs ---
namespace FantaSim.Space.Stellar.Contracts.Constants;

public static class AstronomicalConstants
{
    // Distance
    public const double AU_Meters = 1.495978707e11;
    public const double LightYear_Meters = 9.4607e15;
    public const double Parsec_Meters = 3.0857e16;

    // Mass
    public const double SolarMass_Kg = 1.98892e30;
    public const double EarthMass_Kg = 5.9722e24;
    public const double JupiterMass_Kg = 1.898e27;
    public const double LunarMass_Kg = 7.342e22;

    // Radius
    public const double SolarRadius_M = 6.9634e8;
    public const double EarthRadius_M = 6.371e6;
    public const double JupiterRadius_M = 6.9911e7;

    // Energy
    public const double SolarLuminosity_W = 3.828e26;
    public const double SolarConstant_WPerM2 = 1361.0; // At 1 AU

    // Time
    public const double SecondsPerMinute = 60.0;
    public const double SecondsPerHour = 3600.0;
    public const double SecondsPerDay = 86400.0;
    public const double SecondsPerYear = 31557600.0; // Julian year

    // Angles
    public const double DegreesToRadians = Math.PI / 180.0;
    public const double RadiansToDegrees = 180.0 / Math.PI;
}


// --- PATH: contracts/Space.Stellar.Contracts/Entities/BodyType.cs ---
namespace FantaSim.Space.Stellar.Contracts.Entities;

public enum BodyType
{
    Barycenter,
    Star,
    Planet,
    DwarfPlanet,
    Moon,
    AsteroidBelt,
    Comet,
}


// --- PATH: contracts/Space.Stellar.Contracts/Entities/IBodyProperties.cs ---
namespace FantaSim.Space.Stellar.Contracts.Entities;

public interface IBodyProperties
{
    /// <summary>Mass in kilograms (SI unit).</summary>
    double MassKg { get; }
}


// --- PATH: contracts/Space.Stellar.Contracts/Entities/MoonProperties.cs ---
using System.Runtime.InteropServices;
using UnifySerialization.Abstractions;

namespace FantaSim.Space.Stellar.Contracts.Entities;

[StructLayout(LayoutKind.Auto)]
[UnifyModel]
public readonly record struct MoonProperties(
    [property: UnifyProperty(0)] double MassKg,
    [property: UnifyProperty(1)] double RadiusM,
    [property: UnifyProperty(2)] bool TidallyLocked,
    [property: UnifyProperty(3)] double Albedo
) : IBodyProperties;


// --- PATH: contracts/Space.Stellar.Contracts/Entities/PlanetClass.cs ---
namespace FantaSim.Space.Stellar.Contracts.Entities;

public enum PlanetClass
{
    Terrestrial,
    SuperEarth,
    IceGiant,
    GasGiant,
    HotJupiter,
    Dwarf,
}


// --- PATH: contracts/Space.Stellar.Contracts/Entities/PlanetProperties.cs ---
using System.Runtime.InteropServices;
using UnifySerialization.Abstractions;

namespace FantaSim.Space.Stellar.Contracts.Entities;

[StructLayout(LayoutKind.Auto)]
[UnifyModel]
public readonly record struct PlanetProperties(
    [property: UnifyProperty(0)] double MassKg,
    [property: UnifyProperty(1)] double EquatorialRadiusM,
    [property: UnifyProperty(2)] double PolarRadiusM,
    [property: UnifyProperty(3)] double ObliquityRad,
    [property: UnifyProperty(4)] double RotationPeriodS,
    [property: UnifyProperty(5)] bool ProgradeRotation,
    [property: UnifyProperty(6)] double BondAlbedo,
    [property: UnifyProperty(7)] PlanetClass Class
) : IBodyProperties;


// --- PATH: contracts/Space.Stellar.Contracts/Entities/StarProperties.cs ---
using System.Runtime.InteropServices;
using UnifySerialization.Abstractions;

namespace FantaSim.Space.Stellar.Contracts.Entities;

[StructLayout(LayoutKind.Auto)]
[UnifyModel]
public readonly record struct StarProperties(
    [property: UnifyProperty(0)] double MassKg,
    [property: UnifyProperty(1)] double RadiusM,
    [property: UnifyProperty(2)] double LuminosityW,
    [property: UnifyProperty(3)] double EffectiveTemperatureK,
    [property: UnifyProperty(4)] string SpectralClass,
    [property: UnifyProperty(5)] double AgeYears,
    [property: UnifyProperty(6)] double Metallicity
) : IBodyProperties;


// --- PATH: contracts/Space.Stellar.Contracts/Events/BodyAddedEvent.cs ---
using FantaSim.Space.Stellar.Contracts.Entities;
using FantaSim.Space.Stellar.Contracts.Mechanics;
using UnifySerialization.Abstractions;

namespace FantaSim.Space.Stellar.Contracts.Events;

[UnifyModel]
public readonly record struct BodyAddedEvent(
    [property: UnifyProperty(0)] Guid SystemId,
    [property: UnifyProperty(1)] Guid BodyId,
    [property: UnifyProperty(2)] Guid? ParentBodyId,
    [property: UnifyProperty(3)] BodyType Type,
    [property: UnifyProperty(4)] string Name,
    [property: UnifyProperty(5)] OrbitalElements? Orbit,
    [property: UnifyProperty(6)] byte[] PropertiesData,
    [property: UnifyProperty(7)] long EventSequence
);


// --- PATH: contracts/Space.Stellar.Contracts/Events/BodyRemovalReason.cs ---
namespace FantaSim.Space.Stellar.Contracts.Events;

public enum BodyRemovalReason
{
    Collision,
    Ejection,
    Consumed,
    Administrative,
}


// --- PATH: contracts/Space.Stellar.Contracts/Events/BodyRemovedEvent.cs ---
using System.Runtime.InteropServices;
using UnifySerialization.Abstractions;

namespace FantaSim.Space.Stellar.Contracts.Events;

[StructLayout(LayoutKind.Auto)]
[UnifyModel]
public readonly record struct BodyRemovedEvent(
    [property: UnifyProperty(0)] Guid SystemId,
    [property: UnifyProperty(1)] Guid BodyId,
    [property: UnifyProperty(2)] BodyRemovalReason Reason,
    [property: UnifyProperty(3)] long EventSequence
);


// --- PATH: contracts/Space.Stellar.Contracts/Events/OrbitChangeReason.cs ---
namespace FantaSim.Space.Stellar.Contracts.Events;

public enum OrbitChangeReason
{
    Capture,
    Collision,
    GravitationalPerturbation,
    TidalDecay,
    Resonance,
    Administrative,
}


// --- PATH: contracts/Space.Stellar.Contracts/Events/OrbitChangedEvent.cs ---
using System.Runtime.InteropServices;
using FantaSim.Space.Stellar.Contracts.Mechanics;
using UnifySerialization.Abstractions;

namespace FantaSim.Space.Stellar.Contracts.Events;

[StructLayout(LayoutKind.Auto)]
[UnifyModel]
public readonly record struct OrbitChangedEvent(
    [property: UnifyProperty(0)] Guid SystemId,
    [property: UnifyProperty(1)] Guid BodyId,
    [property: UnifyProperty(2)] OrbitalElements OldOrbit,
    [property: UnifyProperty(3)] OrbitalElements NewOrbit,
    [property: UnifyProperty(4)] OrbitChangeReason Reason,
    [property: UnifyProperty(5)] long EventSequence
);


// --- PATH: contracts/Space.Stellar.Contracts/Events/SystemCreatedEvent.cs ---
using UnifySerialization.Abstractions;

namespace FantaSim.Space.Stellar.Contracts.Events;

[UnifyModel]
public readonly record struct SystemCreatedEvent(
    [property: UnifyProperty(0)] Guid SystemId,
    [property: UnifyProperty(1)] string SystemName,
    [property: UnifyProperty(2)] double EpochTimeS,
    [property: UnifyProperty(3)] long EventSequence,
    [property: UnifyProperty(4)] DateTime CreatedAtUtc
);


// --- PATH: contracts/Space.Stellar.Contracts/Mechanics/OrbitalElements.cs ---
using System.Runtime.InteropServices;
using UnifySerialization.Abstractions;

namespace FantaSim.Space.Stellar.Contracts.Mechanics;

[UnifyModel]
[StructLayout(LayoutKind.Auto)]
public readonly record struct OrbitalElements(
    [property: UnifyProperty(0)] double SemiMajorAxisM,
    [property: UnifyProperty(1)] double Eccentricity,
    [property: UnifyProperty(2)] double InclinationRad,
    [property: UnifyProperty(3)] double LongitudeOfAscendingNodeRad,
    [property: UnifyProperty(4)] double ArgumentOfPeriapsisRad,
    [property: UnifyProperty(5)] double MeanAnomalyAtEpochRad,
    [property: UnifyProperty(6)] double EpochTimeS
)
{
    /// <summary>Validate orbital elements are physically meaningful.</summary>
    public bool IsValid()
    {
        return SemiMajorAxisM > 0
            && Eccentricity >= 0 && Eccentricity < 1
            && InclinationRad >= 0 && InclinationRad <= Math.PI;
    }
}


// --- PATH: contracts/Space.Stellar.Contracts/Mechanics/OrbitalMechanics.cs ---
namespace FantaSim.Space.Stellar.Contracts.Mechanics;

public static class OrbitalMechanics
{
    public const double GravitationalConstant = 6.67430e-11; // m³/(kg·s²)

    /// <summary>Orbital period in seconds.</summary>
    public static double GetOrbitalPeriod(double semiMajorAxisM, double centralMassKg)
    {
        if (semiMajorAxisM <= 0)
            throw new ArgumentOutOfRangeException(nameof(semiMajorAxisM), semiMajorAxisM, "Must be > 0.");
        if (centralMassKg <= 0)
            throw new ArgumentOutOfRangeException(nameof(centralMassKg), centralMassKg, "Must be > 0.");

        // T = 2π * sqrt(a³ / μ)
        double mu = GravitationalConstant * centralMassKg;
        return 2.0 * Math.PI * Math.Sqrt(Math.Pow(semiMajorAxisM, 3) / mu);
    }

    /// <summary>Mean motion (radians per second).</summary>
    public static double GetMeanMotion(double semiMajorAxisM, double centralMassKg)
    {
        double period = GetOrbitalPeriod(semiMajorAxisM, centralMassKg);
        return 2.0 * Math.PI / period;
    }

    /// <summary>Periapsis distance in meters.</summary>
    public static double GetPeriapsis(OrbitalElements orbit)
        => orbit.SemiMajorAxisM * (1.0 - orbit.Eccentricity);

    /// <summary>Apoapsis distance in meters.</summary>
    public static double GetApoapsis(OrbitalElements orbit)
        => orbit.SemiMajorAxisM * (1.0 + orbit.Eccentricity);

    /// <summary>Orbital velocity at a given distance (vis-viva equation).</summary>
    public static double GetOrbitalVelocity(double distanceM, double semiMajorAxisM, double centralMassKg)
    {
        if (distanceM <= 0)
            throw new ArgumentOutOfRangeException(nameof(distanceM), distanceM, "Must be > 0.");
        if (semiMajorAxisM <= 0)
            throw new ArgumentOutOfRangeException(nameof(semiMajorAxisM), semiMajorAxisM, "Must be > 0.");
        if (centralMassKg <= 0)
            throw new ArgumentOutOfRangeException(nameof(centralMassKg), centralMassKg, "Must be > 0.");

        // v = sqrt(μ * (2/r - 1/a))
        double mu = GravitationalConstant * centralMassKg;
        return Math.Sqrt(mu * (2.0 / distanceM - 1.0 / semiMajorAxisM));
    }

    /// <summary>Escape velocity at a given distance from a body.</summary>
    public static double GetEscapeVelocity(double distanceM, double centralMassKg)
    {
        if (distanceM <= 0)
            throw new ArgumentOutOfRangeException(nameof(distanceM), distanceM, "Must be > 0.");
        if (centralMassKg <= 0)
            throw new ArgumentOutOfRangeException(nameof(centralMassKg), centralMassKg, "Must be > 0.");

        // v_escape = sqrt(2 * μ / r)
        double mu = GravitationalConstant * centralMassKg;
        return Math.Sqrt(2.0 * mu / distanceM);
    }

    /// <summary>Hill sphere radius (gravitational sphere of influence).</summary>
    public static double GetHillRadius(double semiMajorAxisM, double eccentricity, double bodyMassKg, double centralMassKg)
    {
        if (semiMajorAxisM <= 0)
            throw new ArgumentOutOfRangeException(nameof(semiMajorAxisM), semiMajorAxisM, "Must be > 0.");
        if (eccentricity < 0 || eccentricity >= 1)
            throw new ArgumentOutOfRangeException(nameof(eccentricity), eccentricity, "Must be in [0, 1).");
        if (bodyMassKg <= 0)
            throw new ArgumentOutOfRangeException(nameof(bodyMassKg), bodyMassKg, "Must be > 0.");
        if (centralMassKg <= 0)
            throw new ArgumentOutOfRangeException(nameof(centralMassKg), centralMassKg, "Must be > 0.");

        // r_Hill ≈ a * (1 - e) * (m / 3M)^(1/3)
        double massRatio = bodyMassKg / (3.0 * centralMassKg);
        return semiMajorAxisM * (1.0 - eccentricity) * Math.Pow(massRatio, 1.0 / 3.0);
    }
}


// --- PATH: contracts/Space.Stellar.Contracts/Numerics/Vector3d.cs ---
using System.Runtime.InteropServices;

namespace FantaSim.Space.Stellar.Contracts.Numerics;

/// <summary>
/// Double-precision 3D vector for orbital mechanics calculations.
/// Owned by Space.Stellar contracts to avoid cross-domain dependencies.
/// </summary>
[StructLayout(LayoutKind.Sequential)]
public readonly record struct Vector3d(double X, double Y, double Z)
{
    /// <summary>Zero vector (origin).</summary>
    public static readonly Vector3d Zero = new(0, 0, 0);

    /// <summary>Unit vector along X axis.</summary>
    public static readonly Vector3d UnitX = new(1, 0, 0);

    /// <summary>Unit vector along Y axis.</summary>
    public static readonly Vector3d UnitY = new(0, 1, 0);

    /// <summary>Unit vector along Z axis.</summary>
    public static readonly Vector3d UnitZ = new(0, 0, 1);

    /// <summary>Magnitude (length) of vector.</summary>
    public double Length() => Math.Sqrt(X * X + Y * Y + Z * Z);

    /// <summary>Squared magnitude (avoids sqrt for comparisons).</summary>
    public double LengthSquared() => X * X + Y * Y + Z * Z;

    /// <summary>Returns a unit vector in same direction.</summary>
    /// <exception cref="InvalidOperationException">If vector is zero.</exception>
    public Vector3d Normalize()
    {
        double len = Length();
        if (len < double.Epsilon)
            throw new InvalidOperationException("Cannot normalize a zero-length vector.");
        return new Vector3d(X / len, Y / len, Z / len);
    }

    /// <summary>Dot product with another vector.</summary>
    public double Dot(Vector3d other) => X * other.X + Y * other.Y + Z * other.Z;

    /// <summary>Cross product with another vector.</summary>
    public Vector3d Cross(Vector3d other) => new(
        Y * other.Z - Z * other.Y,
        Z * other.X - X * other.Z,
        X * other.Y - Y * other.X
    );

    /// <summary>Distance to another point.</summary>
    public double DistanceTo(Vector3d other) => (this - other).Length();

    // Operators
    public static Vector3d operator +(Vector3d a, Vector3d b) => new(a.X + b.X, a.Y + b.Y, a.Z + b.Z);
    public static Vector3d operator -(Vector3d a, Vector3d b) => new(a.X - b.X, a.Y - b.Y, a.Z - b.Z);
    public static Vector3d operator -(Vector3d v) => new(-v.X, -v.Y, -v.Z);
    public static Vector3d operator *(Vector3d v, double scalar) => new(v.X * scalar, v.Y * scalar, v.Z * scalar);
    public static Vector3d operator *(double scalar, Vector3d v) => new(v.X * scalar, v.Y * scalar, v.Z * scalar);
    public static Vector3d operator /(Vector3d v, double scalar) => new(v.X / scalar, v.Y / scalar, v.Z / scalar);

    public override string ToString() => $"({X:G6}, {Y:G6}, {Z:G6})";
}


// --- PATH: contracts/Space.Stellar.Contracts/Snapshots/L3BodySnapshot.cs ---
using System.Runtime.InteropServices;
using FantaSim.Space.Stellar.Contracts.Entities;
using FantaSim.Space.Stellar.Contracts.Mechanics;
using UnifySerialization.Abstractions;

namespace FantaSim.Space.Stellar.Contracts.Snapshots;

[StructLayout(LayoutKind.Auto)]
[UnifyModel]
public readonly record struct L3BodySnapshot(
    [property: UnifyProperty(0)] Guid BodyId,
    [property: UnifyProperty(1)] BodyType Type,
    [property: UnifyProperty(2)] OrbitalElements? Orbit,
    [property: UnifyProperty(3)] double MassKg,
    [property: UnifyProperty(4)] double RadiusM,
    [property: UnifyProperty(5)] Guid? ParentId,
    [property: UnifyProperty(6)] double ParentMassKg
);


// --- PATH: contracts/Space.Stellar.Contracts/Snapshots/L3SystemSnapshot.cs ---
using System.Collections.Immutable;
using System.Runtime.InteropServices;
using UnifySerialization.Abstractions;

namespace FantaSim.Space.Stellar.Contracts.Snapshots;

[StructLayout(LayoutKind.Auto)]
[UnifyModel]
public readonly record struct L3SystemSnapshot(
    [property: UnifyProperty(0)] Guid SystemId,
    [property: UnifyProperty(1)] ImmutableArray<L3BodySnapshot> Bodies,
    [property: UnifyProperty(2)] double CurrentTimeS
)
{
    public L3BodySnapshot? GetBody(Guid bodyId)
    {
        foreach (var body in Bodies)
        {
            if (body.BodyId == bodyId)
                return body;
        }

        return null;
    }
}


// --- PATH: contracts/Space.Stellar.Contracts/Solvers/IInsolationSolver.cs ---
namespace FantaSim.Space.Stellar.Contracts.Solvers;

/// <summary>
/// Defines insolation computation methods for stellar-planet interactions.
/// Provides deterministic, pure functions for calculating solar irradiance parameters.
/// </summary>
public interface IInsolationSolver
{
    /// <summary>
    /// Calculates solar flux at a given distance from a star using the inverse-square law.
    /// </summary>
    /// <param name="starLuminosityW">Star luminosity in watts (W).</param>
    /// <param name="distanceM">Distance from star in meters (m).</param>
    /// <returns>Solar flux in watts per square meter (W/m²).</returns>
    /// <remarks>
    /// Formula: Flux = Luminosity / (4π * distance²)
    /// </remarks>
    double CalculateSolarFlux(double starLuminosityW, double distanceM);

    /// <summary>
    /// Calculates daily insolation at a given latitude for a specific solar declination.
    /// </summary>
    /// <param name="latitudeRad">Latitude in radians (π/2 for north pole, -π/2 for south pole).</param>
    /// <param name="declinationRad">Solar declination in radians (positive for northern hemisphere summer).</param>
    /// <param name="solarConstant">Solar constant in watts per square meter (W/m²).</param>
    /// <returns>Daily insolation in watts per square meter (W/m²), averaged over 24 hours.</returns>
    /// <remarks>
    /// Accounts for the angle of incidence and day length at the specified latitude.
    /// </remarks>
    double CalculateDailyInsolation(double latitudeRad, double declinationRad, double solarConstant);

    /// <summary>
    /// Calculates the solar zenith angle at a given location and time.
    /// </summary>
    /// <param name="latitudeRad">Latitude in radians.</param>
    /// <param name="declinationRad">Solar declination in radians.</param>
    /// <param name="hourAngleRad">Hour angle in radians (solar noon = 0, negative morning, positive afternoon).</param>
    /// <returns>Solar zenith angle in radians (0 = sun directly overhead, π/2 = horizon, π = nadir).</returns>
    /// <remarks>
    /// The zenith angle is the angle between the sun's position and the local vertical.
    /// Uses spherical astronomy to determine sun position relative to observer.
    /// </remarks>
    double CalculateSolarZenithAngle(double latitudeRad, double declinationRad, double hourAngleRad);

    /// <summary>
    /// Calculates the length of daylight at a given latitude for a specific solar declination.
    /// </summary>
    /// <param name="latitudeRad">Latitude in radians.</param>
    /// <param name="declinationRad">Solar declination in radians.</param>
    /// <returns>Day length in hours. Can be 0 (polar night) or 24 (polar day).</returns>
    /// <remarks>
    /// Day length depends on the latitude and the sun's declination, creating seasonal variations.
    /// </remarks>
    double CalculateDayLength(double latitudeRad, double declinationRad);

    /// <summary>
    /// Calculates the sunrise hour angle, which determines when the sun crosses the horizon.
    /// </summary>
    /// <param name="latitudeRad">Latitude in radians.</param>
    /// <param name="declinationRad">Solar declination in radians.</param>
    /// <returns>Hour angle at sunrise in radians. If negative, polar night; if greater than π, polar day.</returns>
    /// <remarks>
    /// The sunrise hour angle (ω₀) is the solar hour angle when the sun's center is on the horizon.
    /// It's used to calculate day length and daily insolation.
    /// </remarks>
    double CalculateSunriseHourAngle(double latitudeRad, double declinationRad);
}


// --- PATH: contracts/Space.Stellar.Contracts/Solvers/IOrbitSolver.cs ---
using FantaSim.Space.Stellar.Contracts.Mechanics;
using FantaSim.Space.Stellar.Contracts.Numerics;

namespace FantaSim.Space.Stellar.Contracts.Solvers;

/// <summary>
/// Solver for orbital mechanics calculations.
/// Converts between orbital elements and Cartesian state vectors.
/// </summary>
public interface IOrbitSolver
{
    /// <summary>
    /// Calculate position vector at a given time.
    /// </summary>
    /// <param name="orbit">Orbital elements defining the orbit.</param>
    /// <param name="centralMassKg">Mass of the central body in kilograms.</param>
    /// <param name="timeS">Time at which to calculate position (seconds since epoch).</param>
    /// <returns>Position vector in meters relative to central body in inertial reference frame.</returns>
    Vector3d CalculatePosition(OrbitalElements orbit, double centralMassKg, double timeS);

    /// <summary>
    /// Calculate velocity vector at a given time.
    /// </summary>
    /// <param name="orbit">Orbital elements defining the orbit.</param>
    /// <param name="centralMassKg">Mass of the central body in kilograms.</param>
    /// <param name="timeS">Time at which to calculate velocity (seconds since epoch).</param>
    /// <returns>Velocity vector in meters per second relative to central body in inertial reference frame.</returns>
    Vector3d CalculateVelocity(OrbitalElements orbit, double centralMassKg, double timeS);

    /// <summary>
    /// Calculate complete orbital state at a given time.
    /// </summary>
    /// <param name="orbit">Orbital elements defining the orbit.</param>
    /// <param name="centralMassKg">Mass of the central body in kilograms.</param>
    /// <param name="timeS">Time at which to calculate state (seconds since epoch).</param>
    /// <returns>Complete orbital state including position, velocity, and anomalies.</returns>
    OrbitalState CalculateOrbitalState(OrbitalElements orbit, double centralMassKg, double timeS);

    /// <summary>
    /// Find the time at which the body reaches a target true anomaly.
    /// </summary>
    /// <param name="orbit">Orbital elements defining the orbit.</param>
    /// <param name="centralMassKg">Mass of the central body in kilograms.</param>
    /// <param name="targetTrueAnomalyRad">Target true anomaly in radians (range [0, 2π)).</param>
    /// <param name="afterTimeS">Search for the next occurrence after this time (seconds since epoch).</param>
    /// <returns>Time in seconds since epoch when the body reaches the target true anomaly.</returns>
    double FindTimeAtTrueAnomaly(OrbitalElements orbit, double centralMassKg, double targetTrueAnomalyRad, double afterTimeS);

    /// <summary>
    /// Convert mean anomaly to true anomaly.
    /// </summary>
    /// <param name="meanAnomalyRad">Mean anomaly in radians (range [0, 2π)).</param>
    /// <param name="eccentricity">Orbital eccentricity (range [0, 1)).</param>
    /// <returns>True anomaly in radians (range [0, 2π)).</returns>
    double MeanToTrueAnomaly(double meanAnomalyRad, double eccentricity);

    /// <summary>
    /// Convert true anomaly to eccentric anomaly.
    /// </summary>
    /// <param name="trueAnomalyRad">True anomaly in radians (range [0, 2π)).</param>
    /// <param name="eccentricity">Orbital eccentricity (range [0, 1)).</param>
    /// <returns>Eccentric anomaly in radians (range [0, 2π)).</returns>
    double TrueToEccentricAnomaly(double trueAnomalyRad, double eccentricity);
}


// --- PATH: contracts/Space.Stellar.Contracts/Solvers/OrbitalState.cs ---
using System.Runtime.InteropServices;
using FantaSim.Space.Stellar.Contracts.Numerics;

namespace FantaSim.Space.Stellar.Contracts.Solvers;

/// <summary>
/// Represents the complete orbital state of a body at a specific time.
/// Includes both Cartesian state vectors and orbital anomalies.
/// </summary>
[StructLayout(LayoutKind.Auto)]
public readonly record struct OrbitalState(
    Vector3d PositionM,
    Vector3d VelocityMPerS,
    double DistanceM,
    double SpeedMPerS,
    double TrueAnomalyRad,
    double EccentricAnomalyRad,
    double MeanAnomalyRad,
    double TimeS
);


// --- PATH: contracts/Space.Stellar.Contracts/Topology/L3Body.cs ---
using FantaSim.Space.Stellar.Contracts.Entities;
using FantaSim.Space.Stellar.Contracts.Mechanics;

namespace FantaSim.Space.Stellar.Contracts.Topology;

public sealed class L3Body
{
    public required Guid BodyId { get; init; }

    public required string Name { get; init; }

    public required BodyType Type { get; init; }

    /// <summary>Null for root body (star or barycenter).</summary>
    public OrbitalElements? Orbit { get; init; }

    /// <summary>Type-specific physical properties.</summary>
    public required IBodyProperties Properties { get; init; }

    /// <summary>Child bodies (moons, belts, etc.).</summary>
    public required IReadOnlyList<L3Body> Children { get; init; }

    /// <summary>Parent body ID (null for root).</summary>
    public Guid? ParentId { get; init; }

    public bool HasChildren => Children.Count != 0;

    /// <summary>Get the depth in the hierarchy (0 = root).</summary>
    public int GetDepth(L3SystemTopology topology)
    {
        ArgumentNullException.ThrowIfNull(topology);

        var depth = 0;
        var current = this;

        while (current.ParentId.HasValue)
        {
            var parent = topology.GetBodyById(current.ParentId.Value);
            if (parent is null)
                break;

            depth++;
            current = parent;
        }

        return depth;
    }
}


// --- PATH: contracts/Space.Stellar.Contracts/Topology/L3SystemTopology.cs ---
using FantaSim.Space.Stellar.Contracts.Entities;

namespace FantaSim.Space.Stellar.Contracts.Topology;

public sealed class L3SystemTopology
{
    public required Guid SystemId { get; init; }

    public required string SystemName { get; init; }

    public required L3Body RootBody { get; init; }

    public required double EpochTimeS { get; init; }

    private Dictionary<Guid, L3Body>? _bodyIndex;

    public L3Body? GetBodyById(Guid bodyId)
    {
        _bodyIndex ??= BuildIndex(RootBody);
        return _bodyIndex.GetValueOrDefault(bodyId);
    }

    public IEnumerable<L3Body> GetAllBodies()
    {
        _bodyIndex ??= BuildIndex(RootBody);
        return _bodyIndex.Values;
    }

    public IEnumerable<L3Body> GetBodiesOfType(BodyType type)
        => GetAllBodies().Where(b => b.Type == type);

    private static Dictionary<Guid, L3Body> BuildIndex(L3Body root)
    {
        var index = new Dictionary<Guid, L3Body>();

        void Traverse(L3Body body)
        {
            index[body.BodyId] = body;
            foreach (var child in body.Children)
                Traverse(child);
        }

        Traverse(root);
        return index;
    }
}


// --- PATH: contracts/Space.Stellar.Contracts/Validation/L3ValidationRules.cs ---
using FantaSim.Space.Stellar.Contracts.Topology;

namespace FantaSim.Space.Stellar.Contracts.Validation;

public static class L3ValidationRules
{
    public static ValidationResult ValidateTopology(L3SystemTopology topology)
    {
        ArgumentNullException.ThrowIfNull(topology);

        var errors = new List<string>();

        if (topology.RootBody is null)
        {
            errors.Add("System must have a root body.");
            return new ValidationResult(false, errors);
        }

        if (topology.RootBody.ParentId is not null)
            errors.Add("Root body must not have a parent.");

        if (topology.RootBody.Orbit is not null)
            errors.Add("Root body must not have an orbit.");

        var byId = new Dictionary<Guid, L3Body>();

        Traverse(topology.RootBody, expectedParentId: null);
        ValidateParentChains();

        return new ValidationResult(errors.Count == 0, errors);

        void Traverse(L3Body body, Guid? expectedParentId)
        {
            if (!byId.TryAdd(body.BodyId, body))
            {
                errors.Add($"Duplicate BodyId detected: {body.BodyId}.");
                return;
            }

            if (expectedParentId is null)
            {
                if (body.ParentId is not null)
                    errors.Add($"Root body {body.BodyId} must have ParentId null.");
                if (body.Orbit is not null)
                    errors.Add($"Root body {body.BodyId} must have Orbit null.");
            }
            else
            {
                if (body.ParentId is null)
                    errors.Add($"Body {body.BodyId} is non-root but has ParentId null.");
                else if (body.ParentId != expectedParentId)
                    errors.Add($"Body {body.BodyId} ParentId {body.ParentId} does not match container parent {expectedParentId}.");

                if (body.Orbit is null)
                    errors.Add($"Body {body.BodyId} has a parent but no orbit.");
                else if (!body.Orbit.Value.IsValid())
                    errors.Add($"Body {body.BodyId} has invalid orbital elements.");
            }

            if (string.IsNullOrWhiteSpace(body.Name))
                errors.Add($"Body {body.BodyId} has empty Name.");

            if (body.Properties is null)
                errors.Add($"Body {body.BodyId} has null Properties.");

            foreach (var child in body.Children)
                Traverse(child, expectedParentId: body.BodyId);
        }

        void ValidateParentChains()
        {
            foreach (var body in byId.Values)
            {
                var seen = new HashSet<Guid>();
                var current = body;

                while (current.ParentId.HasValue)
                {
                    if (!seen.Add(current.BodyId))
                    {
                        errors.Add($"Cycle detected in parent chain at BodyId {current.BodyId}.");
                        break;
                    }

                    var parentId = current.ParentId.Value;
                    if (!byId.TryGetValue(parentId, out var parent))
                    {
                        errors.Add($"Body {current.BodyId} references missing parent {parentId}.");
                        break;
                    }

                    current = parent;
                }
            }
        }
    }
}


// --- PATH: contracts/Space.Stellar.Contracts/Validation/ValidationResult.cs ---
namespace FantaSim.Space.Stellar.Contracts.Validation;

public sealed record ValidationResult(bool IsValid, IReadOnlyList<string> Errors);


// --- PATH: hosts/Geosphere.Plate.PluginSmokeHost/NonCachingPluginActivator.cs ---
using System;
using System.Linq;
using PluginArchi.Extensibility.Abstractions;

namespace FantaSim.Geosphere.Plate.PluginSmokeHost;

public sealed class NonCachingPluginActivator : IPluginActivator
{
    public bool CanActivate(Type pluginType)
        => pluginType is not null
           && !pluginType.IsAbstract
           && typeof(IPlugin).IsAssignableFrom(pluginType)
           && pluginType.GetConstructors().Length > 0;

    public IPlugin Activate(Type pluginType, IServiceProvider services)
    {
        if (!CanActivate(pluginType))
        {
            throw new PluginLoadException($"Cannot activate plugin type {pluginType?.FullName}.")
            {
                PluginId = pluginType?.FullName,
                Reason = PluginLoadFailureReason.ActivationFailed
            };
        }

        var constructors = pluginType!
            .GetConstructors()
            .OrderByDescending(c => c.GetParameters().Length)
            .ToArray();

        foreach (var ctor in constructors)
        {
            var parameters = ctor.GetParameters();
            var args = new object?[parameters.Length];
            var ok = true;

            for (var i = 0; i < parameters.Length; i++)
            {
                var p = parameters[i];
                var service = services.GetService(p.ParameterType);

                if (service is not null)
                {
                    args[i] = service;
                }
                else if (p.HasDefaultValue)
                {
                    args[i] = p.DefaultValue;
                }
                else
                {
                    ok = false;
                    break;
                }
            }

            if (!ok)
            {
                continue;
            }

            return (IPlugin)ctor.Invoke(args);
        }

        throw new PluginLoadException($"Cannot activate plugin type {pluginType?.FullName}: no constructor could be satisfied from the host services.")
        {
            PluginId = pluginType?.FullName,
            Reason = PluginLoadFailureReason.DependencyMissing
        };
    }
}


// --- PATH: hosts/Geosphere.Plate.PluginSmokeHost/Program.cs ---
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using FantaSim.Geosphere.Plate.Runtime.Des;
using FantaSim.Geosphere.Plate.Topology.Contracts.Derived;
using FantaSim.Geosphere.Plate.Topology.Contracts.Events;
using FantaSim.Geosphere.Plate.Topology.Materializer;
using PluginArchi.Extensibility.Hosting;
using FantaSim.Geosphere.Plate.PluginSmokeHost;
using ServiceArchi.Contracts;
using ServiceArchi.Core;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.Loader;
using System.Threading;

using var loggerFactory = LoggerFactory.Create(builder =>
{
    builder.SetMinimumLevel(LogLevel.Information);
    builder.AddSimpleConsole(options =>
    {
        options.SingleLine = true;
        options.TimestampFormat = "HH:mm:ss ";
    });
});

var logger = loggerFactory.CreateLogger("FantaSim.World.PluginSmokeHost");

var pluginDir = args.Length > 0 && !string.IsNullOrWhiteSpace(args[0])
    ? args[0]
    : Path.Combine(AppContext.BaseDirectory, "plugins");

Directory.CreateDirectory(pluginDir);

static bool TrySeedPluginDirectoryFromBuildOutput(string buildOutputDir, string pluginDir)
{
    if (!Directory.Exists(buildOutputDir))
    {
        return false;
    }

    var hostFiles = Directory.GetFiles(AppContext.BaseDirectory)
        .Select(Path.GetFileName)
        .ToHashSet(StringComparer.OrdinalIgnoreCase);

    var files = Directory.GetFiles(buildOutputDir)
        .Where(f =>
            f.EndsWith(".dll", StringComparison.OrdinalIgnoreCase)
            || f.EndsWith(".deps.json", StringComparison.OrdinalIgnoreCase))
        .ToArray();

    if (files.Length == 0)
    {
        return false;
    }

    foreach (var file in files)
    {
        var fileName = Path.GetFileName(file);
        if (hostFiles.Contains(fileName))
        {
            continue;
        }

        var dst = Path.Combine(pluginDir, fileName);
        File.Copy(file, dst, overwrite: true);
    }

    return true;
}

static bool TrySeedPluginDirectoryFromBuildOutputs(string projectDir, string pluginDir)
{
    var pluginNames = new[]
    {
        "Geosphere.Plate.Runtime.Des",
        "Space.Stellar.Solvers.Reference",
        "Geosphere.Plate.Reconstruction.Solver",
        "Geosphere.Plate.Kinematics.Serializers",
        "Geosphere.Plate.Kinematics.Materializer",
        "Geosphere.Plate.Topology.Serializers",
        "Geosphere.Plate.Topology.Materializer"
    };

    var anySeeded = false;

    foreach (var name in pluginNames)
    {
        var candidateDirs = new[]
        {
            Path.Combine(projectDir, "plugins", name, "bin", "Release", "net8.0"),
            Path.Combine(projectDir, "plugins", name, "bin", "Debug", "net8.0")
        };

        foreach (var dir in candidateDirs)
        {
            if (TrySeedPluginDirectoryFromBuildOutput(dir, pluginDir))
            {
                anySeeded = true;
                break;
            }
        }
    }

    return anySeeded;
}

var registry = new ServiceArchi.Core.ServiceRegistry();

// We'll recreate the ServiceCollection for each iteration while keeping the
// ServiceRegistry (registry) and loggerFactory singleton outside the loop.

var projectDir = Path.GetFullPath(Path.Combine(AppContext.BaseDirectory, "..", "..", "..", "..", ".."));
var seeded = TrySeedPluginDirectoryFromBuildOutputs(projectDir, pluginDir);

Assembly.Load("Geosphere.Plate.Topology.Materializer");

var allCollected = true;
for (var i = 0; i < 5; i++)
{
    logger.LogInformation("=== Iteration {Iteration}/5 ===", i + 1);

    var services = new ServiceCollection();
    services.AddSingleton(loggerFactory);
    services.AddSingleton(typeof(ILogger<>), typeof(Logger<>));

    // Register the shared registry instance and other required services per-iteration
    services.AddSingleton<IRegistry>(registry);
    services.AddSingleton<ITopologyEventStore, NullTopologyEventStore>();
    services.AddSingleton<IPlateTopologySnapshotStore, NullPlateTopologySnapshotStore>();
    services.AddSingleton<PlateTopologyTimeline>();

    var collected = RunAndVerifyUnload(services, logger, registry, pluginDir, seeded);
    logger.LogInformation("Plugin load context collected after shutdown: {Collected}", collected);

    if (!collected)
    {
        Environment.ExitCode = 1;
        allCollected = false;
        break;
    }
}

[MethodImpl(MethodImplOptions.NoInlining)]
static bool RunAndVerifyUnload(IServiceCollection services, ILogger logger, IRegistry registry, string pluginDir, bool seeded)
{
    var weakRef = RunPluginHostOnce(services, logger, registry, pluginDir, seeded);
    var collected = WaitForUnload(weakRef);

    if (!collected)
    {
        DumpContexts(logger, weakRef);
    }

    return collected;
}

static void DumpContexts(ILogger logger, WeakReference weakRef)
{
    if (weakRef.Target is AssemblyLoadContext alc)
    {
        logger.LogInformation("Unloaded context still alive: Name={Name}, IsCollectible={IsCollectible}, Assemblies={AssemblyCount}", alc.Name, alc.IsCollectible, alc.Assemblies.Count());
        foreach (var a in alc.Assemblies.OrderBy(a => a.GetName().Name, StringComparer.OrdinalIgnoreCase))
        {
            logger.LogInformation("- ALC Assembly: {Assembly}", a.GetName().Name);
        }
    }

    var all = AssemblyLoadContext.All.ToArray();
    logger.LogInformation("AssemblyLoadContext.All: {Count}", all.Length);
    foreach (var c in all.OrderBy(c => c.Name ?? string.Empty, StringComparer.OrdinalIgnoreCase))
    {
        logger.LogInformation("- ALC: Name={Name}, IsCollectible={IsCollectible}, Assemblies={AssemblyCount}", c.Name, c.IsCollectible, c.Assemblies.Count());
    }
}

[MethodImpl(MethodImplOptions.NoInlining)]
static WeakReference RunPluginHostOnce(IServiceCollection services, ILogger logger, IRegistry registry, string pluginDir, bool seeded)
{
    var loader = new IsolatedLoader(pluginDir, "*.dll", SearchOption.TopDirectoryOnly, contextName: "FantaSimWorldPlugins");
    var builder = new PluginHostBuilder(services)
        .UseLoader(loader)
        .UseActivator(new NonCachingPluginActivator());

    var host = builder.Build();
    try
    {

    logger.LogInformation("Plugin directory: {PluginDir}", pluginDir);
    logger.LogInformation("Seeded plugin directory from build output: {Seeded}", seeded);
    logger.LogInformation("SupportsReload={SupportsReload}", host.SupportsReload);

    host.InitializeAsync().GetAwaiter().GetResult();
    logger.LogInformation("DES factory registered (pre-shutdown): {Registered}", registry.IsRegistered<IDesRuntimeFactory>());

    logger.LogInformation("Discovered plugins: {Count}", host.Registry.Plugins.Count);
    foreach (var plugin in host.Registry.Plugins)
    {
        logger.LogInformation("- {PluginId}", plugin.Descriptor.Id);
    }

    var enableReload = string.Equals(
        Environment.GetEnvironmentVariable("FANTASIM_SMOKEHOTRELOAD"),
        "1",
        StringComparison.OrdinalIgnoreCase);

    if (enableReload)
    {
        var reloadOk = host.ReloadPluginsAsync().GetAwaiter().GetResult();
        logger.LogInformation("ReloadPluginsAsync result: {ReloadOk}", reloadOk);
    }

    var context = loader.Context;
    var weakRef = new WeakReference(context ?? throw new InvalidOperationException("Loader context is null after host initialization."));
    context = null;

    host.ShutdownAsync().GetAwaiter().GetResult();
    logger.LogInformation("DES factory registered (post-shutdown): {Registered}", registry.IsRegistered<IDesRuntimeFactory>());
    return weakRef;
    }
    finally
    {
        host.DisposeAsync().GetAwaiter().GetResult();
    }
}

static bool WaitForUnload(WeakReference weakRef)
{
    for (var i = 0; i < 200; i++)
    {
        GC.Collect(GC.MaxGeneration, GCCollectionMode.Forced, blocking: true, compacting: true);
        GC.WaitForPendingFinalizers();
        GC.Collect(GC.MaxGeneration, GCCollectionMode.Forced, blocking: true, compacting: true);

        if (IsCollected(weakRef))
        {
            return true;
        }

        Thread.Sleep(50);
    }

    return IsCollected(weakRef);
}

[MethodImpl(MethodImplOptions.NoInlining)]
static bool IsCollected(WeakReference weakRef)
{
    return !weakRef.IsAlive;
}


// --- PATH: hosts/Geosphere.Plate.PluginSmokeHost/TopologyTestDoubles.cs ---
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;
using FantaSim.Geosphere.Plate.Topology.Contracts.Derived;
using FantaSim.Geosphere.Plate.Topology.Contracts.Events;
using FantaSim.Geosphere.Plate.Topology.Contracts.Identity;

namespace FantaSim.Geosphere.Plate.PluginSmokeHost;

internal sealed class NullTopologyEventStore : ITopologyEventStore
{
    public Task AppendAsync(
        TruthStreamIdentity stream,
        IEnumerable<IPlateTopologyEvent> events,
        CancellationToken cancellationToken)
    {
        return Task.CompletedTask;
    }

    public Task AppendAsync(
        TruthStreamIdentity stream,
        IEnumerable<IPlateTopologyEvent> events,
        AppendOptions options,
        CancellationToken cancellationToken)
    {
        return Task.CompletedTask;
    }

    public async IAsyncEnumerable<IPlateTopologyEvent> ReadAsync(
        TruthStreamIdentity stream,
        long fromSequenceInclusive,
        [EnumeratorCancellation] CancellationToken cancellationToken)
    {
        yield break;
    }

    public Task<long?> GetLastSequenceAsync(TruthStreamIdentity stream, CancellationToken cancellationToken)
    {
        return Task.FromResult<long?>(null);
    }

    public Task<StreamHead> GetHeadAsync(TruthStreamIdentity stream, CancellationToken cancellationToken)
    {
        return Task.FromResult(StreamHead.Empty);
    }
}

internal sealed class NullPlateTopologySnapshotStore : IPlateTopologySnapshotStore
{
    public Task SaveSnapshotAsync(PlateTopologySnapshot snapshot, CancellationToken cancellationToken)
    {
        return Task.CompletedTask;
    }

    public Task<PlateTopologySnapshot?> GetSnapshotAsync(PlateTopologyMaterializationKey key, CancellationToken cancellationToken)
    {
        return Task.FromResult<PlateTopologySnapshot?>(null);
    }

    public Task<PlateTopologySnapshot?> GetLatestSnapshotBeforeAsync(
        TruthStreamIdentity stream,
        long targetTick,
        CancellationToken cancellationToken)
    {
        return Task.FromResult<PlateTopologySnapshot?>(null);
    }
}


// --- PATH: hosts/Geosphere.Plate.SolverLab.Core/Benchmarking/BenchmarkReport.cs ---
using System.Collections.Immutable;

namespace FantaSim.Geosphere.Plate.SolverLab.Core.Benchmarking;

public enum CaseStatus
{
    Passed,
    Failed,
    Skipped
}

public sealed record CaseBenchmarkResult
{
    public required string CaseId { get; init; }
    public required CaseStatus Status { get; init; }
    public string? ErrorMessage { get; init; }
    public double MedianTimeMs { get; init; }
    public double MinTimeMs { get; init; }
    public double MaxTimeMs { get; init; }
}

public sealed record SolverBenchmarkResult
{
    public required string SolverName { get; init; }
    public required string SolverVersion { get; init; }
    public required CaseBenchmarkResult[] Cases { get; init; }
}

public sealed record BenchmarkReport
{
    public required DateTime Timestamp { get; init; }
    public required SolverBenchmarkResult[] Results { get; init; }
}


// --- PATH: hosts/Geosphere.Plate.SolverLab.Core/Benchmarking/IVerifier.cs ---
namespace FantaSim.Geosphere.Plate.SolverLab.Core.Benchmarking;

public interface IVerifier<in TOutput>
{
    bool Verify(TOutput expected, TOutput actual, out string? error);
}


// --- PATH: hosts/Geosphere.Plate.SolverLab.Core/Benchmarking/SolverBenchmark.cs ---
using System.Collections.Immutable;
using System.Diagnostics;
using FantaSim.Geosphere.Plate.Topology.Contracts.Simulation;
using FantaSim.Geosphere.Plate.SolverLab.Core.Corpus;
using MessagePack;

namespace FantaSim.Geosphere.Plate.SolverLab.Core.Benchmarking;

public sealed class SolverBenchmark<TInput, TOutput>
{
    private readonly IReadOnlyList<ISolver<TInput, TOutput>> _solvers;
    private readonly SolverCorpus _corpus;
    private readonly IVerifier<TOutput> _verifier;
    private readonly MessagePackSerializerOptions _options;

    public SolverBenchmark(
        IReadOnlyList<ISolver<TInput, TOutput>> solvers,
        SolverCorpus corpus,
        IVerifier<TOutput> verifier,
        MessagePackSerializerOptions options)
    {
        _solvers = solvers;
        _corpus = corpus;
        _verifier = verifier;
        _options = options;
    }

    public Task<BenchmarkReport> RunAsync(CancellationToken ct = default)
    {
        var results = new List<SolverBenchmarkResult>();

        foreach (var solver in _solvers)
        {
            var solverResults = new List<CaseBenchmarkResult>();

            foreach (var testCase in _corpus.Cases)
            {
                var input = MessagePackSerializer.Deserialize<TInput>(testCase.InputData, _options);
                var expected = MessagePackSerializer.Deserialize<TOutput>(testCase.ExpectedOutput, _options);

                // Warmup
                for (int i = 0; i < 3; i++)
                    solver.Calculate(input);

                // Timed runs
                var times = new List<double>();
                bool anyFailure = false;
                string? firstError = null;

                for (int i = 0; i < 10; i++)
                {
                    var sw = Stopwatch.StartNew();
                    var actual = solver.Calculate(input);
                    sw.Stop();
                    times.Add(sw.Elapsed.TotalMilliseconds);

                    // Verify correctness on first run
                    if (i == 0)
                    {
                        if (!_verifier.Verify(expected, actual, out var error))
                        {
                            anyFailure = true;
                            firstError = error;
                        }
                    }
                }

                if (anyFailure)
                {
                    solverResults.Add(new CaseBenchmarkResult
                    {
                        CaseId = testCase.CaseId,
                        Status = CaseStatus.Failed,
                        ErrorMessage = firstError ?? "Output mismatch",
                        MedianTimeMs = 0,
                        MinTimeMs = 0,
                        MaxTimeMs = 0
                    });
                }
                else
                {
                    times.Sort();
                    solverResults.Add(new CaseBenchmarkResult
                    {
                        CaseId = testCase.CaseId,
                        Status = CaseStatus.Passed,
                        MedianTimeMs = times[times.Count / 2],
                        MinTimeMs = times[0],
                        MaxTimeMs = times[^1]
                    });
                }
            }

            results.Add(new SolverBenchmarkResult
            {
                SolverName = solver.Metadata.Name,
                SolverVersion = solver.Metadata.Version,
                Cases = solverResults.ToArray()
            });
        }

        return Task.FromResult(new BenchmarkReport
        {
            Timestamp = DateTime.UtcNow,
            Results = results.ToArray()
        });
    }
}


// --- PATH: hosts/Geosphere.Plate.SolverLab.Core/Benchmarking/Verifiers/PlateMotionVerifier.cs ---
using System.Collections.Immutable;
using FantaSim.Geosphere.Plate.Topology.Contracts.Simulation;
using FantaSim.Geosphere.Plate.Topology.Contracts.Numerics;

namespace FantaSim.Geosphere.Plate.SolverLab.Core.Benchmarking.Verifiers;

public sealed class PlateMotionVerifier : IVerifier<PlateMotionResult>
{
    private readonly double _positionToleranceM = 1.0;        // 1 meter
    private readonly double _rotationToleranceRad = 1e-6;     // ~0.00006 degrees

    public bool Verify(PlateMotionResult expected, PlateMotionResult actual, out string? error)
    {
        var errors = new List<string>();

        // Check all plate motions
        foreach (var expectedMotion in expected.PlateMotions)
        {
            var actualMotion = actual.PlateMotions
                .FirstOrDefault(m => m.PlateId == expectedMotion.PlateId);

            if (actualMotion.PlateId == default)
            {
                errors.Add($"Missing motion for plate {expectedMotion.PlateId}");
                continue;
            }

            // Position check
            var positionDiff = (expectedMotion.DeltaPosition - actualMotion.DeltaPosition).Length();
            if (positionDiff > _positionToleranceM)
            {
                errors.Add($"Plate {expectedMotion.PlateId}: position diff {positionDiff:F3}m exceeds tolerance");
            }

            // Rotation check
            var rotationDiff = Quaterniond.Angle(expectedMotion.DeltaRotation, actualMotion.DeltaRotation);
            if (rotationDiff > _rotationToleranceRad)
            {
                errors.Add($"Plate {expectedMotion.PlateId}: rotation diff {rotationDiff:E3}rad exceeds tolerance");
            }
        }

        // Check topology events
        if (expected.NewRifts.Length != actual.NewRifts.Length)
        {
            errors.Add($"Rift count mismatch: expected {expected.NewRifts.Length}, got {actual.NewRifts.Length}");
        }

        if (errors.Count > 0)
        {
            error = string.Join("; ", errors);
            return false;
        }

        error = null;
        return true;
    }
}


// --- PATH: hosts/Geosphere.Plate.SolverLab.Core/Class1.cs ---
﻿namespace Geosphere.Plate.SolverLab.Core;

public class Class1
{

}


// --- PATH: hosts/Geosphere.Plate.SolverLab.Core/Corpus/CaseDifficulty.cs ---
namespace FantaSim.Geosphere.Plate.SolverLab.Core.Corpus;

public enum CaseDifficulty
{
    Trivial,      // Edge cases, simple scenarios
    Normal,       // Typical simulation states
    Complex,      // Many interacting elements
    Adversarial   // Designed to break naive implementations
}


// --- PATH: hosts/Geosphere.Plate.SolverLab.Core/Corpus/CorpusCase.cs ---
namespace FantaSim.Geosphere.Plate.SolverLab.Core.Corpus;

public sealed class CorpusCase
{
    public required string CaseId { get; init; }
    public required string Description { get; init; }
    public required byte[] InputData { get; init; }        // MessagePack-encoded snapshot
    public required byte[] ExpectedOutput { get; init; }   // MessagePack-encoded result
    public required CaseDifficulty Difficulty { get; init; }
    public required string[] Tags { get; init; }           // e.g., ["collision", "stress-test"]
}


// --- PATH: hosts/Geosphere.Plate.SolverLab.Core/Corpus/FlowlineCorpusEntry.cs ---
using System.Runtime.InteropServices;
using MessagePack;
using Plate.TimeDete.Time.Primitives;
using FantaSim.Geosphere.Plate.Topology.Contracts.Entities;
using FantaSim.Geosphere.Plate.Velocity.Contracts;
using FantaSim.Geosphere.Plate.Motion.Contracts;

namespace FantaSim.Geosphere.Plate.SolverLab.Core.Corpus;

/// <summary>
/// Strongly-typed corpus entry for flowline test cases (RFC-V2-0035 §12).
/// </summary>
[MessagePackObject]
public sealed class FlowlineCorpusEntry
{
    [Key(0)]
    public required string CaseId { get; init; }

    [Key(1)]
    public required string Description { get; init; }

    [Key(2)]
    public required FlowlineInput Input { get; init; }

    [Key(3)]
    public required Flowline ExpectedOutput { get; init; }

    [Key(4)]
    public required CaseDifficulty Difficulty { get; init; }

    [Key(5)]
    public required string[] Tags { get; init; }
}

/// <summary>
/// Input parameters for flowline corpus cases.
/// </summary>
[StructLayout(LayoutKind.Auto)]
[MessagePackObject]
public readonly record struct FlowlineInput(
    [property: Key(0)] BoundaryId BoundaryId,
    [property: Key(1)] BoundaryVelocitySample SeedSample,
    [property: Key(2)] PlateId LeftPlateId,
    [property: Key(3)] PlateId RightPlateId,
    [property: Key(4)] PlateSide Side,
    [property: Key(5)] int StepCount,
    [property: Key(6)] int StepTicks,
    [property: Key(7)] CanonicalTick StartTick,
    [property: Key(8)] IntegrationDirection Direction
);


// --- PATH: hosts/Geosphere.Plate.SolverLab.Core/Corpus/MotionPathCorpusEntry.cs ---
using System.Runtime.InteropServices;
using MessagePack;
using Plate.TimeDete.Time.Primitives;
using UnifyGeometry;
using FantaSim.Geosphere.Plate.Topology.Contracts.Entities;
using FantaSim.Geosphere.Plate.Topology.Contracts.Numerics;
using FantaSim.Geosphere.Plate.Motion.Contracts;

namespace FantaSim.Geosphere.Plate.SolverLab.Core.Corpus;

/// <summary>
/// Strongly-typed corpus entry for motion path test cases (RFC-V2-0035 §12).
/// </summary>
[MessagePackObject]
public sealed class MotionPathCorpusEntry
{
    [Key(0)]
    public required string CaseId { get; init; }

    [Key(1)]
    public required string Description { get; init; }

    [Key(2)]
    public required MotionPathInput Input { get; init; }

    [Key(3)]
    public required MotionPath ExpectedOutput { get; init; }

    [Key(4)]
    public required CaseDifficulty Difficulty { get; init; }

    [Key(5)]
    public required string[] Tags { get; init; }
}

/// <summary>
/// Input parameters for motion path corpus cases.
/// </summary>
/// <remarks>
/// <para>
/// <b>Type safety:</b> StartPoint is a <see cref="Point3"/> (position on sphere),
/// while RotationAxis is a <see cref="UnitVector3d"/> (direction/axis of rotation).
/// This distinction prevents "point vs vector" confusion bugs.
/// </para>
/// </remarks>
[StructLayout(LayoutKind.Auto)]
[MessagePackObject]
public readonly record struct MotionPathInput(
    [property: Key(0)] PlateId PlateId,
    [property: Key(1)] Point3 StartPoint,
    [property: Key(2)] UnitVector3d RotationAxis,  // Direction vector (unit length)
    [property: Key(3)] double AngularRate,
    [property: Key(4)] int StepCount,
    [property: Key(5)] int StepTicks,
    [property: Key(6)] CanonicalTick StartTick,
    [property: Key(7)] IntegrationDirection Direction
);


// --- PATH: hosts/Geosphere.Plate.SolverLab.Core/Corpus/SolverCorpus.cs ---
using System.Collections.Immutable;

namespace FantaSim.Geosphere.Plate.SolverLab.Core.Corpus;

public sealed class SolverCorpus
{
    public required string Domain { get; init; }           // e.g., "PlateMotion"
    public required string Version { get; init; }          // Corpus format version
    public required CorpusCase[] Cases { get; init; }
}


// --- PATH: hosts/Geosphere.Plate.SolverLab.Core/Registry/SolverRegistry.cs ---
using FantaSim.Geosphere.Plate.Topology.Contracts.Simulation;

namespace FantaSim.Geosphere.Plate.SolverLab.Core.Registry;

internal interface ISolverFactory
{
    object Create();
}

internal class SolverFactory<TSolver, TInput, TOutput> : ISolverFactory
    where TSolver : ISolver<TInput, TOutput>, new()
{
    public object Create() => new TSolver();
}

public sealed class SolverRegistry
{
    private readonly Dictionary<string, ISolverFactory> _factories = new();
    private readonly Dictionary<string, string> _activeVariants = new();

    /// <summary>
    /// Register a solver implementation.
    /// </summary>
    public void Register<TSolver, TInput, TOutput>(string domain, string variant)
        where TSolver : ISolver<TInput, TOutput>, new()
    {
        var key = $"{domain}:{variant}";
        _factories[key] = new SolverFactory<TSolver, TInput, TOutput>();
    }

    /// <summary>
    /// Set the active variant for a domain.
    /// </summary>
    public void SetActiveVariant(string domain, string variant)
    {
        _activeVariants[domain] = variant;
    }

    /// <summary>
    /// Get the active solver for a domain.
    /// </summary>
    public ISolver<TInput, TOutput> GetSolver<TInput, TOutput>(string domain)
    {
        var variant = _activeVariants.GetValueOrDefault(domain, "Reference");
        var key = $"{domain}:{variant}";

        if (!_factories.TryGetValue(key, out var factory))
        {
            throw new KeyNotFoundException($"No solver registered for domain '{domain}' with variant '{variant}'");
        }

        return (ISolver<TInput, TOutput>)factory.Create();
    }
}


// --- PATH: hosts/Geosphere.Plate.SolverLab.Core/Solvers/Reference/ReferencePlateMotionSolver.cs ---
using System.Collections.Immutable;
using System.Diagnostics;
using FantaSim.Geosphere.Plate.Topology.Contracts.Simulation;
using FantaSim.Geosphere.Plate.Topology.Contracts.Numerics;
using FantaSim.Geosphere.Plate.Topology.Contracts.Entities;

namespace FantaSim.Geosphere.Plate.SolverLab.Core.Solvers.Reference;

/// <summary>
/// Reference implementation of plate motion solver.
/// Prioritizes correctness and readability over performance.
/// </summary>
public sealed class ReferencePlateMotionSolver : IPlateMotionSolver
{
    public SolverMetadata Metadata => new()
    {
        Name = "Reference",
        Version = "1.0.0",
        Description = "Naive O(n²) force calculation, readable but slow",
        Complexity = "O(n²)"
    };

    public PlateMotionResult Calculate(PlateMotionInput input) => Calculate(input.Snapshot, input.TimeDeltaS);

    public PlateMotionResult Calculate(PlateMechanicsSnapshot topology, float dt)
    {
        var sw = Stopwatch.StartNew();
        var motions = new List<PlateMotion>();

        // Calculate forces on each plate
        foreach (var plate in topology.Plates)
        {
            var force = CalculateNetForce(plate, topology);
            var motion = IntegrateMotion(plate, force, dt);
            motions.Add(motion);
        }

        // Detect topology changes
        var rifts = DetectRifts(topology, motions);
        var collisions = DetectCollisions(topology, motions);

        sw.Stop();

        return new PlateMotionResult
        {
            PlateMotions = motions.ToArray(),
            NewRifts = rifts.ToArray(),
            NewCollisions = collisions.ToArray(),
            Metrics = new ComputationMetrics
            {
                ComputeTimeMs = sw.Elapsed.TotalMilliseconds,
                IterationCount = 1,
                ConvergenceError = 0
            }
        };
    }

    private Vector3d CalculateNetForce(PlateSnapshot plate, PlateMechanicsSnapshot topology)
    {
        var force = Vector3d.Zero;

        // Ridge push (from divergent boundaries)
        foreach (var boundary in topology.Boundaries.Where(b =>
            b.Type == BoundaryType.Divergent &&
            (b.PlateA == plate.PlateId || b.PlateB == plate.PlateId)))
        {
            force += CalculateRidgePush(plate, boundary);
        }

        // Slab pull (from subducting boundaries)
        foreach (var boundary in topology.Boundaries.Where(b =>
            b.Type == BoundaryType.Convergent &&
            b.SubductingPlate == plate.PlateId))
        {
            force += CalculateSlabPull(plate, boundary);
        }

        // Mantle drag (resistance)
        force += CalculateMantleDrag(plate);

        return force;
    }

    private Vector3d CalculateRidgePush(PlateSnapshot plate, BoundarySnapshot boundary)
    {
        // Placeholder logic
        return Vector3d.UnitX * 1000.0;
    }

    private Vector3d CalculateSlabPull(PlateSnapshot plate, BoundarySnapshot boundary)
    {
        // Placeholder logic
        return Vector3d.UnitY * 2000.0;
    }

    private Vector3d CalculateMantleDrag(PlateSnapshot plate)
    {
        // Placeholder logic: oppose motion (simplified as generic drag for now)
        return Vector3d.Zero; // Needs velocity state which we don't track in snapshot currently, assuming static start or implicitly handled
    }

    private PlateMotion IntegrateMotion(PlateSnapshot plate, Vector3d force, float dt)
    {
        // Simple Euler integration
        // F = ma -> a = F/m
        var acceleration = force / plate.MassKg;
        var deltaPosition = acceleration * dt * dt * 0.5;

        // Angular motion from torque
        var torque = CalculateTorque(plate, force);

        // Simplified inertia for thin shell sphere approx
        double inertia = plate.MassKg * plate.AreaM2 / 12.0;

        // Avoid divide by zero
        if (inertia < 1e-9) inertia = 1.0;

        var angularAccel = torque / inertia;
        // Approximation: torque direction is axis of rotation
        var deltaRotation = Quaterniond.FromAxisAngle(Vector3d.UnitZ, angularAccel.Length() * dt * dt * 0.5);

        return new PlateMotion
        {
            PlateId = plate.PlateId,
            DeltaPosition = deltaPosition,
            DeltaRotation = deltaRotation,
            Force = force,
            Torque = torque
        };
    }

    private Vector3d CalculateTorque(PlateSnapshot plate, Vector3d force)
    {
        // Placeholder: Torque = r x F
        // Assuming force applied at some offset from center of mass
        return Vector3d.Zero;
    }

    private List<RiftEvent> DetectRifts(PlateMechanicsSnapshot topology, List<PlateMotion> motions)
    {
        // Placeholder
        return new List<RiftEvent>();
    }

    private List<CollisionEvent> DetectCollisions(PlateMechanicsSnapshot topology, List<PlateMotion> motions)
    {
        // Placeholder
        return new List<CollisionEvent>();
    }
}


// --- PATH: hosts/Geosphere.Plate.SolverLab.Runner/BoundaryVelocityCorpusGenerator.cs ---
using System.Collections.Immutable;
using TimeDete = Plate.TimeDete.Time.Primitives;
using FantaSim.Geosphere.Plate.Kinematics.Contracts.Derived;
using FantaSim.Geosphere.Plate.Topology.Contracts.Derived;
using FantaSim.Geosphere.Plate.Topology.Contracts.Entities;
using FantaSim.Geosphere.Plate.Topology.Contracts.Identity;
using FantaSim.Geosphere.Plate.Topology.Contracts.Numerics;
using FantaSim.Geosphere.Plate.SolverLab.Core.Corpus;
using FantaSim.Geosphere.Plate.Velocity.Contracts;
using FantaSim.Geosphere.Plate.Velocity.Solver;
using MessagePack;
using UnifyGeometry;

namespace FantaSim.Geosphere.Plate.SolverLab.Runner;

using CanonicalTick = TimeDete.CanonicalTick;

/// <summary>
/// Generates Solver Lab corpus cases for RFC-V2-0034 Boundary Velocity analysis.
/// </summary>
public static class BoundaryVelocityCorpusGenerator
{
    private static readonly TimeDete.CanonicalTick DefaultTick = new TimeDete.CanonicalTick(1000);
    private static readonly BoundarySamplingSpec DefaultSampling = new(32, SamplingMode.ArcLength, true);

    /// <summary>
    /// Generates the complete boundary velocity corpus with 3 test cases.
    /// </summary>
    public static SolverCorpus GenerateCorpus(MessagePackSerializerOptions options)
    {
        return new SolverCorpus
        {
            Domain = "BoundaryVelocity",
            Version = "1.0",
            Cases = new[]
            {
                CreateCase001(options),
                CreateCase002(options),
                CreateCase003(options)
            }
        };
    }

    /// <summary>
    /// Case 1: Simple Divergent Boundary (Ridge)
    /// Two plates separating along a north-south trending boundary.
    /// Expected: MeanNormalRate > 0 (opening), MeanSlipRate ≈ 0
    /// </summary>
    private static CorpusCase CreateCase001(MessagePackSerializerOptions options)
    {
        // Deterministic plate IDs
        var plateId1 = new PlateId(Guid.Parse("00000001-0000-0000-0000-000000000001"));
        var plateId2 = new PlateId(Guid.Parse("00000001-0000-0000-0000-000000000002"));
        var boundaryId = new BoundaryId(Guid.Parse("00000001-0000-0000-0000-000000000003"));

        // Angular velocities: both rotating counter-clockwise around X axis (ω = 0.5, 0, 0)
        // This creates divergence at the boundary
        var omega1 = new AngularVelocity3d(0.5, 0, 0);
        var omega2 = new AngularVelocity3d(0.5, 0, 0);

        // Create boundary: Great circle arc at longitude 0°, latitudes ±30°
        var boundary = CreateBoundary(
            boundaryId,
            plateId1,
            plateId2,
            BoundaryType.Divergent,
            CreateGreatCircleArc(0.0, -30.0, 0.0, 30.0));

        // Create mock state views
        var topology = new MockTopologyStateView(new Dictionary<PlateId, Topology.Contracts.Entities.Plate>
        {
            [plateId1] = new Topology.Contracts.Entities.Plate(plateId1, false, null),
            [plateId2] = new Topology.Contracts.Entities.Plate(plateId2, false, null)
        }, new Dictionary<BoundaryId, Boundary>
        {
            [boundaryId] = boundary
        });

        var kinematics = new MockKinematicsStateView(new Dictionary<PlateId, AngularVelocity3d>
        {
            [plateId1] = omega1,
            [plateId2] = omega2
        });

        // Create solver and compute expected output
        var velocitySolver = new FiniteRotationPlateVelocitySolver();
        var boundarySolver = new RigidBoundaryVelocitySolver(velocitySolver);

        var expected = boundarySolver.AnalyzeAllBoundaries(
            new[] { boundary },
            DefaultSampling,
            DefaultTick,
            topology,
            kinematics);

        // Create input structure (boundary + sampling spec + tick)
        var input = new BoundaryVelocityInput(
            boundary,
            DefaultSampling,
            DefaultTick,
            topology,
            kinematics);

        return new CorpusCase
        {
            CaseId = "case-001-simple-ridge",
            Description = "Simple divergent boundary (mid-ocean ridge) - two plates with same rotation create opening",
            Difficulty = CaseDifficulty.Normal,
            Tags = new[] { "divergent", "ridge", "opening", "rfc-v2-0034" },
            InputData = MessagePackSerializer.Serialize(input, options),
            ExpectedOutput = MessagePackSerializer.Serialize(expected, options)
        };
    }

    /// <summary>
    /// Case 2: Subduction Zone (Convergent)
    /// Two plates converging.
    /// Expected: MeanNormalRate < 0 (closing)
    /// </summary>
    private static CorpusCase CreateCase002(MessagePackSerializerOptions options)
    {
        // Deterministic plate IDs
        var plateId1 = new PlateId(Guid.Parse("00000002-0000-0000-0000-000000000001"));
        var plateId2 = new PlateId(Guid.Parse("00000002-0000-0000-0000-000000000002"));
        var boundaryId = new BoundaryId(Guid.Parse("00000002-0000-0000-0000-000000000003"));

        // Angular velocities: opposite rotations create convergence
        // Plate 1: ω = (0.5, 0, 0) - counter-clockwise around X
        // Plate 2: ω = (-0.5, 0, 0) - clockwise around X
        var omega1 = new AngularVelocity3d(0.5, 0, 0);
        var omega2 = new AngularVelocity3d(-0.5, 0, 0);

        // Create boundary: Great circle arc at longitude 90°, latitudes ±30°
        var boundary = CreateBoundary(
            boundaryId,
            plateId1,
            plateId2,
            BoundaryType.Convergent,
            CreateGreatCircleArc(90.0, -30.0, 90.0, 30.0));

        // Create mock state views
        var topology = new MockTopologyStateView(new Dictionary<PlateId, Topology.Contracts.Entities.Plate>
        {
            [plateId1] = new Topology.Contracts.Entities.Plate(plateId1, false, null),
            [plateId2] = new Topology.Contracts.Entities.Plate(plateId2, false, null)
        }, new Dictionary<BoundaryId, Boundary>
        {
            [boundaryId] = boundary
        });

        var kinematics = new MockKinematicsStateView(new Dictionary<PlateId, AngularVelocity3d>
        {
            [plateId1] = omega1,
            [plateId2] = omega2
        });

        // Create solver and compute expected output
        var velocitySolver = new FiniteRotationPlateVelocitySolver();
        var boundarySolver = new RigidBoundaryVelocitySolver(velocitySolver);

        var expected = boundarySolver.AnalyzeAllBoundaries(
            new[] { boundary },
            DefaultSampling,
            DefaultTick,
            topology,
            kinematics);

        // Create input structure
        var input = new BoundaryVelocityInput(
            boundary,
            DefaultSampling,
            DefaultTick,
            topology,
            kinematics);

        return new CorpusCase
        {
            CaseId = "case-002-subduction-zone",
            Description = "Subduction zone (convergent boundary) - opposite rotations create closing",
            Difficulty = CaseDifficulty.Normal,
            Tags = new[] { "convergent", "subduction", "closing", "rfc-v2-0034" },
            InputData = MessagePackSerializer.Serialize(input, options),
            ExpectedOutput = MessagePackSerializer.Serialize(expected, options)
        };
    }

    /// <summary>
    /// Case 3: Transform Fault
    /// Two plates sliding past each other.
    /// Expected: MeanNormalRate ≈ 0 (no opening/closing), MeanSlipRate > 0
    /// </summary>
    private static CorpusCase CreateCase003(MessagePackSerializerOptions options)
    {
        // Deterministic plate IDs
        var plateId1 = new PlateId(Guid.Parse("00000003-0000-0000-0000-000000000001"));
        var plateId2 = new PlateId(Guid.Parse("00000003-0000-0000-0000-000000000002"));
        var boundaryId = new BoundaryId(Guid.Parse("00000003-0000-0000-0000-000000000003"));

        // Angular velocities: both rotating around Z axis in opposite directions
        // This creates strike-slip motion at the equator
        // Plate 1: ω = (0, 0, 0.5) - counter-clockwise around Z
        // Plate 2: ω = (0, 0, -0.5) - clockwise around Z
        var omega1 = new AngularVelocity3d(0, 0, 0.5);
        var omega2 = new AngularVelocity3d(0, 0, -0.5);

        // Create boundary: Great circle along equator from lon 0° to 90°
        var boundary = CreateBoundary(
            boundaryId,
            plateId1,
            plateId2,
            BoundaryType.Transform,
            CreateGreatCircleArc(0.0, 0.0, 90.0, 0.0));

        // Create mock state views
        var topology = new MockTopologyStateView(new Dictionary<PlateId, Topology.Contracts.Entities.Plate>
        {
            [plateId1] = new Topology.Contracts.Entities.Plate(plateId1, false, null),
            [plateId2] = new Topology.Contracts.Entities.Plate(plateId2, false, null)
        }, new Dictionary<BoundaryId, Boundary>
        {
            [boundaryId] = boundary
        });

        var kinematics = new MockKinematicsStateView(new Dictionary<PlateId, AngularVelocity3d>
        {
            [plateId1] = omega1,
            [plateId2] = omega2
        });

        // Create solver and compute expected output
        var velocitySolver = new FiniteRotationPlateVelocitySolver();
        var boundarySolver = new RigidBoundaryVelocitySolver(velocitySolver);

        var expected = boundarySolver.AnalyzeAllBoundaries(
            new[] { boundary },
            DefaultSampling,
            DefaultTick,
            topology,
            kinematics);

        // Create input structure
        var input = new BoundaryVelocityInput(
            boundary,
            DefaultSampling,
            DefaultTick,
            topology,
            kinematics);

        return new CorpusCase
        {
            CaseId = "case-003-transform-fault",
            Description = "Transform fault (strike-slip boundary) - opposite Z rotations create lateral sliding",
            Difficulty = CaseDifficulty.Normal,
            Tags = new[] { "transform", "strike-slip", "sliding", "rfc-v2-0034" },
            InputData = MessagePackSerializer.Serialize(input, options),
            ExpectedOutput = MessagePackSerializer.Serialize(expected, options)
        };
    }

    /// <summary>
    /// Creates a Boundary with the specified parameters.
    /// </summary>
    private static Boundary CreateBoundary(
        BoundaryId id,
        PlateId leftPlateId,
        PlateId rightPlateId,
        BoundaryType type,
        Polyline3 geometry)
    {
        return new Boundary(id, leftPlateId, rightPlateId, type, geometry, false, null);
    }

    /// <summary>
    /// Creates a great circle arc as a Polyline3 with intermediate vertices.
    /// Lat/lon in degrees.
    /// </summary>
    private static Polyline3 CreateGreatCircleArc(double lon1, double lat1, double lon2, double lat2)
    {
        const int segments = 4;
        var points = new Point3[segments + 1];

        var start = LatLonToPoint3(lat1, lon1);
        var end = LatLonToPoint3(lat2, lon2);

        for (int i = 0; i <= segments; i++)
        {
            double t = i / (double)segments;
            points[i] = GreatCircleInterpolate(start, end, t);
        }

        return new Polyline3(points);
    }

    /// <summary>
    /// Converts latitude/longitude (degrees) to Point3 on unit sphere.
    /// </summary>
    private static Point3 LatLonToPoint3(double lat, double lon)
    {
        double latRad = lat * Math.PI / 180.0;
        double lonRad = lon * Math.PI / 180.0;

        double x = Math.Cos(latRad) * Math.Cos(lonRad);
        double y = Math.Cos(latRad) * Math.Sin(lonRad);
        double z = Math.Sin(latRad);

        return new Point3(x, y, z);
    }

    /// <summary>
    /// Interpolates along a great circle between two points on the unit sphere.
    /// </summary>
    private static Point3 GreatCircleInterpolate(Point3 a, Point3 b, double t)
    {
        double ax = a.X, ay = a.Y, az = a.Z;
        double bx = b.X, by = b.Y, bz = b.Z;

        double dot = ax * bx + ay * by + az * bz;
        dot = Math.Clamp(dot, -1.0, 1.0);

        double angle = Math.Acos(dot);

        if (angle < 1e-10)
            return a;

        double sinAngle = Math.Sin(angle);
        double wa = Math.Sin((1 - t) * angle) / sinAngle;
        double wb = Math.Sin(t * angle) / sinAngle;

        double x = wa * ax + wb * bx;
        double y = wa * ay + wb * by;
        double z = wa * az + wb * bz;

        return new Point3(x, y, z);
    }

    /// <summary>
    /// Input structure for boundary velocity corpus cases.
    /// </summary>
    [MessagePackObject]
    public readonly record struct BoundaryVelocityInput(
        [property: Key(0)] Topology.Contracts.Entities.Boundary Boundary,
        [property: Key(1)] BoundarySamplingSpec Sampling,
        [property: Key(2)] TimeDete.CanonicalTick Tick,
        [property: Key(3)] MockTopologyStateView Topology,
        [property: Key(4)] MockKinematicsStateView Kinematics
    );

    /// <summary>
    /// Mock implementation of IPlateTopologyStateView for corpus generation.
    /// </summary>
    [MessagePackObject]
    public class MockTopologyStateView : IPlateTopologyStateView
    {
        [Key(0)]
        public TruthStreamIdentity Identity { get; init; } = new("test", "trunk", 1, Domain.Parse("geo.plates.test"), "0");

        [Key(1)]
        public ImmutableDictionary<PlateId, Topology.Contracts.Entities.Plate> Plates { get; init; }

        [Key(2)]
        public ImmutableDictionary<BoundaryId, Topology.Contracts.Entities.Boundary> Boundaries { get; init; }

        [Key(3)]
        public ImmutableDictionary<JunctionId, Topology.Contracts.Entities.Junction> Junctions { get; init; } = ImmutableDictionary<JunctionId, Topology.Contracts.Entities.Junction>.Empty;

        [Key(4)]
        public long LastEventSequence { get; init; } = 0;

        // Non-serialized interface implementations
        [IgnoreMember]
        IReadOnlyDictionary<PlateId, Topology.Contracts.Entities.Plate> IPlateTopologyStateView.Plates => Plates;

        [IgnoreMember]
        IReadOnlyDictionary<BoundaryId, Topology.Contracts.Entities.Boundary> IPlateTopologyStateView.Boundaries => Boundaries;

        [IgnoreMember]
        IReadOnlyDictionary<JunctionId, Topology.Contracts.Entities.Junction> IPlateTopologyStateView.Junctions => Junctions;

        public MockTopologyStateView()
        {
            Plates = ImmutableDictionary<PlateId, Topology.Contracts.Entities.Plate>.Empty;
            Boundaries = ImmutableDictionary<BoundaryId, Topology.Contracts.Entities.Boundary>.Empty;
        }

        public MockTopologyStateView(Dictionary<PlateId, Topology.Contracts.Entities.Plate> plates, Dictionary<BoundaryId, Topology.Contracts.Entities.Boundary> boundaries)
        {
            Plates = plates.ToImmutableDictionary();
            Boundaries = boundaries.ToImmutableDictionary();
        }
    }

    /// <summary>
    /// Mock implementation of IPlateKinematicsStateView for corpus generation.
    /// Returns constant angular velocities for plates.
    /// </summary>
    [MessagePackObject]
    public class MockKinematicsStateView : IPlateKinematicsStateView
    {
        [Key(0)]
        public TruthStreamIdentity Identity { get; init; } = new("test", "trunk", 1, Domain.Parse("geo.plates.kinematics.test"), "0");

        [Key(1)]
        public long LastEventSequence { get; init; } = 0;

        [Key(2)]
        public ImmutableDictionary<PlateId, AngularVelocity3d> AngularVelocities { get; init; }

        public MockKinematicsStateView()
        {
            AngularVelocities = ImmutableDictionary<PlateId, AngularVelocity3d>.Empty;
        }

        public MockKinematicsStateView(Dictionary<PlateId, AngularVelocity3d> angularVelocities)
        {
            AngularVelocities = angularVelocities.ToImmutableDictionary();
        }

        public bool TryGetRotation(PlateId plateId, TimeDete.CanonicalTick tick, out Quaterniond rotation)
        {
            // Compute rotation from angular velocity: θ = ω * t
            // For corpus generation, we use a simple linear rotation model
            if (AngularVelocities.TryGetValue(plateId, out var omega))
            {
                double angle = omega.Rate() * tick.Value;
                if (angle > 0)
                {
                    var (axisX, axisY, axisZ) = omega.GetAxis();
                    rotation = Quaterniond.FromAxisAngle(new Vector3d(axisX, axisY, axisZ), angle);
                    return true;
                }
            }

            rotation = Quaterniond.Identity;
            return false;
        }
    }
}


// --- PATH: hosts/Geosphere.Plate.SolverLab.Runner/CorpusGenerator.cs ---
using System.Collections.Immutable;
using FantaSim.Geosphere.Plate.SolverLab.Core.Corpus;
using FantaSim.Geosphere.Plate.Topology.Contracts.Simulation;
using FantaSim.Geosphere.Plate.Topology.Contracts.Numerics;
using FantaSim.Geosphere.Plate.SolverLab.Core.Solvers.Reference;
using FantaSim.Geosphere.Plate.Topology.Contracts.Entities;
using MessagePack;

namespace FantaSim.Geosphere.Plate.SolverLab.Runner;

public static class CorpusGenerator
{
    public static SolverCorpus GenerateSampleCorpus(MessagePackSerializerOptions options)
    {
        var cases = new List<CorpusCase>();

        // Case 1: Trivial - Single stationary plate, no forces
        cases.Add(CreateTrivialCase(options));

        // Case 2: Two Divergent Plates
        cases.Add(CreateDivergentCase(options));

        return new SolverCorpus
        {
            Domain = "PlateMotion",
            Version = "1.0",
            Cases = cases.ToArray()
        };
    }

    private static CorpusCase CreateTrivialCase(MessagePackSerializerOptions options)
    {
        var plateId = PlateId.NewId();
        var snapshot = new PlateMechanicsSnapshot
        {
            CurrentTimeS = 0,
            Plates = new[]
            {
                new PlateSnapshot
                {
                    PlateId = plateId,
                    Position = Vector3d.UnitX * 6371000, // Surface
                    Rotation = Quaterniond.Identity,
                    MassKg = 1e22,
                    AreaM2 = 1e12,
                    Type = PlateType.Oceanic
                }
            },
            Boundaries = Array.Empty<BoundarySnapshot>()
        };

        var input = new PlateMotionInput
        {
            Snapshot = snapshot,
            TimeDeltaS = 1.0f
        };

        // Expected: No motion
        var expectedResult = new PlateMotionResult
        {
            PlateMotions = new[]
            {
                new PlateMotion
                {
                    PlateId = plateId,
                    DeltaPosition = Vector3d.Zero,
                    DeltaRotation = Quaterniond.Identity,
                    Force = Vector3d.Zero,
                    Torque = Vector3d.Zero
                }
            },
            NewRifts = Array.Empty<RiftEvent>(),
            NewCollisions = Array.Empty<CollisionEvent>(),
            Metrics = new ComputationMetrics { ComputeTimeMs = 0, ConvergenceError = 0, IterationCount = 0 }
        };

        return new CorpusCase
        {
            CaseId = "case-001",
            Description = "Trivial stationary plate",
            Difficulty = CaseDifficulty.Trivial,
            Tags = new[] { "sanity" },
            InputData = MessagePackSerializer.Serialize(input, options),
            ExpectedOutput = MessagePackSerializer.Serialize(expectedResult, options)
        };
    }

    private static CorpusCase CreateDivergentCase(MessagePackSerializerOptions options)
    {
        var p1 = PlateId.NewId();
        var p2 = PlateId.NewId();
        var b1 = BoundaryId.NewId();

        var snapshot = new PlateMechanicsSnapshot
        {
            CurrentTimeS = 0,
            Plates = new[]
            {
                new PlateSnapshot
                {
                    PlateId = p1,
                    Position = Vector3d.UnitX * 6371000,
                    Rotation = Quaterniond.Identity,
                    MassKg = 1e22,
                    AreaM2 = 1e12,
                    Type = PlateType.Oceanic
                },
                new PlateSnapshot
                {
                    PlateId = p2,
                    Position = -Vector3d.UnitX * 6371000,
                    Rotation = Quaterniond.Identity,
                    MassKg = 1e22,
                    AreaM2 = 1e12,
                    Type = PlateType.Oceanic
                }
            },
            Boundaries = new[]
            {
                new BoundarySnapshot
                {
                    BoundaryId = b1,
                    PlateA = p1,
                    PlateB = p2,
                    Type = BoundaryType.Divergent,
                    SubductingPlate = default
                }
            }
        };

        var input = new PlateMotionInput
        {
            Snapshot = snapshot,
            TimeDeltaS = 1.0f
        };

        // Use Reference Solver to generate Ground Truth
        var solver = new ReferencePlateMotionSolver();
        var result = solver.Calculate(input);

        return new CorpusCase
        {
            CaseId = "case-002",
            Description = "Simple divergence (Generated by Reference Solver)",
            Difficulty = CaseDifficulty.Normal,
            Tags = new[] { "physics", "generated" },
            InputData = MessagePackSerializer.Serialize(input, options),
            ExpectedOutput = MessagePackSerializer.Serialize(result, options)
        };
    }
}


// --- PATH: hosts/Geosphere.Plate.SolverLab.Runner/FlowlineCorpusGenerator.cs ---
using System.Collections.Immutable;
using TimeDete = Plate.TimeDete.Time.Primitives;
using FantaSim.Geosphere.Plate.Kinematics.Contracts.Derived;
using FantaSim.Geosphere.Plate.Topology.Contracts.Derived;
using FantaSim.Geosphere.Plate.Topology.Contracts.Entities;
using FantaSim.Geosphere.Plate.Topology.Contracts.Numerics;
using FantaSim.Geosphere.Plate.SolverLab.Core.Corpus;
using FantaSim.Geosphere.Plate.Velocity.Contracts;
using FantaSim.Geosphere.Plate.Velocity.Solver;
using FantaSim.Geosphere.Plate.Motion.Contracts;
using FantaSim.Geosphere.Plate.Motion.Solver;
using MessagePack;
using UnifyGeometry;

namespace FantaSim.Geosphere.Plate.SolverLab.Runner;

using CanonicalTick = TimeDete.CanonicalTick;
using Topology = FantaSim.Geosphere.Plate.Topology.Contracts;

/// <summary>
/// Generates Solver Lab corpus cases for RFC-V2-0035 Flowline analysis.
/// </summary>
public static class FlowlineCorpusGenerator
{
    /// <summary>
    /// Generates the complete flowline corpus with divergent boundary cases.
    /// </summary>
    public static SolverCorpus GenerateCorpus(MessagePackSerializerOptions options)
    {
        return new SolverCorpus
        {
            Domain = "Flowline",
            Version = "1.0",
            Cases = new[]
            {
                CreateDivergentRidgeCase(options)
            }
        };
    }

    /// <summary>
    /// Case 1: Divergent Ridge Flowline
    /// Two plates diverging at a ridge boundary, with a seed point at the ridge center.
    /// Expected: Flowline shows the point moving away from the ridge on each plate.
    /// </summary>
    private static CorpusCase CreateDivergentRidgeCase(MessagePackSerializerOptions options)
    {
        // Deterministic IDs
        var leftPlateId = new PlateId(Guid.Parse("00000020-0000-0000-0000-000000000001"));
        var rightPlateId = new PlateId(Guid.Parse("00000020-0000-0000-0000-000000000002"));
        var boundaryId = new BoundaryId(Guid.Parse("00000020-0000-0000-0000-000000000003"));

        // Ridge position: equator at prime meridian (0°, 0°)
        var ridgeCenter = new Vector3d(1.0, 0.0, 0.0);

        // Divergent velocity configuration:
        // Left plate rotates CCW around Z (positive ωz)
        // Right plate rotates CW around Z (negative ωz)
        // This creates opposite velocities at the boundary (divergence)
        var leftOmega = new AngularVelocity3d(0.0, 0.0, 0.1);
        var rightOmega = new AngularVelocity3d(0.0, 0.0, -0.1);

        // Integration parameters
        const int stepCount = 10;
        const int stepTicks = 1;
        var startTick = new TimeDete.CanonicalTick(1000);
        var endTick = new TimeDete.CanonicalTick(startTick.Value + (stepCount * stepTicks));
        var direction = IntegrationDirection.Forward;

        // Create boundary: simple ridge at equator
        var boundary = CreateBoundary(
            boundaryId,
            leftPlateId,
            rightPlateId,
            BoundaryType.Divergent,
            CreateGreatCircleArc(0.0, -10.0, 0.0, 10.0));

        // Create seed sample at ridge center
        // For a divergent boundary, relative velocity points outward from boundary
        // Left plate moves "up" (positive Y), right plate moves "down" (negative Y)
        var seedSample = new BoundaryVelocitySample(
            ridgeCenter,
            new Velocity3d(0.0, 0.1, 0.0),  // Relative velocity at ridge
            new Vector3d(0.0, 0.0, 1.0),     // Tangent (Z-axis, along ridge)
            new Vector3d(0.0, 1.0, 0.0),     // Normal (Y-axis, across ridge)
            0.1,                              // Tangential rate
            0.1,                              // Normal rate (positive = opening)
            0);                               // Sample index

        // Create mock state views
        var topology = new MockTopologyStateView(
            new Dictionary<PlateId, Topology.Entities.Plate>
            {
                [leftPlateId] = new Topology.Entities.Plate(leftPlateId, false, null),
                [rightPlateId] = new Topology.Entities.Plate(rightPlateId, false, null)
            },
            new Dictionary<BoundaryId, Topology.Entities.Boundary>
            {
                [boundaryId] = boundary
            });

        var kinematics = new MockKinematicsStateView(
            new Dictionary<PlateId, AngularVelocity3d>
            {
                [leftPlateId] = leftOmega,
                [rightPlateId] = rightOmega
            });

        // Create solvers
        var velocitySolver = new FiniteRotationPlateVelocitySolver();
        var flowlineSolver = new EulerFlowlineSolver(velocitySolver);

        // Compute flowline for left plate side
        var leftFlowline = flowlineSolver.ComputeFlowline(
            boundaryId,
            seedSample,
            PlateSide.Left,
            startTick,
            endTick,
            direction,
            topology,
            kinematics,
            new MotionIntegrationSpec(stepTicks, stepCount));

        // Create input structure
        var input = new FlowlineInput(
            boundaryId,
            seedSample,
            leftPlateId,
            rightPlateId,
            PlateSide.Left,  // Testing the left plate side
            stepCount,
            stepTicks,
            startTick,
            direction);

        // Create the entry
        var entry = new FlowlineCorpusEntry
        {
            CaseId = "case-001-divergent-ridge",
            Description = "Divergent ridge flowline - two plates with opposite rotations create opening at boundary, flowline traces path away from ridge",
            Input = input,
            ExpectedOutput = leftFlowline,
            Difficulty = CaseDifficulty.Normal,
            Tags = new[] { "flowline", "divergent", "ridge", "boundary", "rfc-v2-0035" }
        };

        return new CorpusCase
        {
            CaseId = entry.CaseId,
            Description = entry.Description,
            Difficulty = entry.Difficulty,
            Tags = entry.Tags,
            InputData = MessagePackSerializer.Serialize(input, options),
            ExpectedOutput = MessagePackSerializer.Serialize(leftFlowline, options)
        };
    }

    /// <summary>
    /// Creates a Boundary with the specified parameters.
    /// </summary>
    private static Topology.Entities.Boundary CreateBoundary(
        BoundaryId id,
        PlateId leftPlateId,
        PlateId rightPlateId,
        BoundaryType type,
        Polyline3 geometry)
    {
        return new Topology.Entities.Boundary(id, leftPlateId, rightPlateId, type, geometry, false, null);
    }

    /// <summary>
    /// Creates a great circle arc as a Polyline3 with intermediate vertices.
    /// Lat/lon in degrees.
    /// </summary>
    private static Polyline3 CreateGreatCircleArc(double lon1, double lat1, double lon2, double lat2)
    {
        const int segments = 4;
        var points = new Point3[segments + 1];

        var start = LatLonToPoint3(lat1, lon1);
        var end = LatLonToPoint3(lat2, lon2);

        for (int i = 0; i <= segments; i++)
        {
            double t = i / (double)segments;
            points[i] = GreatCircleInterpolate(start, end, t);
        }

        return new Polyline3(points);
    }

    /// <summary>
    /// Converts latitude/longitude (degrees) to Point3 on unit sphere.
    /// </summary>
    private static Point3 LatLonToPoint3(double lat, double lon)
    {
        double latRad = lat * Math.PI / 180.0;
        double lonRad = lon * Math.PI / 180.0;

        double x = Math.Cos(latRad) * Math.Cos(lonRad);
        double y = Math.Cos(latRad) * Math.Sin(lonRad);
        double z = Math.Sin(latRad);

        return new Point3(x, y, z);
    }

    /// <summary>
    /// Interpolates along a great circle between two points on the unit sphere.
    /// </summary>
    private static Point3 GreatCircleInterpolate(Point3 a, Point3 b, double t)
    {
        double ax = a.X, ay = a.Y, az = a.Z;
        double bx = b.X, by = b.Y, bz = b.Z;

        double dot = ax * bx + ay * by + az * bz;
        dot = Math.Clamp(dot, -1.0, 1.0);

        double angle = Math.Acos(dot);

        if (angle < 1e-10)
            return a;

        double sinAngle = Math.Sin(angle);
        double wa = Math.Sin((1 - t) * angle) / sinAngle;
        double wb = Math.Sin(t * angle) / sinAngle;

        double x = wa * ax + wb * bx;
        double y = wa * ay + wb * by;
        double z = wa * az + wb * bz;

        return new Point3(x, y, z);
    }
}


// --- PATH: hosts/Geosphere.Plate.SolverLab.Runner/MockStateViews.cs ---
using System.Collections.Immutable;
using TimeDete = Plate.TimeDete.Time.Primitives;
using FantaSim.Geosphere.Plate.Kinematics.Contracts.Derived;
using FantaSim.Geosphere.Plate.Topology.Contracts.Derived;
using FantaSim.Geosphere.Plate.Topology.Contracts.Entities;
using FantaSim.Geosphere.Plate.Topology.Contracts.Identity;
using FantaSim.Geosphere.Plate.Topology.Contracts.Numerics;
using FantaSim.Geosphere.Plate.Velocity.Contracts;
using MessagePack;

namespace FantaSim.Geosphere.Plate.SolverLab.Runner;

using CanonicalTick = TimeDete.CanonicalTick;
using Topology = FantaSim.Geosphere.Plate.Topology.Contracts;

/// <summary>
/// Mock implementation of IPlateTopologyStateView for corpus generation.
/// </summary>
[MessagePackObject]
public class MockTopologyStateView : IPlateTopologyStateView
{
    [Key(0)]
    public TruthStreamIdentity Identity { get; init; } = new("test", "trunk", 1, Domain.Parse("geo.plates.test"), "0");

    [Key(1)]
    public ImmutableDictionary<PlateId, Topology.Entities.Plate> Plates { get; init; }

    [Key(2)]
    public ImmutableDictionary<BoundaryId, Topology.Entities.Boundary> Boundaries { get; init; }

    [Key(3)]
    public ImmutableDictionary<JunctionId, Topology.Entities.Junction> Junctions { get; init; } = ImmutableDictionary<JunctionId, Topology.Entities.Junction>.Empty;

    [Key(4)]
    public long LastEventSequence { get; init; } = 0;

    // Non-serialized interface implementations
    [IgnoreMember]
    IReadOnlyDictionary<PlateId, Topology.Entities.Plate> IPlateTopologyStateView.Plates => Plates;

    [IgnoreMember]
    IReadOnlyDictionary<BoundaryId, Topology.Entities.Boundary> IPlateTopologyStateView.Boundaries => Boundaries;

    [IgnoreMember]
    IReadOnlyDictionary<JunctionId, Topology.Entities.Junction> IPlateTopologyStateView.Junctions => Junctions;

    public MockTopologyStateView()
    {
        Plates = ImmutableDictionary<PlateId, Topology.Entities.Plate>.Empty;
        Boundaries = ImmutableDictionary<BoundaryId, Topology.Entities.Boundary>.Empty;
    }

    public MockTopologyStateView(Dictionary<PlateId, Topology.Entities.Plate> plates, Dictionary<BoundaryId, Topology.Entities.Boundary> boundaries)
    {
        Plates = plates.ToImmutableDictionary();
        Boundaries = boundaries.ToImmutableDictionary();
    }
}

/// <summary>
/// Mock implementation of IPlateKinematicsStateView for corpus generation.
/// Returns constant angular velocities for plates.
/// </summary>
[MessagePackObject]
public class MockKinematicsStateView : IPlateKinematicsStateView
{
    [Key(0)]
    public TruthStreamIdentity Identity { get; init; } = new("test", "trunk", 1, Domain.Parse("geo.plates.kinematics.test"), "0");

    [Key(1)]
    public long LastEventSequence { get; init; } = 0;

    [Key(2)]
    public ImmutableDictionary<PlateId, AngularVelocity3d> AngularVelocities { get; init; }

    public MockKinematicsStateView()
    {
        AngularVelocities = ImmutableDictionary<PlateId, AngularVelocity3d>.Empty;
    }

    public MockKinematicsStateView(Dictionary<PlateId, AngularVelocity3d> angularVelocities)
    {
        AngularVelocities = angularVelocities.ToImmutableDictionary();
    }

    public bool TryGetRotation(PlateId plateId, TimeDete.CanonicalTick tick, out Quaterniond rotation)
    {
        // Compute rotation from angular velocity: θ = ω * t
        // For corpus generation, we use a simple linear rotation model
        if (AngularVelocities.TryGetValue(plateId, out var omega))
        {
            double angle = omega.Rate() * tick.Value;
            if (angle > 0)
            {
                var (axisX, axisY, axisZ) = omega.GetAxis();
                rotation = Quaterniond.FromAxisAngle(new Vector3d(axisX, axisY, axisZ), angle);
                return true;
            }
        }

        rotation = Quaterniond.Identity;
        return false;
    }
}


// --- PATH: hosts/Geosphere.Plate.SolverLab.Runner/MotionPathCorpusGenerator.cs ---
﻿using System.Collections.Immutable;
using TimeDete = Plate.TimeDete.Time.Primitives;
using FantaSim.Geosphere.Plate.Kinematics.Contracts.Derived;
using FantaSim.Geosphere.Plate.Topology.Contracts.Derived;
using FantaSim.Geosphere.Plate.Topology.Contracts.Entities;
using FantaSim.Geosphere.Plate.Topology.Contracts.Numerics;
using FantaSim.Geosphere.Plate.SolverLab.Core.Corpus;
using FantaSim.Geosphere.Plate.Velocity.Contracts;
using FantaSim.Geosphere.Plate.Velocity.Solver;
using FantaSim.Geosphere.Plate.Motion.Contracts;
using FantaSim.Geosphere.Plate.Motion.Solver;
using MessagePack;
using UnifyGeometry;

namespace FantaSim.Geosphere.Plate.SolverLab.Runner;

using CanonicalTick = TimeDete.CanonicalTick;
using Topology = FantaSim.Geosphere.Plate.Topology.Contracts;

/// <summary>
/// Generates Solver Lab corpus cases for RFC-V2-0035 Motion Path analysis.
/// </summary>
public static class MotionPathCorpusGenerator
{
    /// <summary>
    /// Generates the complete motion path corpus with analytical verification cases.
    /// </summary>
    public static SolverCorpus GenerateCorpus(MessagePackSerializerOptions options)
    {
        return new SolverCorpus
        {
            Domain = "MotionPath",
            Version = "1.0",
            Cases = new[]
            {
                CreateConstantRotationCase(options)
            }
        };
    }

    /// <summary>
    /// Case 1: Constant Rotation Motion Path
    /// A point on a plate rotating at constant angular velocity traces a great circle.
    /// Expected: Motion path matches analytical Rodrigues' rotation formula.
    /// </summary>
    private static CorpusCase CreateConstantRotationCase(MessagePackSerializerOptions options)
    {
        // Deterministic plate ID
        var plateId = new PlateId(Guid.Parse("00000010-0000-0000-0000-000000000001"));

        // Start point at (1, 0, 0) on unit sphere (equator at prime meridian)
        var startPoint = new Point3(1.0, 0.0, 0.0);

        // Rotation axis: Z-axis (0, 0, 1) - rotation in XY plane
        var rotationAxis = new Vector3d(0.0, 0.0, 1.0);

        // Angular rate: 0.1 rad/tick
        const double angularRate = 0.1;

        // Integration parameters
        const int stepCount = 10;
        const int stepTicks = 1;
        var startTick = new TimeDete.CanonicalTick(1000);
        var endTick = new TimeDete.CanonicalTick(startTick.Value + (stepCount * stepTicks));
        var direction = IntegrationDirection.Forward;

        // Create angular velocity from axis and rate
        var omega = new AngularVelocity3d(
            rotationAxis.X * angularRate,
            rotationAxis.Y * angularRate,
            rotationAxis.Z * angularRate);

        // Create mock state views
        var topology = new MockTopologyStateView(
            new Dictionary<PlateId, Topology.Entities.Plate>
            {
                [plateId] = new Topology.Entities.Plate(plateId, false, null)
            },
            new Dictionary<BoundaryId, Topology.Entities.Boundary>());

        var kinematics = new MockKinematicsStateView(
            new Dictionary<PlateId, AngularVelocity3d>
            {
                [plateId] = omega
            });

        // Create solver and compute expected output
        var velocitySolver = new FiniteRotationPlateVelocitySolver();
        var motionPathSolver = new EulerMotionPathSolver(velocitySolver);

        var expected = motionPathSolver.ComputeMotionPath(
            plateId,
            startPoint,
            startTick,
            endTick,
            direction,
            topology,
            kinematics,
            new MotionIntegrationSpec(stepTicks, stepCount, IntegrationMethod.Euler));

        // Compute analytical baseline for verification
        var analyticalPath = ComputeAnalyticalPath(
            startPoint,
            rotationAxis,
            angularRate,
            stepCount,
            stepTicks,
            startTick);

        // Create input structure
        var input = new MotionPathInput(
            plateId,
            startPoint,
            UnitVector3d.Create(rotationAxis.X, rotationAxis.Y, rotationAxis.Z),
            angularRate,
            stepCount,
            stepTicks,
            startTick,
            direction);

        // Create the entry with both solver output and analytical baseline
        var entry = new MotionPathCorpusEntry
        {
            CaseId = "case-001-constant-rotation",
            Description = "Constant rotation motion path - point traces great circle on unit sphere under Z-axis rotation (analytical verification)",
            Input = input,
            ExpectedOutput = expected,
            Difficulty = CaseDifficulty.Trivial,
            Tags = new[] { "motion-path", "constant-rotation", "analytical", "rfc-v2-0035" }
        };

        return new CorpusCase
        {
            CaseId = entry.CaseId,
            Description = entry.Description,
            Difficulty = entry.Difficulty,
            Tags = entry.Tags,
            InputData = MessagePackSerializer.Serialize(input, options),
            ExpectedOutput = MessagePackSerializer.Serialize(expected, options)
        };
    }

    /// <summary>
    /// Computes the analytical motion path using Rodrigues' rotation formula.
    /// For constant angular velocity ω around axis a, a point p at time t is:
    /// p(t) = p₀·cos(ωt) + (a×p₀)·sin(ωt) + a·(a·p₀)·(1-cos(ωt))
    /// </summary>
    private static MotionPath ComputeAnalyticalPath(
        Point3 startPoint,
        Vector3d rotationAxis,
        double angularRate,
        int stepCount,
        int stepTicks,
        CanonicalTick startTick)
    {
        var samples = new List<MotionPathSample>(stepCount + 1);

        // Normalize rotation axis
        var axisLength = rotationAxis.Length();
        if (axisLength < double.Epsilon)
        {
            throw new ArgumentException("Rotation axis cannot be zero", nameof(rotationAxis));
        }

        var axis = rotationAxis / axisLength;
        var p0 = new Vector3d(startPoint.X, startPoint.Y, startPoint.Z);

        // Create omega vector for velocity computation
        var omegaVec = axis * angularRate;

        for (int i = 0; i <= stepCount; i++)
        {
            var tick = new TimeDete.CanonicalTick(startTick.Value + (i * stepTicks));
            var t = i * stepTicks;
            var angle = angularRate * t;

            // Rodrigues' rotation formula:
            // p(t) = p₀·cos(θ) + (a×p₀)·sin(θ) + a·(a·p₀)·(1-cos(θ))
            var cosTheta = Math.Cos(angle);
            var sinTheta = Math.Sin(angle);

            // Cross product: a × p₀
            var crossX = axis.Y * p0.Z - axis.Z * p0.Y;
            var crossY = axis.Z * p0.X - axis.X * p0.Z;
            var crossZ = axis.X * p0.Y - axis.Y * p0.X;

            // Dot product: a · p₀
            var dot = axis.X * p0.X + axis.Y * p0.Y + axis.Z * p0.Z;

            // Apply Rodrigues' formula
            var px = p0.X * cosTheta + crossX * sinTheta + axis.X * dot * (1 - cosTheta);
            var py = p0.Y * cosTheta + crossY * sinTheta + axis.Y * dot * (1 - cosTheta);
            var pz = p0.Z * cosTheta + crossZ * sinTheta + axis.Z * dot * (1 - cosTheta);

            // Normalize to unit sphere
            var length = Math.Sqrt(px * px + py * py + pz * pz);
            px /= length;
            py /= length;
            pz /= length;

            // Compute velocity at this point (tangent to rotation)
            // v = ω × r (angular velocity cross position)
            var vx = omegaVec.Y * pz - omegaVec.Z * py;
            var vy = omegaVec.Z * px - omegaVec.X * pz;
            var vz = omegaVec.X * py - omegaVec.Y * px;

            samples.Add(new MotionPathSample(
                tick,
                new Point3((double)px, (double)py, (double)pz),
                new Velocity3d(vx, vy, vz),
                i));
        }

        var endTick = new TimeDete.CanonicalTick(startTick.Value + (stepCount * stepTicks));
        return new MotionPath(
            new PlateId(Guid.Parse("00000010-0000-0000-0000-000000000001")),
            startTick,
            endTick,
            IntegrationDirection.Forward,
            samples.ToImmutableArray());
    }
}


// --- PATH: hosts/Geosphere.Plate.SolverLab.Runner/Program.cs ---
using FantaSim.Geosphere.Plate.SolverLab.Core.Benchmarking;
using FantaSim.Geosphere.Plate.SolverLab.Core.Benchmarking.Verifiers;
using FantaSim.Geosphere.Plate.Topology.Contracts.Simulation;
using FantaSim.Geosphere.Plate.SolverLab.Core.Solvers.Reference;
using FantaSim.Geosphere.Plate.Topology.Serializers;
using FantaSim.Geosphere.Plate.SolverLab.Runner;
// using FantaSim.Geosphere.Plate.SolverLab.Core.Abstractions; // No longer needed if ISolver is in Contracts.Simulation?
// Wait, ISolver is in Contracts.Simulation now.
using MessagePack;
using Microsoft.Extensions.Logging;

using var loggerFactory = LoggerFactory.Create(builder =>
{
    builder.SetMinimumLevel(LogLevel.Information);
    builder.AddSimpleConsole(options =>
    {
        options.SingleLine = true;
        options.TimestampFormat = "HH:mm:ss ";
    });
});

var logger = loggerFactory.CreateLogger("SolverLab");

logger.LogInformation("=== FantaSim Solver Lab - Plate Motion ===");

// 1. Setup Serialization
var serializerOptions = MessagePackEventSerializer.Options;

// 2. Generate Corpus
logger.LogInformation("Generating corpus...");
var corpus = CorpusGenerator.GenerateSampleCorpus(serializerOptions);
logger.LogInformation("Generated {CaseCount} cases.", corpus.Cases.Length);

// 3. Register Solvers
var solvers = new List<ISolver<PlateMotionInput, PlateMotionResult>>
{
    new ReferencePlateMotionSolver()
};

// 4. Setup Verifier
var verifier = new PlateMotionVerifier();

// 5. Run Benchmark
logger.LogInformation("Running benchmark...");
var benchmark = new SolverBenchmark<PlateMotionInput, PlateMotionResult>(
    solvers,
    corpus,
    verifier,
    serializerOptions);

var report = await benchmark.RunAsync();

// 6. Print Report
logger.LogInformation("=== Benchmark Report ===");
logger.LogInformation("Timestamp: {Timestamp}", report.Timestamp);

foreach (var result in report.Results)
{
    logger.LogInformation("Solver: {SolverName} (v{SolverVersion})", result.SolverName, result.SolverVersion);
    logger.LogInformation("--------------------------------------------------");

    foreach (var caseResult in result.Cases)
    {
        var status = caseResult.Status == CaseStatus.Passed ? "PASS" : "FAIL";
        var timing = caseResult.Status == CaseStatus.Passed
            ? $"{caseResult.MedianTimeMs:F3}ms (min: {caseResult.MinTimeMs:F3}, max: {caseResult.MaxTimeMs:F3})"
            : $"Error: {caseResult.ErrorMessage}";

        logger.LogInformation("[{Status}] {CaseId}: {Result}", status, caseResult.CaseId, timing);
    }
}

logger.LogInformation("Done.");


// --- PATH: plugins/Geosphere.Plate.Cache.Materializer/Cache/ArtifactCache.cs ---
﻿using System.Security.Cryptography;
using System.Text;
using FantaSim.Geosphere.Plate.Cache.Contracts;
using FantaSim.Geosphere.Plate.Cache.Contracts.Models;
using FantaSim.Geosphere.Plate.Cache.Materializer.Hashing;
using FantaSim.Geosphere.Plate.Cache.Materializer.Storage;
using FantaSim.Geosphere.Plate.Topology.Contracts.Identity;

namespace FantaSim.Geosphere.Plate.Cache.Materializer.Cache;

public sealed class ArtifactCache : IDerivedArtifactCache
{
    private readonly IArtifactStorage _storage;
    private readonly ArtifactCacheOptions _options;

    public ArtifactCache(IArtifactStorage storage, ArtifactCacheOptions options)
    {
        ArgumentNullException.ThrowIfNull(storage);
        ArgumentNullException.ThrowIfNull(options);
        _storage = storage;
        _options = options;
    }

    public async Task<CacheLookupResult> GetOrCreateArtifactAsync<T>(
        TruthStreamIdentity stream,
        string productType,
        long lastSequence,
        string generatorId,
        string generatorVersion,
        Dictionary<string, object> parameters,
        IArtifactGenerator<T> generator,
        CancellationToken ct)
    {
        if (lastSequence < 0)
            throw new ArgumentException("LastSequence cannot be negative", nameof(lastSequence));

        ArgumentException.ThrowIfNullOrWhiteSpace(productType);
        ArgumentException.ThrowIfNullOrWhiteSpace(generatorId);
        ArgumentException.ThrowIfNullOrWhiteSpace(generatorVersion);
        ArgumentNullException.ThrowIfNull(parameters);
        ArgumentNullException.ThrowIfNull(generator);
        ct.ThrowIfCancellationRequested();

        var paramsHash = ParamsHashComputer.Compute(parameters);
        var inputFingerprint = InputFingerprintComputer.Compute(
            sourceStream: stream.ToEventStreamIdString(),
            boundaryKind: "sequence",
            lastSequence: (ulong)lastSequence,
            generatorId: generatorId,
            generatorVersion: generatorVersion,
            paramsHash: paramsHash);

        var manifestKey = KeyBuilder.BuildManifestKey(stream, productType, inputFingerprint);
        var payloadKey = KeyBuilder.BuildPayloadKey(stream, productType, inputFingerprint);

        var manifest = await _storage.GetManifestAsync(manifestKey, ct).ConfigureAwait(false);
        if (manifest.HasValue)
        {
            if (!string.Equals(manifest.Value.InputFingerprint, inputFingerprint, StringComparison.Ordinal))
                throw new InvalidOperationException("Manifest input_fingerprint does not match computed fingerprint");

            var payload = await _storage.GetPayloadAsync(payloadKey, ct).ConfigureAwait(false);
            if (payload == null)
                throw new InvalidOperationException("Payload missing for cached manifest");

            if (_options.VerifyOnRead)
            {
                await VerifyContentAsync(payload, manifest.Value.Storage, ct).ConfigureAwait(false);
            }

            return CacheLookupResult.Hit(payload, manifest.Value, inputFingerprint);
        }

        return CacheLookupResult.Miss(inputFingerprint);
    }

    public async Task StoreArtifactAsync(
        TruthStreamIdentity stream,
        string productType,
        long lastSequence,
        string inputFingerprint,
        string generatorId,
        string generatorVersion,
        Dictionary<string, object> parameters,
        byte[] payload,
        CancellationToken ct)
    {
        if (lastSequence < 0)
            throw new ArgumentException("LastSequence cannot be negative", nameof(lastSequence));

        ArgumentException.ThrowIfNullOrWhiteSpace(productType);
        ArgumentException.ThrowIfNullOrWhiteSpace(inputFingerprint);
        ArgumentException.ThrowIfNullOrWhiteSpace(generatorId);
        ArgumentException.ThrowIfNullOrWhiteSpace(generatorVersion);
        ArgumentNullException.ThrowIfNull(parameters);
        ArgumentNullException.ThrowIfNull(payload);
        ct.ThrowIfCancellationRequested();

        var contentHash = ComputeSha256Hex(payload);
        var contentLength = (ulong)payload.Length;
        var paramsHash = ParamsHashComputer.Compute(parameters);
        var boundary = Boundary.Sequence((ulong)lastSequence);
        var generator = new GeneratorInfo(generatorId, generatorVersion);
        var storageInfo = _options.Mode == StorageMode.External
            ? StorageInfo.External(contentHash, contentLength)
            : StorageInfo.Embedded(contentHash, contentLength);

        var manifest = Manifest.Create(
            productType: productType,
            inputFingerprint: inputFingerprint,
            sourceStream: stream.ToEventStreamIdString(),
            boundary: boundary,
            generator: generator,
            paramsHash: paramsHash,
            storage: storageInfo) with
        {
            CreatedAtUtc = DateTimeOffset.UtcNow.ToString("o"),
            Params = parameters
        };

        var manifestKey = KeyBuilder.BuildManifestKey(stream, productType, inputFingerprint);
        var payloadKey = KeyBuilder.BuildPayloadKey(stream, productType, inputFingerprint);

        await _storage.StoreAsync(manifestKey, manifest, payloadKey, payload, ct).ConfigureAwait(false);
    }

    public static Task VerifyContentAsync(byte[] payload, StorageInfo storage, CancellationToken ct)
    {
        ArgumentNullException.ThrowIfNull(payload);
        ct.ThrowIfCancellationRequested();

        var hash = ComputeSha256Hex(payload);
        if (!hash.Equals(storage.ContentHash, StringComparison.Ordinal))
            throw new InvalidOperationException("Payload content hash mismatch");

        if ((ulong)payload.Length != storage.ContentLength)
            throw new InvalidOperationException("Payload content length mismatch");

        return Task.CompletedTask;
    }

    private static string ComputeSha256Hex(byte[] bytes)
    {
        var hashBytes = SHA256.HashData(bytes);
        var sb = new StringBuilder(hashBytes.Length * 2);
        foreach (var b in hashBytes)
        {
            sb.AppendFormat("{0:x2}", b);
        }
        return sb.ToString();
    }
}


// --- PATH: plugins/Geosphere.Plate.Cache.Materializer/Cache/ArtifactCacheOptions.cs ---
using FantaSim.Geosphere.Plate.Cache.Contracts.Models;

namespace FantaSim.Geosphere.Plate.Cache.Materializer.Cache;

public sealed record ArtifactCacheOptions(
    StorageMode Mode,
    bool VerifyOnRead = true,
    string? ColumnFamily = "derived",
    RetentionPolicy? Retention = null);


// --- PATH: plugins/Geosphere.Plate.Cache.Materializer/Cache/GarbageCollector.cs ---
using System.Globalization;
using FantaSim.Geosphere.Plate.Cache.Materializer.Storage;

namespace FantaSim.Geosphere.Plate.Cache.Materializer.Cache;

public sealed class GarbageCollector
{
    private const string ManifestSuffix = ":Manifest";
    private const string PayloadSuffix = ":Payload";

    private readonly IArtifactStorage _storage;

    public GarbageCollector(IArtifactStorage storage)
    {
        ArgumentNullException.ThrowIfNull(storage);
        _storage = storage;
    }

    public async Task CollectAsync(string streamPrefix, RetentionPolicy policy, CancellationToken ct)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(streamPrefix);
        ArgumentNullException.ThrowIfNull(policy);
        ct.ThrowIfCancellationRequested();

        var candidates = new List<ArtifactCandidate>();
        await foreach (var key in _storage.EnumerateKeysAsync(streamPrefix, ct).ConfigureAwait(false))
        {
            if (!key.EndsWith(ManifestSuffix, StringComparison.Ordinal))
                continue;

            var manifest = await _storage.GetManifestAsync(key, ct).ConfigureAwait(false);
            if (!manifest.HasValue)
                continue;

            var payloadKey = string.Concat(key.AsSpan(0, key.Length - ManifestSuffix.Length), PayloadSuffix);
            var createdAt = ParseCreatedAt(manifest.Value.CreatedAtUtc);

            candidates.Add(new ArtifactCandidate(
                ManifestKey: key,
                PayloadKey: payloadKey,
                LastSequence: (long)manifest.Value.Boundary.LastSequence,
                CreatedAtUtc: createdAt));
        }

        if (candidates.Count == 0)
            return;

        var protectedKeys = GetProtectedKeys(candidates, policy.MinArtifactsToKeep);
        var maxSequence = candidates.Max(c => c.LastSequence);
        var now = DateTimeOffset.UtcNow;

        foreach (var candidate in candidates)
        {
            if (protectedKeys.Contains(candidate.ManifestKey))
                continue;

            if (ShouldDelete(candidate, policy, maxSequence, now))
            {
                await _storage.DeleteAsync(candidate.ManifestKey, candidate.PayloadKey, ct).ConfigureAwait(false);
            }
        }
    }

    private static bool ShouldDelete(
        ArtifactCandidate candidate,
        RetentionPolicy policy,
        long maxSequence,
        DateTimeOffset now)
    {
        var deleteBySequence = false;
        if (policy.MaxSequenceAge.HasValue)
        {
            deleteBySequence = (maxSequence - candidate.LastSequence) >= policy.MaxSequenceAge.Value;
        }

        var deleteByTime = false;
        if (policy.MaxTimeAge.HasValue && candidate.CreatedAtUtc.HasValue)
        {
            deleteByTime = candidate.CreatedAtUtc.Value <= now.Subtract(policy.MaxTimeAge.Value);
        }

        return deleteBySequence || deleteByTime;
    }

    private static HashSet<string> GetProtectedKeys(
        List<ArtifactCandidate> candidates,
        int? minArtifactsToKeep)
    {
        var protectedKeys = new HashSet<string>(StringComparer.Ordinal);
        if (!minArtifactsToKeep.HasValue || minArtifactsToKeep.Value <= 0)
            return protectedKeys;

        var ordered = candidates
            .OrderByDescending(c => c.LastSequence)
            .ThenByDescending(c => c.CreatedAtUtc ?? DateTimeOffset.MinValue)
            .ThenBy(c => c.ManifestKey, StringComparer.Ordinal)
            .Take(minArtifactsToKeep.Value);

        foreach (var candidate in ordered)
        {
            protectedKeys.Add(candidate.ManifestKey);
        }

        return protectedKeys;
    }

    private static DateTimeOffset? ParseCreatedAt(string? createdAtUtc)
    {
        if (string.IsNullOrWhiteSpace(createdAtUtc))
            return null;

        if (DateTimeOffset.TryParse(
                createdAtUtc,
                CultureInfo.InvariantCulture,
                DateTimeStyles.RoundtripKind,
                out var parsed))
        {
            return parsed;
        }

        return null;
    }

    private sealed record ArtifactCandidate(
        string ManifestKey,
        string PayloadKey,
        long LastSequence,
        DateTimeOffset? CreatedAtUtc);
}


// --- PATH: plugins/Geosphere.Plate.Cache.Materializer/Cache/RetentionPolicy.cs ---
namespace FantaSim.Geosphere.Plate.Cache.Materializer.Cache;

public sealed record RetentionPolicy(
    long? MaxSequenceAge = null,
    TimeSpan? MaxTimeAge = null,
    int? MinArtifactsToKeep = null);


// --- PATH: plugins/Geosphere.Plate.Cache.Materializer/CacheMaterializerPlugin.cs ---
﻿using System;
using System.Threading;
using System.Threading.Tasks;
using FantaSim.Geosphere.Plate.Cache.Contracts;
using FantaSim.Geosphere.Plate.Cache.Contracts.Models;
using FantaSim.Geosphere.Plate.Cache.Materializer.Cache;
using FantaSim.Geosphere.Plate.Cache.Materializer.Storage;
using Microsoft.Extensions.DependencyInjection;
using PluginArchi.Extensibility.Abstractions;
using ServiceArchi.Contracts;
using UnifyStorage.Abstractions;

namespace FantaSim.Geosphere.Plate.Cache.Materializer;

/// <summary>
/// Plugin entry point for the Derived Artifact Cache Materializer.
///
/// Registers:
/// - IDerivedArtifactCache: Cache lookup and storage for derived artifacts
/// - IArtifactStorage: Low-level artifact storage abstraction
/// </summary>
[Plugin("fantasim.geosphere.plate.cache.materializer", Name = "Derived Artifact Cache", Tags = "geosphere,cache,materializer,derived")]
public sealed class CacheMaterializerPlugin : ILifecyclePlugin
{
    private IRegistry? _registry;
    private ArtifactCache? _cache;
    private IArtifactStorage? _storage;

    public IPluginDescriptor Descriptor { get; } = new PluginDescriptor
    {
        Id = "fantasim.geosphere.plate.cache.materializer",
        Name = "Derived Artifact Cache",
        Description = "Caching layer for derived artifacts with content-addressed fingerprinting.",
        Tags = new[] { "geosphere", "cache", "materializer", "derived" },
        Version = new Version(1, 0, 0)
    };

    public ValueTask InitializeAsync(IPluginContext context, CancellationToken ct = default)
    {
        // 1. Resolve the ServiceArchi Registry from the host context
        var registry = context.Services.GetService<IRegistry>();
        if (registry == null)
        {
            return ValueTask.CompletedTask;
        }

        _registry = registry;

        // 2. Resolve options or use defaults (Embedded mode with verification)
        var options = context.Services.GetService<ArtifactCacheOptions>()
            ?? new ArtifactCacheOptions(StorageMode.Embedded);

        // 3. Resolve or create storage backend
        _storage = context.Services.GetService<IArtifactStorage>();
        if (_storage == null)
        {
            // Try to create embedded storage using KV store
            var kvStore = context.Services.GetService<IKeyValueStore>();
            if (kvStore != null)
            {
                _storage = new EmbeddedStorage(kvStore);
            }
            else
            {
                // No storage backend available
                return ValueTask.CompletedTask;
            }
        }

        // 4. Create and register the cache
        _cache = new ArtifactCache(_storage, options);
        registry.Register<IDerivedArtifactCache>(_cache);
        registry.Register<IArtifactStorage>(_storage);

        return ValueTask.CompletedTask;
    }

    public ValueTask ShutdownAsync(CancellationToken ct = default)
    {
        _registry?.UnregisterAll<IArtifactStorage>();
        _registry?.UnregisterAll<IDerivedArtifactCache>();

        _cache = null;
        _storage = null;
        _registry = null;

        return ValueTask.CompletedTask;
    }
}


// --- PATH: plugins/Geosphere.Plate.Cache.Materializer/Hashing/InputFingerprintComputer.cs ---
﻿using System.Security.Cryptography;
using System.Text;
using FantaSim.Geosphere.Plate.Cache.Contracts.Models;
using FantaSim.Geosphere.Plate.Cache.Materializer.Serialization;

namespace FantaSim.Geosphere.Plate.Cache.Materializer.Hashing;

/// <summary>
/// Computes the InputFingerprint for derived artifacts.
///
/// Algorithm:
/// inputFingerprint = lowercase_hex(SHA256(CanonicalMsgPack(FingerprintEnvelope)))
///
/// FingerprintEnvelope is encoded as a MessagePack array with 6 elements:
/// [
///   source_stream (str),
///   boundary_kind (str),
///   last_sequence (uint64),
///   generator_id (str),
///   generator_version (str),
///   params_hash (str)
/// ]
/// </summary>
public static class InputFingerprintComputer
{
    /// <summary>
    /// Computes the input fingerprint from individual components.
    /// </summary>
    /// <param name="sourceStream">Full stream identity (e.g., "S:V1:Bmain:L0:Plates:M0:Events")</param>
    /// <param name="boundaryKind">Boundary kind (always "sequence" in v1)</param>
    /// <param name="lastSequence">Inclusive sequence boundary</param>
    /// <param name="generatorId">Stable generator identifier</param>
    /// <param name="generatorVersion">Generator version string</param>
    /// <param name="paramsHash">SHA-256 hash of canonical params (64 lowercase hex chars)</param>
    /// <returns>64-character lowercase hex SHA-256 hash</returns>
    public static string Compute(
        string sourceStream,
        string boundaryKind,
        ulong lastSequence,
        string generatorId,
        string generatorVersion,
        string paramsHash)
    {
        // Validate inputs
        ValidateInputs(sourceStream, boundaryKind, generatorId, generatorVersion, paramsHash);

        // Encode as canonical MessagePack array
        var canonicalBytes = DerivedCacheCanonicalMessagePackEncoder.EncodeFingerprintEnvelope(
            sourceStream,
            boundaryKind,
            lastSequence,
            generatorId,
            generatorVersion,
            paramsHash
        );

        // Compute SHA-256 hash
        var hashBytes = SHA256.HashData(canonicalBytes);

        // Convert to lowercase hex
        return ToLowercaseHex(hashBytes);
    }

    /// <summary>
    /// Computes the input fingerprint from a FingerprintEnvelope.
    /// </summary>
    public static string Compute(FingerprintEnvelope envelope)
    {
        envelope.Validate();
        return Compute(
            envelope.SourceStream,
            envelope.BoundaryKind,
            envelope.LastSequence,
            envelope.GeneratorId,
            envelope.GeneratorVersion,
            envelope.ParamsHash
        );
    }

    /// <summary>
    /// Computes the golden fingerprint for the RFC test vector.
    /// This can be used to verify implementation correctness.
    /// </summary>
    public static string ComputeGoldenFingerprint()
    {
        return Compute(
            sourceStream: "S:V1:Bmain:L0:Plates:M0:Events",
            boundaryKind: "sequence",
            lastSequence: 0,
            generatorId: "TestGen",
            generatorVersion: "1.0.0",
            paramsHash: ParamsHashComputer.EmptyParamsHash
        );
    }

    /// <summary>
    /// The golden fingerprint computed from the RFC test vector inputs.
    /// Computed once and recorded for cross-implementation compatibility.
    /// </summary>
    public const string GoldenFingerprint = "b22cabf7cd82e2f6a172c1bf11e9e56510a0a084a130fbfbf0a06e05a0d0157e";

    private static void ValidateInputs(
        string sourceStream,
        string boundaryKind,
        string generatorId,
        string generatorVersion,
        string paramsHash)
    {
        if (string.IsNullOrWhiteSpace(sourceStream))
            throw new ArgumentException("SourceStream cannot be null or empty", nameof(sourceStream));

        if (string.IsNullOrWhiteSpace(boundaryKind))
            throw new ArgumentException("BoundaryKind cannot be null or empty", nameof(boundaryKind));

        if (boundaryKind != "sequence")
            throw new ArgumentException("Only 'sequence' boundary kind is supported in v1", nameof(boundaryKind));

        if (string.IsNullOrWhiteSpace(generatorId))
            throw new ArgumentException("GeneratorId cannot be null or empty", nameof(generatorId));

        if (string.IsNullOrWhiteSpace(generatorVersion))
            throw new ArgumentException("GeneratorVersion cannot be null or empty", nameof(generatorVersion));

        if (string.IsNullOrWhiteSpace(paramsHash))
            throw new ArgumentException("ParamsHash cannot be null or empty", nameof(paramsHash));

        if (paramsHash.Length != 64)
            throw new ArgumentException("ParamsHash must be 64 characters (SHA-256 hex)", nameof(paramsHash));

        foreach (var c in paramsHash)
        {
            if (!IsLowercaseHexChar(c))
                throw new ArgumentException("ParamsHash must be lowercase hexadecimal", nameof(paramsHash));
        }
    }

    private static bool IsLowercaseHexChar(char c) =>
        (c >= '0' && c <= '9') || (c >= 'a' && c <= 'f');

    private static string ToLowercaseHex(byte[] bytes)
    {
        var sb = new StringBuilder(bytes.Length * 2);
        foreach (var b in bytes)
        {
            sb.AppendFormat("{0:x2}", b);
        }
        return sb.ToString();
    }
}


// --- PATH: plugins/Geosphere.Plate.Cache.Materializer/Hashing/ParamsHashComputer.cs ---
using System.Security.Cryptography;
using System.Text;
using FantaSim.Geosphere.Plate.Cache.Materializer.Serialization;

namespace FantaSim.Geosphere.Plate.Cache.Materializer.Hashing;

/// <summary>
/// Computes SHA-256 hash of canonical params encoding.
///
/// Algorithm:
/// params_hash = lowercase_hex(SHA256(CanonicalMsgPack(paramsObject)))
///
/// Test Vector:
/// Input: {} (empty map)
/// Canonical MessagePack: 0x80 (single byte)
/// Expected: 76be8b528d0075f7aae98d6fa57a6d3c83ae480a8469e668d7b0af968995ac71
/// </summary>
public static class ParamsHashComputer
{
    /// <summary>
    /// Computes the params hash for a dictionary of parameters.
    /// </summary>
    /// <param name="params">The parameters dictionary (can be null or empty)</param>
    /// <returns>64-character lowercase hex SHA-256 hash</returns>
    public static string Compute(Dictionary<string, object?>? @params)
    {
        // Encode params as canonical MessagePack
        var canonicalBytes = DerivedCacheCanonicalMessagePackEncoder.EncodeMap(@params);

        // Compute SHA-256 hash
        var hashBytes = SHA256.HashData(canonicalBytes);

        // Convert to lowercase hex
        return ToLowercaseHex(hashBytes);
    }

    /// <summary>
    /// Computes the params hash for an empty params object.
    /// Returns the test vector: 76be8b528d0075f7aae98d6fa57a6d3c83ae480a8469e668d7b0af968995ac71
    /// </summary>
    public static string ComputeEmpty() => Compute(null);

    /// <summary>
    /// The expected hash for empty params (test vector).
    /// </summary>
    public const string EmptyParamsHash = "76be8b528d0075f7aae98d6fa57a6d3c83ae480a8469e668d7b0af968995ac71";

    /// <summary>
    /// Converts byte array to lowercase hexadecimal string.
    /// </summary>
    private static string ToLowercaseHex(byte[] bytes)
    {
        var sb = new StringBuilder(bytes.Length * 2);
        foreach (var b in bytes)
        {
            sb.AppendFormat("{0:x2}", b);
        }
        return sb.ToString();
    }
}


// --- PATH: plugins/Geosphere.Plate.Cache.Materializer/Serialization/DerivedCacheCanonicalMessagePackEncoder.cs ---
using System.Buffers;
using System.Text;
using MessagePack;

namespace FantaSim.Geosphere.Plate.Cache.Materializer.Serialization;

/// <summary>
/// Canonical MessagePack encoder for deterministic hashing of derived cache artifacts.
///
/// IMPORTANT: This encoder is scoped to derived cache fingerprinting ONLY.
/// It MUST NOT be used for event hash preimages (RFC-V2-0005 prohibits maps in hash-critical
/// event payloads, but RFC-V2-0006 explicitly allows maps for params_hash in derived cache).
///
/// Key features:
/// - Map keys are sorted by UTF-8 byte order
/// - Produces identical bytes for equivalent data structures
/// - Used for computing content-addressed hashes for derived artifact caching
/// </summary>
public static class DerivedCacheCanonicalMessagePackEncoder
{
    /// <summary>
    /// Encodes a dictionary as canonical MessagePack map with sorted keys.
    /// </summary>
    /// <param name="map">The dictionary to encode</param>
    /// <returns>Canonical MessagePack bytes</returns>
    public static byte[] EncodeMap(Dictionary<string, object?>? map)
    {
        if (map == null || map.Count == 0)
        {
            // Empty map: 0x80 (fixmap with 0 elements)
            return new byte[] { 0x80 };
        }

        var buffer = new ArrayBufferWriter<byte>();
        var writer = new MessagePackWriter(buffer);

        // Sort keys by UTF-8 byte order
        var sortedEntries = map
            .Select(e => new { KeyBytes = Encoding.UTF8.GetBytes(e.Key), e.Key, e.Value })
            .OrderBy(e => e.KeyBytes, ByteArrayComparer.Instance)
            .ToList();

        writer.WriteMapHeader(sortedEntries.Count);

        foreach (var entry in sortedEntries)
        {
            // Write key as raw UTF-8 bytes
            writer.WriteString(entry.KeyBytes);
            // Write value
            WriteValue(ref writer, entry.Value);
        }

        writer.Flush();
        return buffer.WrittenMemory.ToArray();
    }

    /// <summary>
    /// Encodes a FingerprintEnvelope as canonical MessagePack array.
    /// Array encoding preserves field order (no sorting needed for arrays).
    /// </summary>
    public static byte[] EncodeFingerprintEnvelope(
        string sourceStream,
        string boundaryKind,
        ulong lastSequence,
        string generatorId,
        string generatorVersion,
        string paramsHash)
    {
        var buffer = new ArrayBufferWriter<byte>();
        var writer = new MessagePackWriter(buffer);

        // Write as 6-element fixarray: 0x96
        writer.WriteArrayHeader(6);

        // Position 0: source_stream (string)
        writer.Write(sourceStream);

        // Position 1: boundary_kind (string)
        writer.Write(boundaryKind);

        // Position 2: last_sequence (uint64)
        writer.Write(lastSequence);

        // Position 3: generator_id (string)
        writer.Write(generatorId);

        // Position 4: generator_version (string)
        writer.Write(generatorVersion);

        // Position 5: params_hash (string)
        writer.Write(paramsHash);

        writer.Flush();
        return buffer.WrittenMemory.ToArray();
    }

    /// <summary>
    /// Writes a value to the MessagePack writer.
    /// Supports: null, bool, string, long, ulong, double, Dictionary<string, object>
    /// </summary>
    private static void WriteValue(ref MessagePackWriter writer, object? value)
    {
        if (value == null)
        {
            writer.WriteNil();
            return;
        }

        var valueType = value.GetType();

        if (value is bool b)
        {
            writer.Write(b);
        }
        else if (value is string s)
        {
            writer.Write(s);
        }
        else if (value is long l)
        {
            writer.Write(l);
        }
        else if (value is int i)
        {
            writer.Write((long)i);
        }
        else if (value is ulong ul)
        {
            writer.Write(ul);
        }
        else if (value is uint ui)
        {
            writer.Write((ulong)ui);
        }
        else if (value is double d)
        {
            writer.Write(d);
        }
        else if (value is float f)
        {
            writer.Write((double)f);
        }
        else if (valueType.IsGenericType && valueType.GetGenericTypeDefinition() == typeof(Dictionary<,>) &&
                 valueType.GetGenericArguments()[0] == typeof(string))
        {
            // Handle Dictionary<string, object?> and Dictionary<string, object>
            var dict = (System.Collections.IDictionary)value;
            var converted = new Dictionary<string, object?>();
            foreach (var key in dict.Keys)
            {
                converted[(string)key] = dict[key];
            }
            var encoded = DerivedCacheCanonicalMessagePackEncoder.EncodeMap(converted);
            writer.WriteRaw(encoded);
        }
        else
        {
            // Fallback: convert to string
            writer.Write(value.ToString());
        }
    }

    /// <summary>
    /// Comparer for sorting byte arrays by ordinal byte order.
    /// </summary>
    private class ByteArrayComparer : IComparer<byte[]>
    {
        public static readonly ByteArrayComparer Instance = new();

        public int Compare(byte[]? x, byte[]? y)
        {
            if (x == null && y == null) return 0;
            if (x == null) return -1;
            if (y == null) return 1;

            int minLen = Math.Min(x.Length, y.Length);
            for (int i = 0; i < minLen; i++)
            {
                int cmp = x[i].CompareTo(y[i]);
                if (cmp != 0) return cmp;
            }

            return x.Length.CompareTo(y.Length);
        }
    }
}


// --- PATH: plugins/Geosphere.Plate.Cache.Materializer/Serialization/ManifestSerializer.cs ---
using MessagePack;
using MessagePack.Resolvers;
using FantaSim.Geosphere.Plate.Cache.Contracts.Models;

namespace FantaSim.Geosphere.Plate.Cache.Materializer.Serialization;

/// <summary>
/// MessagePack serializer for Manifest records.
/// </summary>
public static class ManifestSerializer
{
    public static readonly MessagePackSerializerOptions Options = MessagePackSerializerOptions.Standard
        .WithResolver(CompositeResolver.Create(
            new IFormatterResolver[]
            {
                ContractlessStandardResolver.Instance,
                StandardResolver.Instance
            }));

    public static byte[] Serialize(Manifest manifest)
    {
        return MessagePackSerializer.Serialize(manifest, Options);
    }

    public static Manifest Deserialize(byte[] bytes)
    {
        return MessagePackSerializer.Deserialize<Manifest>(bytes, Options);
    }
}


// --- PATH: plugins/Geosphere.Plate.Cache.Materializer/Storage/EmbeddedStorage.cs ---
using System.Security.Cryptography;
using System.Text;
using FantaSim.Geosphere.Plate.Cache.Contracts.Models;
using FantaSim.Geosphere.Plate.Cache.Materializer.Serialization;
using UnifyStorage.Abstractions;

namespace FantaSim.Geosphere.Plate.Cache.Materializer.Storage;

/// <summary>
/// Embedded artifact storage backed by a key-value store.
/// Stores manifest and payload directly in the KV store.
/// </summary>
public sealed class EmbeddedStorage : IArtifactStorage
{
    private readonly IKeyValueStore _store;
    private readonly object _lock = new();

    public EmbeddedStorage(IKeyValueStore store)
    {
        ArgumentNullException.ThrowIfNull(store);
        _store = store;
    }

    public Task<Manifest?> GetManifestAsync(string key, CancellationToken ct)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(key);

        ct.ThrowIfCancellationRequested();

        byte[]? bytes;
        lock (_lock)
        {
            bytes = ReadBytes(Encoding.UTF8.GetBytes(key));
        }

        if (bytes == null || bytes.Length == 0)
            return Task.FromResult<Manifest?>(null);

        var manifest = ManifestSerializer.Deserialize(bytes);
        return Task.FromResult<Manifest?>(manifest);
    }

    public async Task<byte[]?> GetPayloadAsync(string key, CancellationToken ct)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(key);
        ct.ThrowIfCancellationRequested();

        byte[]? payload;
        lock (_lock)
        {
            payload = ReadBytes(Encoding.UTF8.GetBytes(key));
        }

        if (payload == null || payload.Length == 0)
            return null;

        var manifestKey = KeyBuilder.DeriveManifestKeyFromPayloadKey(key);
        var manifest = await GetManifestAsync(manifestKey, ct).ConfigureAwait(false);
        if (manifest == null)
            return null;

        VerifyPayload(manifest.Value.Storage, payload);
        return payload;
    }

    public Task StoreAsync(
        string manifestKey,
        Manifest manifest,
        string payloadKey,
        byte[] payload,
        CancellationToken ct)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(manifestKey);
        ArgumentException.ThrowIfNullOrWhiteSpace(payloadKey);
        ArgumentNullException.ThrowIfNull(payload);

        ct.ThrowIfCancellationRequested();

        var contentHash = ComputeSha256Hex(payload);
        var contentLength = (ulong)payload.Length;

        var storageInfo = StorageInfo.Embedded(contentHash, contentLength);
        var updatedManifest = manifest with { Storage = storageInfo, External = null };
        updatedManifest.Validate();

        var manifestBytes = ManifestSerializer.Serialize(updatedManifest);
        var manifestKeyBytes = Encoding.UTF8.GetBytes(manifestKey);
        var payloadKeyBytes = Encoding.UTF8.GetBytes(payloadKey);

        using var batch = _store.CreateWriteBatch();
        batch.Put(manifestKeyBytes, manifestBytes);
        batch.Put(payloadKeyBytes, payload);

        lock (_lock)
        {
            _store.Write(batch);
        }

        return Task.CompletedTask;
    }

    public Task DeleteAsync(string manifestKey, string payloadKey, CancellationToken ct)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(manifestKey);
        ArgumentException.ThrowIfNullOrWhiteSpace(payloadKey);
        ct.ThrowIfCancellationRequested();

        using var batch = _store.CreateWriteBatch();
        batch.Delete(Encoding.UTF8.GetBytes(manifestKey));
        batch.Delete(Encoding.UTF8.GetBytes(payloadKey));

        lock (_lock)
        {
            _store.Write(batch);
        }

        return Task.CompletedTask;
    }

    public async IAsyncEnumerable<string> EnumerateKeysAsync(
        string prefix,
        [System.Runtime.CompilerServices.EnumeratorCancellation] CancellationToken ct)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(prefix);
        ct.ThrowIfCancellationRequested();

        var prefixBytes = Encoding.UTF8.GetBytes(prefix);
        List<string> keys = new();

        lock (_lock)
        {
            using var iterator = _store.CreateIterator();
            iterator.Seek(prefixBytes);
            while (iterator.Valid && StartsWith(iterator.Key, prefixBytes))
            {
                keys.Add(Encoding.UTF8.GetString(iterator.Key));
                iterator.Next();
            }
        }

        foreach (var key in keys)
        {
            ct.ThrowIfCancellationRequested();
            await Task.Yield();
            yield return key;
        }
    }

    private static void VerifyPayload(StorageInfo storage, byte[] payload)
    {
        var hash = ComputeSha256Hex(payload);
        if (!hash.Equals(storage.ContentHash, StringComparison.Ordinal))
            throw new InvalidOperationException("Payload content hash mismatch");

        if ((ulong)payload.Length != storage.ContentLength)
            throw new InvalidOperationException("Payload content length mismatch");
    }

    private static string ComputeSha256Hex(byte[] bytes)
    {
        var hashBytes = SHA256.HashData(bytes);
        var sb = new StringBuilder(hashBytes.Length * 2);
        foreach (var b in hashBytes)
        {
            sb.AppendFormat("{0:x2}", b);
        }
        return sb.ToString();
    }

    private static bool StartsWith(ReadOnlySpan<byte> value, ReadOnlySpan<byte> prefix)
    {
        if (value.Length < prefix.Length)
            return false;

        return value[..prefix.Length].SequenceEqual(prefix);
    }

    private byte[]? ReadBytes(byte[] key)
    {
        Span<byte> initialBuffer = stackalloc byte[1];
        if (_store.TryGet(key, initialBuffer, out var written))
        {
            return initialBuffer.Slice(0, written).ToArray();
        }

        if (written > 0)
        {
            var result = new byte[written];
            if (_store.TryGet(key, result, out var finalWritten))
            {
                return result;
            }
            throw new InvalidOperationException("Store state changed during read");
        }

        return null;
    }
}


// --- PATH: plugins/Geosphere.Plate.Cache.Materializer/Storage/ExternalStorage.cs ---
using System.Security.Cryptography;
using System.Text;
using FantaSim.Geosphere.Plate.Cache.Contracts.Models;
using FantaSim.Geosphere.Plate.Cache.Materializer.Serialization;
using UnifyStorage.Abstractions;

namespace FantaSim.Geosphere.Plate.Cache.Materializer.Storage;

/// <summary>
/// External artifact storage with manifest stored in KV store and payload fetched externally.
/// </summary>
public sealed class ExternalStorage : IArtifactStorage
{
    private readonly IKeyValueStore _store;
    private readonly object _lock = new();

    public ExternalStorage(IKeyValueStore store)
    {
        ArgumentNullException.ThrowIfNull(store);
        _store = store;
    }

    public Task<Manifest?> GetManifestAsync(string key, CancellationToken ct)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(key);
        ct.ThrowIfCancellationRequested();

        byte[]? bytes;
        lock (_lock)
        {
            bytes = ReadBytes(Encoding.UTF8.GetBytes(key));
        }

        if (bytes == null || bytes.Length == 0)
            return Task.FromResult<Manifest?>(null);

        var manifest = ManifestSerializer.Deserialize(bytes);
        return Task.FromResult<Manifest?>(manifest);
    }

    public async Task<byte[]?> GetPayloadAsync(string key, CancellationToken ct)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(key);
        ct.ThrowIfCancellationRequested();

        var manifestKey = KeyBuilder.DeriveManifestKeyFromPayloadKey(key);
        var manifest = await GetManifestAsync(manifestKey, ct).ConfigureAwait(false);
        if (manifest == null)
            return null;

        var storage = manifest.Value.Storage;
        if (storage.Mode != StorageMode.External)
            throw new InvalidOperationException("Manifest storage mode is not External");

        var external = manifest.Value.External;
        if (external == null)
            throw new InvalidOperationException("External storage info is missing");

        var payload = await FetchExternalPayloadAsync(external.Value, ct).ConfigureAwait(false);
        if (payload == null || payload.Length == 0)
            return null;

        VerifyPayload(storage, payload);
        return payload;
    }

    public Task StoreAsync(
        string manifestKey,
        Manifest manifest,
        string payloadKey,
        byte[] payload,
        CancellationToken ct)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(manifestKey);
        ArgumentException.ThrowIfNullOrWhiteSpace(payloadKey);
        ArgumentNullException.ThrowIfNull(payload);

        ct.ThrowIfCancellationRequested();

        if (manifest.External == null)
            throw new ArgumentException("External storage info is required for external storage", nameof(manifest));

        var contentHash = ComputeSha256Hex(payload);
        var contentLength = (ulong)payload.Length;

        var storageInfo = StorageInfo.External(contentHash, contentLength);
        var updatedManifest = manifest with { Storage = storageInfo };
        updatedManifest.Validate();

        var manifestBytes = ManifestSerializer.Serialize(updatedManifest);
        var manifestKeyBytes = Encoding.UTF8.GetBytes(manifestKey);

        using var batch = _store.CreateWriteBatch();
        batch.Put(manifestKeyBytes, manifestBytes);

        lock (_lock)
        {
            _store.Write(batch);
        }

        return Task.CompletedTask;
    }

    public Task DeleteAsync(string manifestKey, string payloadKey, CancellationToken ct)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(manifestKey);
        ArgumentException.ThrowIfNullOrWhiteSpace(payloadKey);
        ct.ThrowIfCancellationRequested();

        using var batch = _store.CreateWriteBatch();
        batch.Delete(Encoding.UTF8.GetBytes(manifestKey));

        lock (_lock)
        {
            _store.Write(batch);
        }

        return Task.CompletedTask;
    }

    public async IAsyncEnumerable<string> EnumerateKeysAsync(
        string prefix,
        [System.Runtime.CompilerServices.EnumeratorCancellation] CancellationToken ct)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(prefix);
        ct.ThrowIfCancellationRequested();

        var prefixBytes = Encoding.UTF8.GetBytes(prefix);
        List<string> keys = new();

        lock (_lock)
        {
            using var iterator = _store.CreateIterator();
            iterator.Seek(prefixBytes);
            while (iterator.Valid && StartsWith(iterator.Key, prefixBytes))
            {
                keys.Add(Encoding.UTF8.GetString(iterator.Key));
                iterator.Next();
            }
        }

        foreach (var key in keys)
        {
            ct.ThrowIfCancellationRequested();
            await Task.Yield();
            yield return key;
        }
    }

    private static Task<byte[]?> FetchExternalPayloadAsync(ExternalStorageInfo external, CancellationToken ct)
    {
        // Placeholder for external fetch implementation (S3/Azure Blob/filesystem).
        // Implementers should use external.Uri and optional ETag/Backend to retrieve bytes.
        ct.ThrowIfCancellationRequested();
        throw new NotImplementedException($"External fetch not implemented for {external.Uri}");
    }

    private static void VerifyPayload(StorageInfo storage, byte[] payload)
    {
        var hash = ComputeSha256Hex(payload);
        if (!hash.Equals(storage.ContentHash, StringComparison.Ordinal))
            throw new InvalidOperationException("Payload content hash mismatch");

        if ((ulong)payload.Length != storage.ContentLength)
            throw new InvalidOperationException("Payload content length mismatch");
    }

    private static string ComputeSha256Hex(byte[] bytes)
    {
        var hashBytes = SHA256.HashData(bytes);
        var sb = new StringBuilder(hashBytes.Length * 2);
        foreach (var b in hashBytes)
        {
            sb.AppendFormat("{0:x2}", b);
        }
        return sb.ToString();
    }

    private static bool StartsWith(ReadOnlySpan<byte> value, ReadOnlySpan<byte> prefix)
    {
        if (value.Length < prefix.Length)
            return false;

        return value[..prefix.Length].SequenceEqual(prefix);
    }

    private byte[]? ReadBytes(byte[] key)
    {
        Span<byte> initialBuffer = stackalloc byte[1];
        if (_store.TryGet(key, initialBuffer, out var written))
        {
            return initialBuffer.Slice(0, written).ToArray();
        }

        if (written > 0)
        {
            var result = new byte[written];
            if (_store.TryGet(key, result, out var finalWritten))
            {
                return result;
            }
            throw new InvalidOperationException("Store state changed during read");
        }

        return null;
    }
}


// --- PATH: plugins/Geosphere.Plate.Cache.Materializer/Storage/IArtifactStorage.cs ---
using FantaSim.Geosphere.Plate.Cache.Contracts.Models;

namespace FantaSim.Geosphere.Plate.Cache.Materializer.Storage;

/// <summary>
/// Storage contract for derived artifacts (manifest + payload).
/// </summary>
public interface IArtifactStorage
{
    Task<Manifest?> GetManifestAsync(string key, CancellationToken ct);

    Task<byte[]?> GetPayloadAsync(string key, CancellationToken ct);

    Task StoreAsync(
        string manifestKey,
        Manifest manifest,
        string payloadKey,
        byte[] payload,
        CancellationToken ct);

    Task DeleteAsync(string manifestKey, string payloadKey, CancellationToken ct);

    IAsyncEnumerable<string> EnumerateKeysAsync(string prefix, CancellationToken ct);
}


// --- PATH: plugins/Geosphere.Plate.Cache.Materializer/Storage/KeyBuilder.cs ---
using System.Text;
using FantaSim.Geosphere.Plate.Topology.Contracts.Identity;

namespace FantaSim.Geosphere.Plate.Cache.Materializer.Storage;

/// <summary>
/// Builds derived artifact keys following RFC-V2-0006.
/// </summary>
public static class KeyBuilder
{
    private const string DerivedPrefix = "Derived";
    private const string ManifestSuffix = "Manifest";
    private const string PayloadSuffix = "Payload";

    /// <summary>
    /// Builds a manifest key for a derived artifact.
    /// Format: S:{variant}:{branch}:L{l}:{domain}:M{m}:Derived:{productType}:{inputFingerprint}:Manifest
    /// </summary>
    public static string BuildManifestKey(
        TruthStreamIdentity stream,
        string productType,
        string inputFingerprint)
    {
        ValidateInputs(stream, productType, inputFingerprint);
        return $"{BuildStreamPrefix(stream)}{DerivedPrefix}:{productType}:{inputFingerprint}:{ManifestSuffix}";
    }

    /// <summary>
    /// Builds a payload key for a derived artifact.
    /// Format: S:{variant}:{branch}:L{l}:{domain}:M{m}:Derived:{productType}:{inputFingerprint}:Payload
    /// </summary>
    public static string BuildPayloadKey(
        TruthStreamIdentity stream,
        string productType,
        string inputFingerprint)
    {
        ValidateInputs(stream, productType, inputFingerprint);
        return $"{BuildStreamPrefix(stream)}{DerivedPrefix}:{productType}:{inputFingerprint}:{PayloadSuffix}";
    }

    /// <summary>
    /// Builds a prefix for enumerating all derived artifacts under a stream and product type.
    /// Format: S:{variant}:{branch}:L{l}:{domain}:M{m}:Derived:{productType}:
    /// </summary>
    public static string BuildPrefixForEnumeration(
        TruthStreamIdentity stream,
        string productType)
    {
        if (!stream.IsValid())
        {
            throw new InvalidOperationException(
                $"TruthStreamIdentity is not valid: {stream}. Ensure VariantId, BranchId, Model are non-empty, LLevel >= 0, and Domain is well-formed.");
        }

        if (string.IsNullOrWhiteSpace(productType))
            throw new ArgumentException("ProductType cannot be null or empty", nameof(productType));

        return $"{BuildStreamPrefix(stream)}{DerivedPrefix}:{productType}:";
    }

    internal static string BuildStreamPrefix(TruthStreamIdentity stream)
    {
        if (!stream.IsValid())
        {
            throw new InvalidOperationException(
                $"TruthStreamIdentity is not valid: {stream}. Ensure VariantId, BranchId, Model are non-empty, LLevel >= 0, and Domain is well-formed.");
        }

        return $"S:{stream.ToStreamKey()}:";
    }

    internal static string DeriveManifestKeyFromPayloadKey(string payloadKey)
    {
        if (string.IsNullOrWhiteSpace(payloadKey))
            throw new ArgumentException("Payload key cannot be null or empty", nameof(payloadKey));

        const string suffix = ":Payload";
        if (!payloadKey.EndsWith(suffix, StringComparison.Ordinal))
            throw new ArgumentException("Payload key must end with ':Payload'", nameof(payloadKey));

        return string.Concat(payloadKey.AsSpan(0, payloadKey.Length - suffix.Length), ":Manifest");
    }

    private static void ValidateInputs(
        TruthStreamIdentity stream,
        string productType,
        string inputFingerprint)
    {
        if (!stream.IsValid())
        {
            throw new InvalidOperationException(
                $"TruthStreamIdentity is not valid: {stream}. Ensure VariantId, BranchId, Model are non-empty, LLevel >= 0, and Domain is well-formed.");
        }

        if (string.IsNullOrWhiteSpace(productType))
            throw new ArgumentException("ProductType cannot be null or empty", nameof(productType));

        if (string.IsNullOrWhiteSpace(inputFingerprint))
            throw new ArgumentException("InputFingerprint cannot be null or empty", nameof(inputFingerprint));
    }
}


// --- PATH: plugins/Geosphere.Plate.Datasets.Import/JsonPlatesDatasetLoader.cs ---
using System.IO;
using System.Text.Json;
using System.Text.Json.Serialization;
using FantaSim.Geosphere.Plate.Datasets.Contracts.Loading;
using FantaSim.Geosphere.Plate.Datasets.Contracts.Manifest;
using FantaSim.Geosphere.Plate.Datasets.Contracts.Validation;

namespace FantaSim.Geosphere.Plate.Datasets.Import;

public sealed class JsonPlatesDatasetLoader : IPlatesDatasetLoader
{
    private static readonly JsonSerializerOptions JsonOptions = new()
    {
        PropertyNameCaseInsensitive = false,
        PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
        Converters = { new JsonStringEnumConverter(JsonNamingPolicy.CamelCase) }
    };

    public async Task<PlatesDatasetLoadResult> LoadAsync(
        string datasetRootPath,
        PlatesDatasetLoadOptions? options,
        CancellationToken cancellationToken)
    {
        options ??= new PlatesDatasetLoadOptions();

        if (string.IsNullOrWhiteSpace(datasetRootPath))
        {
            return new PlatesDatasetLoadResult(
                null,
                new[] { new DatasetValidationError("dataset_root.required", "datasetRootPath", "Dataset root path is required.") });
        }

        if (!Directory.Exists(datasetRootPath))
        {
            return new PlatesDatasetLoadResult(
                null,
                new[] { new DatasetValidationError("dataset_root.missing", "datasetRootPath", "Dataset root path does not exist.") });
        }

        var manifestPath = Path.Combine(datasetRootPath, options.ManifestFileName);
        if (!File.Exists(manifestPath))
        {
            return new PlatesDatasetLoadResult(
                null,
                new[] { new DatasetValidationError("manifest.missing", "manifest", "Dataset manifest file does not exist.") });
        }

        PlatesDatasetManifest? manifest;
        try
        {
            await using var stream = File.OpenRead(manifestPath);
            manifest = await JsonSerializer.DeserializeAsync<PlatesDatasetManifest>(stream, JsonOptions, cancellationToken).ConfigureAwait(false);
        }
        catch (JsonException)
        {
            return new PlatesDatasetLoadResult(
                null,
                new[] { new DatasetValidationError("manifest.json.invalid", "manifest", "Dataset manifest JSON is invalid.") });
        }
        catch (IOException)
        {
            return new PlatesDatasetLoadResult(
                null,
                new[] { new DatasetValidationError("manifest.read_failed", "manifest", "Failed to read dataset manifest file.") });
        }

        if (manifest is null)
        {
            return new PlatesDatasetLoadResult(
                null,
                new[] { new DatasetValidationError("manifest.json.null", "manifest", "Dataset manifest JSON deserialized to null.") });
        }

        var errors = PlatesDatasetManifestValidator.Validate(manifest).ToList();

        var assets = new List<ResolvedAsset>();

        BuildAssets(datasetRootPath, "featureSets", manifest.FeatureSets, PlatesAssetKind.FeatureSet, options.ValidateOnly, assets, errors);
        BuildAssets(datasetRootPath, "rasterSequences", manifest.RasterSequences, PlatesAssetKind.RasterSequence, options.ValidateOnly, assets, errors);
        BuildAssets(datasetRootPath, "motionModels", manifest.MotionModels, PlatesAssetKind.MotionModel, options.ValidateOnly, assets, errors);

        errors.Sort(static (a, b) =>
        {
            var c = string.Compare(a.Code, b.Code, StringComparison.Ordinal);
            if (c != 0)
                return c;

            c = string.Compare(a.Path, b.Path, StringComparison.Ordinal);
            if (c != 0)
                return c;

            return string.Compare(a.Message, b.Message, StringComparison.Ordinal);
        });

        if (errors.Count != 0)
            return new PlatesDatasetLoadResult(null, errors);

        assets.Sort(static (a, b) =>
        {
            var c = a.Kind.CompareTo(b.Kind);
            if (c != 0)
                return c;

            c = string.Compare(a.AssetId, b.AssetId, StringComparison.Ordinal);
            if (c != 0)
                return c;

            return string.Compare(a.AbsolutePath, b.AbsolutePath, StringComparison.Ordinal);
        });

        return new PlatesDatasetLoadResult(
            new PlatesDataset(datasetRootPath, manifest, assets),
            Array.Empty<DatasetValidationError>());
    }

    private static void BuildAssets<TAsset>(
        string datasetRootPath,
        string group,
        TAsset[]? rawAssets,
        PlatesAssetKind kind,
        bool validateOnly,
        List<ResolvedAsset> resolved,
        List<DatasetValidationError> errors)
        where TAsset : class
    {
        var assets = rawAssets ?? Array.Empty<TAsset>();

        for (var i = 0; i < assets.Length; i++)
        {
            var asset = assets[i];

            string assetId;
            string relativePath;
            string format;

            switch (asset)
            {
                case FeatureSetAsset fs:
                    assetId = fs.AssetId;
                    relativePath = fs.RelativePath;
                    format = fs.Format;
                    break;
                case RasterSequenceAsset rs:
                    assetId = rs.AssetId;
                    relativePath = rs.RelativePath;
                    format = rs.Format;
                    break;
                case MotionModelAsset mm:
                    assetId = mm.AssetId;
                    relativePath = mm.RelativePath;
                    format = mm.Format;
                    break;
                default:
                    continue;
            }

            if (!PathResolver.TryResolveFile(datasetRootPath, relativePath, out var absolutePath))
            {
                errors.Add(new DatasetValidationError("asset_path.invalid", $"{group}[{i}].relativePath", "Asset path is invalid."));
                continue;
            }

            if (!validateOnly && !File.Exists(absolutePath))
            {
                errors.Add(new DatasetValidationError("asset_file.missing", $"{group}[{i}].relativePath", "Referenced asset file does not exist."));
                continue;
            }

            resolved.Add(new ResolvedAsset(kind, assetId, absolutePath, format));
        }
    }
}


// --- PATH: plugins/Geosphere.Plate.Datasets.Import/PathResolver.cs ---
using System.IO;

namespace FantaSim.Geosphere.Plate.Datasets.Import;

internal static class PathResolver
{
    public static bool TryResolveFile(string datasetRootPath, string relativePath, out string absolutePath)
    {
        absolutePath = string.Empty;

        if (string.IsNullOrWhiteSpace(datasetRootPath) || string.IsNullOrWhiteSpace(relativePath))
            return false;

        if (Path.IsPathRooted(relativePath))
            return false;

        var segments = relativePath.Replace('\\', '/').Split('/');
        foreach (var seg in segments)
        {
            if (seg == "..")
                return false;
        }

        var rootFull = Path.GetFullPath(datasetRootPath);
        var candidate = Path.GetFullPath(Path.Combine(rootFull, relativePath));

        var rootWithSep = rootFull.EndsWith(Path.DirectorySeparatorChar)
            ? rootFull
            : rootFull + Path.DirectorySeparatorChar;

        if (!candidate.StartsWith(rootWithSep, StringComparison.OrdinalIgnoreCase))
            return false;

        absolutePath = candidate;
        return true;
    }
}


// --- PATH: plugins/Geosphere.Plate.Datasets.Import/PlatesDataset.cs ---
using FantaSim.Geosphere.Plate.Datasets.Contracts.Loading;
using FantaSim.Geosphere.Plate.Datasets.Contracts.Manifest;

namespace FantaSim.Geosphere.Plate.Datasets.Import;

internal sealed class PlatesDataset : IPlatesDataset
{
    public PlatesDataset(string datasetRootPath, PlatesDatasetManifest manifest, IReadOnlyList<ResolvedAsset> assets)
    {
        DatasetRootPath = datasetRootPath;
        Manifest = manifest;
        Assets = assets;
    }

    public string DatasetRootPath { get; }

    public PlatesDatasetManifest Manifest { get; }

    public IReadOnlyList<ResolvedAsset> Assets { get; }
}


// --- PATH: plugins/Geosphere.Plate.Datasets.Import/PlatesDatasetIngestor.cs ---
using System.IO;
using System.Security.Cryptography;
using System.Text;
using System.Text.Json;
using FantaSim.Geosphere.Plate.Datasets.Contracts.Canonicalization;
using FantaSim.Geosphere.Plate.Datasets.Contracts.Ingest;
using FantaSim.Geosphere.Plate.Datasets.Contracts.Loading;
using FantaSim.Geosphere.Plate.Datasets.Contracts.Manifest;
using FantaSim.Geosphere.Plate.Datasets.Contracts.Validation;
using FantaSim.Geosphere.Plate.Kinematics.Contracts.Entities;
using FantaSim.Geosphere.Plate.Kinematics.Contracts.Events;
using FantaSim.Geosphere.Plate.Kinematics.Contracts.Numerics;
using FantaSim.Geosphere.Plate.Topology.Contracts.Entities;
using FantaSim.Geosphere.Plate.Topology.Contracts.Identity;
using Plate.TimeDete.Time.Primitives;
using Plate.TimeDete.Traceability.HashChain;
using Plate.TimeDete.Traceability.Hashing;

namespace FantaSim.Geosphere.Plate.Datasets.Import;

public sealed class PlatesDatasetIngestor : IPlatesDatasetIngestor
{
    private readonly IPlatesDatasetLoader _loader;
    private readonly IKinematicsEventStore? _kinematicsEventStore;

    public PlatesDatasetIngestor(IPlatesDatasetLoader loader, IKinematicsEventStore? kinematicsEventStore)
    {
        ArgumentNullException.ThrowIfNull(loader);
        _loader = loader;
        _kinematicsEventStore = kinematicsEventStore;
    }

    public PlatesDatasetIngestor(IKinematicsEventStore? kinematicsEventStore)
        : this(new JsonPlatesDatasetLoader(), kinematicsEventStore)
    {
    }

    public async Task<PlatesDatasetIngestResult> IngestAsync(
        string datasetRootPath,
        PlatesDatasetIngestSpec spec,
        PlatesDatasetLoadOptions? loadOptions,
        CancellationToken cancellationToken)
    {
        loadOptions ??= new PlatesDatasetLoadOptions();

        if (spec is null)
        {
            return new PlatesDatasetIngestResult(
                null,
                Array.Empty<TruthStreamIdentity>(),
                null,
                new[] { new DatasetValidationError("ingest_spec.required", "spec", "Ingest spec is required.") });
        }

        var loadResult = await _loader.LoadAsync(datasetRootPath, loadOptions, cancellationToken).ConfigureAwait(false);
        if (!loadResult.IsSuccess)
        {
            return new PlatesDatasetIngestResult(
                loadResult.Dataset,
                Array.Empty<TruthStreamIdentity>(),
                null,
                loadResult.Errors);
        }

        var dataset = loadResult.Dataset!;

        if (spec.Mode == IngestMode.AssetOnly)
        {
            var audit = BuildAudit(dataset, loadOptions.ManifestFileName, targets: Array.Empty<PlatesAssetIngestTarget>(), streams: Array.Empty<PlatesDatasetIngestStreamAudit>());
            return new PlatesDatasetIngestResult(
                dataset,
                Array.Empty<TruthStreamIdentity>(),
                audit,
                Array.Empty<DatasetValidationError>());
        }

        if (spec.Mode != IngestMode.Ingest)
        {
            var audit = BuildAudit(dataset, loadOptions.ManifestFileName, targets: spec.Targets ?? Array.Empty<PlatesAssetIngestTarget>(), streams: Array.Empty<PlatesDatasetIngestStreamAudit>());
            return new PlatesDatasetIngestResult(
                dataset,
                Array.Empty<TruthStreamIdentity>(),
                audit,
                new[] { new DatasetValidationError("ingest_mode.invalid", "mode", "Ingest mode is invalid.") });
        }

        var errors = new List<DatasetValidationError>();
        var producedStreams = new List<TruthStreamIdentity>();

        var perStreamPlans = new Dictionary<TruthStreamIdentity, List<KinematicsEventPlan>>(new TruthStreamIdentityEqualityComparer());

        var targets = spec.Targets ?? Array.Empty<PlatesAssetIngestTarget>();
        for (var i = 0; i < targets.Length; i++)
        {
            var t = targets[i];
            var basePath = $"targets[{i}]";

            if (t is null)
            {
                errors.Add(new DatasetValidationError("ingest_target.required", basePath, "Ingest target is required."));
                continue;
            }

            if (string.IsNullOrWhiteSpace(t.AssetId))
            {
                errors.Add(new DatasetValidationError("ingest_target.asset_id.required", $"{basePath}.assetId", "AssetId is required."));
                continue;
            }

            if (!t.StreamIdentity.IsValid())
            {
                errors.Add(new DatasetValidationError("ingest_target.stream.invalid", $"{basePath}.streamIdentity", "StreamIdentity is invalid."));
                continue;
            }

            var resolved = dataset.Assets.FirstOrDefault(a => a.Kind == t.Kind && string.Equals(a.AssetId, t.AssetId, StringComparison.Ordinal));
            if (resolved is null)
            {
                errors.Add(new DatasetValidationError("ingest_target.asset_missing", basePath, "Target asset was not found in the loaded dataset."));
                continue;
            }

            producedStreams.Add(t.StreamIdentity);

            switch (t.Kind)
            {
                case PlatesAssetKind.MotionModel:
                    if (t.StreamIdentity.Domain != Domain.GeoPlatesKinematics)
                    {
                        errors.Add(new DatasetValidationError(
                            "ingest_target.domain.invalid",
                            $"{basePath}.streamIdentity.domain",
                            "Motion model targets must use domain geo.plates.kinematics."));
                        continue;
                    }

                    if (_kinematicsEventStore is null)
                    {
                        errors.Add(new DatasetValidationError(
                            "ingest.kinematics_store.required",
                            "kinematicsEventStore",
                            "A kinematics event store is required for ingest."));
                        continue;
                    }

                    if (!string.Equals(resolved.Format, "segments-v1", StringComparison.OrdinalIgnoreCase))
                    {
                        errors.Add(new DatasetValidationError(
                            "motion_model.format.unsupported",
                            basePath,
                            "Motion model format is not supported for ingest."));
                        continue;
                    }

                    var motionModelErrors = new List<DatasetValidationError>();
                    var plans = await SegmentsV1MotionModelParser.BuildKinematicsPlansAsync(
                        resolved.AbsolutePath,
                        dataset.Manifest.DatasetId,
                        resolved.AssetId,
                        t.StreamIdentity,
                        motionModelErrors,
                        cancellationToken).ConfigureAwait(false);

                    if (motionModelErrors.Count != 0)
                    {
                        errors.AddRange(motionModelErrors.Select(e => e with { Path = $"{basePath}.{e.Path}" }));
                        continue;
                    }

                    if (!perStreamPlans.TryGetValue(t.StreamIdentity, out var streamPlans))
                    {
                        streamPlans = new List<KinematicsEventPlan>();
                        perStreamPlans.Add(t.StreamIdentity, streamPlans);
                    }

                    streamPlans.AddRange(plans);
                    break;

                case PlatesAssetKind.FeatureSet:
                case PlatesAssetKind.RasterSequence:
                default:
                    errors.Add(new DatasetValidationError(
                        "ingest_target.kind.not_supported",
                        basePath,
                        "Ingest for this asset kind is not supported yet."));
                    break;
            }
        }

        producedStreams.Sort(static (a, b) => string.Compare(a.ToStreamKey(), b.ToStreamKey(), StringComparison.Ordinal));
        producedStreams = producedStreams.Distinct().ToList();

        errors.Sort(static (a, b) =>
        {
            var c = string.Compare(a.Code, b.Code, StringComparison.Ordinal);
            if (c != 0)
                return c;

            c = string.Compare(a.Path, b.Path, StringComparison.Ordinal);
            if (c != 0)
                return c;

            return string.Compare(a.Message, b.Message, StringComparison.Ordinal);
        });

        if (errors.Count != 0)
        {
            var audit = BuildAudit(dataset, loadOptions.ManifestFileName, targets, streams: Array.Empty<PlatesDatasetIngestStreamAudit>());
            return new PlatesDatasetIngestResult(dataset, producedStreams, audit, errors);
        }

        if (_kinematicsEventStore is null)
        {
            var audit = BuildAudit(dataset, loadOptions.ManifestFileName, targets, streams: Array.Empty<PlatesDatasetIngestStreamAudit>());
            return new PlatesDatasetIngestResult(
                dataset,
                producedStreams,
                audit,
                new[] { new DatasetValidationError("ingest.kinematics_store.required", "kinematicsEventStore", "A kinematics event store is required for ingest.") });
        }

        var orderedStreams = perStreamPlans.Keys
            .OrderBy(s => s.ToStreamKey(), StringComparer.Ordinal)
            .ToList();

        var streamAudits = new List<PlatesDatasetIngestStreamAudit>();

        foreach (var stream in orderedStreams)
        {
            cancellationToken.ThrowIfCancellationRequested();

            var plans = perStreamPlans[stream];
            plans.Sort(KinematicsEventPlan.Compare);

            var lastSeq = await _kinematicsEventStore.GetLastSequenceAsync(stream, cancellationToken).ConfigureAwait(false);
            var nextSeq = lastSeq.HasValue ? lastSeq.Value + 1 : 0;

            var events = new List<IPlateKinematicsEvent>(plans.Count);
            for (var i = 0; i < plans.Count; i++)
            {
                var seq = nextSeq + i;
                var evtId = DeterministicIdPolicy.DeriveEventId(dataset.Manifest.DatasetId, plans[i].AssetId, seq);
                events.Add(plans[i].Create(evtId, seq));
            }

            var eventIdDigest = ComputeEventIdDigest(events);
            streamAudits.Add(new PlatesDatasetIngestStreamAudit(
                stream.ToStreamKey(),
                events.Count,
                events.Count == 0 ? -1 : events[0].Sequence,
                events.Count == 0 ? -1 : events[^1].Sequence,
                eventIdDigest));

            await _kinematicsEventStore.AppendAsync(stream, events, cancellationToken).ConfigureAwait(false);
        }

        streamAudits.Sort(static (a, b) => string.Compare(a.StreamKey, b.StreamKey, StringComparison.Ordinal));

        var finalAudit = BuildAudit(dataset, loadOptions.ManifestFileName, targets, streamAudits);
        return new PlatesDatasetIngestResult(dataset, producedStreams, finalAudit, Array.Empty<DatasetValidationError>());
    }

    private static PlatesDatasetIngestAudit BuildAudit(
        IPlatesDataset dataset,
        string manifestFileName,
        PlatesAssetIngestTarget[] targets,
        IReadOnlyList<PlatesDatasetIngestStreamAudit> streams)
    {
        var manifestPath = Path.Combine(dataset.DatasetRootPath, manifestFileName);

        // Read manifest file once - manifest files are typically small (metadata only)
        byte[] manifestBytes;
        try
        {
            manifestBytes = File.ReadAllBytes(manifestPath);
        }
        catch (FileNotFoundException ex)
        {
            throw new FileNotFoundException(
                $"Manifest file not found: {manifestPath}", ex);
        }
        catch (IOException ex)
        {
            throw new IOException(
                $"I/O error reading manifest file: {manifestPath}", ex);
        }

        var manifestFileSha256 = Sha256Hex.ComputeLowerHex(manifestBytes);

        var manifest = dataset.Manifest;
        var canonicalManifestObject = new
        {
            datasetId = manifest.DatasetId,
            bodyId = manifest.BodyId,
            bodyFrame = manifest.BodyFrame,
            timeMapping = manifest.TimeMapping,
            canonicalizationRules = manifest.CanonicalizationRules,
            featureSets = (manifest.FeatureSets ?? Array.Empty<FeatureSetAsset>())
                .OrderBy(a => a.AssetId, StringComparer.Ordinal)
                .ThenBy(a => a.RelativePath, StringComparer.Ordinal)
                .ThenBy(a => a.Format, StringComparer.Ordinal)
                .ToArray(),
            rasterSequences = (manifest.RasterSequences ?? Array.Empty<RasterSequenceAsset>())
                .OrderBy(a => a.AssetId, StringComparer.Ordinal)
                .ThenBy(a => a.RelativePath, StringComparer.Ordinal)
                .ThenBy(a => a.Format, StringComparer.Ordinal)
                .ToArray(),
            motionModels = (manifest.MotionModels ?? Array.Empty<MotionModelAsset>())
                .OrderBy(a => a.AssetId, StringComparer.Ordinal)
                .ThenBy(a => a.RelativePath, StringComparer.Ordinal)
                .ThenBy(a => a.Format, StringComparer.Ordinal)
                .ToArray(),
        };

        var canonicalManifestJson = CanonicalJsonSerializer.Serialize(canonicalManifestObject);
        var manifestCanonicalSha256 = Sha256Hex.ComputeLowerHex(canonicalManifestJson);

        var assetMeta = new Dictionary<(PlatesAssetKind Kind, string AssetId), (string RelativePath, string Format)>();

        var featureSets = dataset.Manifest.FeatureSets ?? Array.Empty<FeatureSetAsset>();
        foreach (var fs in featureSets)
            assetMeta[(PlatesAssetKind.FeatureSet, fs.AssetId)] = (fs.RelativePath, fs.Format);

        var rasterSequences = dataset.Manifest.RasterSequences ?? Array.Empty<RasterSequenceAsset>();
        foreach (var rs in rasterSequences)
            assetMeta[(PlatesAssetKind.RasterSequence, rs.AssetId)] = (rs.RelativePath, rs.Format);

        var motionModels = dataset.Manifest.MotionModels ?? Array.Empty<MotionModelAsset>();
        foreach (var mm in motionModels)
            assetMeta[(PlatesAssetKind.MotionModel, mm.AssetId)] = (mm.RelativePath, mm.Format);

        var assets = dataset.Assets ?? Array.Empty<ResolvedAsset>();
        var assetAudits = new List<PlatesDatasetIngestAssetAudit>(assets.Count);

        foreach (var a in assets)
        {
            if (!assetMeta.TryGetValue((a.Kind, a.AssetId), out var meta))
                meta = (Path.GetFileName(a.AbsolutePath) ?? string.Empty, a.Format);

            var rel = (meta.RelativePath ?? string.Empty).Replace('\\', '/');

            // Use streaming hash computation - will throw if file is missing or inaccessible
            string fileSha256;
            try
            {
                fileSha256 = ComputeFileSha256Streaming(a.AbsolutePath);
            }
            catch (FileNotFoundException ex)
            {
                throw new FileNotFoundException(
                    $"Asset file not found during ingest audit computation. The asset was resolved earlier but is now missing. AssetId: {a.AssetId}, Kind: {a.Kind}, Path: {a.AbsolutePath}",
                    ex);
            }
            catch (IOException ex)
            {
                throw new IOException(
                    $"I/O error reading asset file during ingest audit computation. AssetId: {a.AssetId}, Kind: {a.Kind}, Path: {a.AbsolutePath}",
                    ex);
            }
            catch (UnauthorizedAccessException ex)
            {
                throw new UnauthorizedAccessException(
                    $"Access denied to asset file during ingest audit computation. AssetId: {a.AssetId}, Kind: {a.Kind}, Path: {a.AbsolutePath}",
                    ex);
            }

            assetAudits.Add(new PlatesDatasetIngestAssetAudit(
                a.AssetId,
                a.Kind.ToString(),
                rel,
                meta.Format,
                fileSha256));
        }

        assetAudits.Sort(static (a, b) =>
        {
            var c = string.Compare(a.Kind, b.Kind, StringComparison.Ordinal);
            if (c != 0)
                return c;
            c = string.Compare(a.AssetId, b.AssetId, StringComparison.Ordinal);
            if (c != 0)
                return c;
            return string.Compare(a.RelativePath, b.RelativePath, StringComparison.Ordinal);
        });

        var targetAudits = (targets ?? Array.Empty<PlatesAssetIngestTarget>())
            .Where(t => t is not null)
            .Select(t => new PlatesDatasetIngestTargetAudit(
                t!.AssetId,
                t.Kind.ToString(),
                t.StreamIdentity.ToStreamKey()))
            .OrderBy(t => t.Kind, StringComparer.Ordinal)
            .ThenBy(t => t.AssetId, StringComparer.Ordinal)
            .ThenBy(t => t.StreamKey, StringComparer.Ordinal)
            .ToArray();

        var rules = dataset.Manifest.CanonicalizationRules;

        var payloadForAuditHash = new
        {
            datasetId = dataset.Manifest.DatasetId,
            bodyId = dataset.Manifest.BodyId,
            manifestFileName,
            manifestFileSha256,
            manifestCanonicalSha256,
            stableIdPolicyId = rules.StableIdPolicyId,
            assetOrderingPolicyId = rules.AssetOrderingPolicyId,
            quantizationPolicyId = rules.QuantizationPolicyId,
            assets = assetAudits,
            targets = targetAudits,
            streams = streams
        };

        var canonicalAuditJson = CanonicalJsonSerializer.Serialize(payloadForAuditHash);
        var auditSha256 = Sha256Hex.ComputeLowerHex(Encoding.UTF8.GetBytes(canonicalAuditJson));

        return new PlatesDatasetIngestAudit(
            dataset.Manifest.DatasetId,
            dataset.Manifest.BodyId,
            manifestFileName,
            manifestFileSha256,
            manifestCanonicalSha256,
            rules.StableIdPolicyId,
            rules.AssetOrderingPolicyId,
            rules.QuantizationPolicyId,
            assetAudits.ToArray(),
            targetAudits,
            streams.ToArray(),
            auditSha256);
    }

    /// <summary>
    /// Computes SHA256 hash of a file using streaming to avoid loading entire file into memory.
    /// </summary>
    /// <param name="filePath">The path to the file to hash.</param>
    /// <returns>A lowercase hexadecimal string representation of the SHA256 hash.</returns>
    /// <exception cref="FileNotFoundException">Thrown when the file does not exist.</exception>
    /// <exception cref="IOException">Thrown when an I/O error occurs while reading the file.</exception>
    /// <exception cref="UnauthorizedAccessException">Thrown when access to the file is denied.</exception>
    private static string ComputeFileSha256Streaming(string filePath)
    {
        using var stream = File.OpenRead(filePath);
        using var sha256 = SHA256.Create();
        var hashBytes = sha256.ComputeHash(stream);
        return Convert.ToHexString(hashBytes).ToLowerInvariant();
    }

    private static string ComputeEventIdDigest(IReadOnlyList<IPlateKinematicsEvent> events)
    {
        var hasher = new Sha256HashChainHasher();
        string? previous = null;

        for (var i = 0; i < events.Count; i++)
        {
            var payload = $"{events[i].Sequence}:{events[i].EventId:D}";
            var bytes = Encoding.UTF8.GetBytes(payload);
            previous = HashChain.ComputeNextHash(hasher, bytes, previous);
        }

        return previous ?? Sha256Hex.ComputeLowerHex(Array.Empty<byte>());
    }

    private sealed class TruthStreamIdentityEqualityComparer : IEqualityComparer<TruthStreamIdentity>
    {
        public bool Equals(TruthStreamIdentity x, TruthStreamIdentity y) => x.Equals(y);

        public int GetHashCode(TruthStreamIdentity obj) => obj.GetHashCode();
    }

    private sealed record KinematicsEventPlan(
        string AssetId,
        int KindOrder,
        string OrderKey,
        Func<Guid, long, IPlateKinematicsEvent> Create)
    {
        public static int Compare(KinematicsEventPlan a, KinematicsEventPlan b)
        {
            var c = a.KindOrder.CompareTo(b.KindOrder);
            if (c != 0)
                return c;

            c = string.Compare(a.OrderKey, b.OrderKey, StringComparison.Ordinal);
            if (c != 0)
                return c;

            return string.Compare(a.AssetId, b.AssetId, StringComparison.Ordinal);
        }
    }

    private static class SegmentsV1MotionModelParser
    {
        private static readonly JsonSerializerOptions JsonOptions = new()
        {
            PropertyNameCaseInsensitive = false,
            PropertyNamingPolicy = JsonNamingPolicy.CamelCase
        };

        public static async Task<IReadOnlyList<KinematicsEventPlan>> BuildKinematicsPlansAsync(
            string motionModelPath,
            string datasetId,
            string assetId,
            TruthStreamIdentity stream,
            List<DatasetValidationError> errors,
            CancellationToken cancellationToken)
        {
            ArgumentNullException.ThrowIfNull(errors);

            if (string.IsNullOrWhiteSpace(motionModelPath))
            {
                errors.Add(new DatasetValidationError("motion_model.path.required", "motionModel.path", "Motion model path is required."));
                return Array.Empty<KinematicsEventPlan>();
            }

            if (!File.Exists(motionModelPath))
            {
                errors.Add(new DatasetValidationError("motion_model.file.missing", "motionModel.path", "Motion model file does not exist."));
                return Array.Empty<KinematicsEventPlan>();
            }

            MotionModelSegmentsV1? doc;
            try
            {
                await using var streamIn = File.OpenRead(motionModelPath);
                doc = await JsonSerializer.DeserializeAsync<MotionModelSegmentsV1>(streamIn, JsonOptions, cancellationToken).ConfigureAwait(false);
            }
            catch (JsonException)
            {
                errors.Add(new DatasetValidationError("motion_model.json.invalid", "motionModel", "Motion model JSON is invalid."));
                return Array.Empty<KinematicsEventPlan>();
            }
            catch (IOException)
            {
                errors.Add(new DatasetValidationError("motion_model.read_failed", "motionModel", "Failed to read motion model file."));
                return Array.Empty<KinematicsEventPlan>();
            }

            if (doc is null)
            {
                errors.Add(new DatasetValidationError("motion_model.json.null", "motionModel", "Motion model JSON deserialized to null."));
                return Array.Empty<KinematicsEventPlan>();
            }

            if (!string.Equals(doc.Schema, "segments-v1", StringComparison.OrdinalIgnoreCase))
            {
                errors.Add(new DatasetValidationError("motion_model.schema.invalid", "motionModel.schema", "Motion model schema must be segments-v1."));
            }

            if (string.IsNullOrWhiteSpace(doc.ModelId))
            {
                errors.Add(new DatasetValidationError("motion_model.model_id.required", "motionModel.modelId", "ModelId is required."));
            }

            var plates = doc.Plates ?? Array.Empty<MotionModelPlateV1>();
            var plateKeys = new HashSet<string>(StringComparer.Ordinal);

            for (var i = 0; i < plates.Length; i++)
            {
                var p = plates[i];
                var platePath = $"motionModel.plates[{i}]";

                if (p is null)
                {
                    errors.Add(new DatasetValidationError("motion_model.plate.required", platePath, "Plate entry is required."));
                    continue;
                }

                if (string.IsNullOrWhiteSpace(p.PlateKey))
                {
                    errors.Add(new DatasetValidationError("motion_model.plate_key.required", $"{platePath}.plateKey", "PlateKey is required."));
                    continue;
                }

                if (!plateKeys.Add(p.PlateKey))
                {
                    errors.Add(new DatasetValidationError("motion_model.plate_key.duplicate", $"{platePath}.plateKey", "PlateKey must be unique."));
                }

                var segments = p.Segments ?? Array.Empty<MotionModelSegmentV1>();
                for (var j = 0; j < segments.Length; j++)
                {
                    var s = segments[j];
                    var segPath = $"{platePath}.segments[{j}]";
                    if (s is null)
                    {
                        errors.Add(new DatasetValidationError("motion_model.segment.required", segPath, "Segment entry is required."));
                        continue;
                    }

                    if (s.TickA < 0)
                        errors.Add(new DatasetValidationError("motion_model.segment.tick_a.invalid", $"{segPath}.tickA", "TickA must be non-negative."));

                    if (s.TickB < 0)
                        errors.Add(new DatasetValidationError("motion_model.segment.tick_b.invalid", $"{segPath}.tickB", "TickB must be non-negative."));

                    if (s.TickB <= s.TickA)
                        errors.Add(new DatasetValidationError("motion_model.segment.tick_range.invalid", segPath, "Segment must satisfy tickB > tickA."));
                }
            }

            if (errors.Count != 0)
            {
                errors.Sort(static (a, b) =>
                {
                    var c = string.Compare(a.Code, b.Code, StringComparison.Ordinal);
                    if (c != 0)
                        return c;
                    c = string.Compare(a.Path, b.Path, StringComparison.Ordinal);
                    if (c != 0)
                        return c;
                    return string.Compare(a.Message, b.Message, StringComparison.Ordinal);
                });
                return Array.Empty<KinematicsEventPlan>();
            }

            var plans = new List<KinematicsEventPlan>();

            var orderedPlates = plates
                .Where(p => p is not null)
                .OrderBy(p => p!.PlateKey, StringComparer.Ordinal)
                .ToList();

            foreach (var plate in orderedPlates)
            {
                var plateKey = plate!.PlateKey;

                var plateGuid = TryParseGuid(plate.PlateId)
                    ?? DeterministicIdPolicy.DeriveStableId(datasetId, assetId, "plate", plateKey);

                var plateId = new PlateId(plateGuid);

                var segments = (plate.Segments ?? Array.Empty<MotionModelSegmentV1>())
                    .Where(s => s is not null)
                    .OrderBy(s => s!.TickA)
                    .ThenBy(s => s!.TickB)
                    .ThenBy(s => s!.AxisAzimuthMicroDeg)
                    .ThenBy(s => s!.AxisElevationMicroDeg)
                    .ThenBy(s => s!.AngleMicroDeg)
                    .ToList();

                var assignTick = segments.Count != 0 ? segments[0]!.TickA : 0;

                plans.Add(new KinematicsEventPlan(
                    assetId,
                    KindOrder: 0,
                    OrderKey: $"plate:{plateKey}",
                    Create: (eventId, sequence) => new PlateMotionModelAssignedEvent(
                        eventId,
                        plateId,
                        doc.ModelId,
                        new CanonicalTick(assignTick),
                        sequence,
                        stream,
                        ReadOnlyMemory<byte>.Empty,
                        ReadOnlyMemory<byte>.Empty)));

                foreach (var seg in segments)
                {
                    var tickA = new CanonicalTick(seg!.TickA);
                    var tickB = new CanonicalTick(seg.TickB);

                    var segmentKey = $"{plateKey}:{seg.TickA}:{seg.TickB}:{seg.AxisAzimuthMicroDeg}:{seg.AxisElevationMicroDeg}:{seg.AngleMicroDeg}";
                    var segGuid = TryParseGuid(seg.SegmentId)
                        ?? DeterministicIdPolicy.DeriveStableId(datasetId, assetId, "segment", segmentKey);
                    var segmentId = new MotionSegmentId(segGuid);

                    var rot = QuantizedEulerPoleRotation.Create(seg.AxisAzimuthMicroDeg, seg.AxisElevationMicroDeg, seg.AngleMicroDeg);

                    plans.Add(new KinematicsEventPlan(
                        assetId,
                        KindOrder: 1,
                        OrderKey: $"seg:{plateKey}:{seg.TickA:D20}:{seg.TickB:D20}:{seg.AxisAzimuthMicroDeg:D11}:{seg.AxisElevationMicroDeg:D11}:{seg.AngleMicroDeg:D11}",
                        Create: (eventId, sequence) => new MotionSegmentUpsertedEvent(
                            eventId,
                            plateId,
                            segmentId,
                            tickA,
                            tickB,
                            rot,
                            tickA,
                            sequence,
                            stream,
                            ReadOnlyMemory<byte>.Empty,
                            ReadOnlyMemory<byte>.Empty)));
                }
            }

            plans.Sort(KinematicsEventPlan.Compare);
            return plans;
        }

        private static Guid? TryParseGuid(string? value)
        {
            if (string.IsNullOrWhiteSpace(value))
                return null;
            return Guid.TryParse(value, out var g) ? g : null;
        }

        private sealed record MotionModelSegmentsV1(
            string Schema,
            string ModelId,
            MotionModelPlateV1[] Plates);

        private sealed record MotionModelPlateV1(
            string PlateKey,
            string? PlateId,
            MotionModelSegmentV1[] Segments);

        private sealed record MotionModelSegmentV1(
            long TickA,
            long TickB,
            int AxisAzimuthMicroDeg,
            int AxisElevationMicroDeg,
            int AngleMicroDeg,
            string? SegmentId);
    }
}


// --- PATH: plugins/Geosphere.Plate.Junction.Solver/JunctionAnalyzer.cs ---
﻿using System.Collections.Immutable;
using FantaSim.Geosphere.Plate.Junction.Contracts.Diagnostics;
using FantaSim.Geosphere.Plate.Junction.Contracts.Products;
using FantaSim.Geosphere.Plate.Junction.Contracts.Solvers;
using FantaSim.Geosphere.Plate.Kinematics.Contracts.Derived;
using FantaSim.Geosphere.Plate.Topology.Contracts.Derived;
using FantaSim.Geosphere.Plate.Topology.Contracts.Entities;
using FantaSim.Geosphere.Plate.Topology.Contracts.Numerics;
using FantaSim.Geosphere.Plate.Velocity.Contracts;
using Plate.TimeDete.Time.Primitives;
using UnifyGeometry;

namespace FantaSim.Geosphere.Plate.Junction.Solver;

/// <summary>
/// Implementation of junction analysis per RFC-V2-0042.
/// </summary>
/// <remarks>
/// <para>
/// <b>Determinism:</b> All methods produce identical results for identical inputs.
/// </para>
/// <para>
/// <b>Incident ordering (§10.1):</b> Incidents are sorted by tangent angle (CCW from North),
/// computed in the local tangent plane at the junction's surface point. Ties broken by BoundaryId.
/// </para>
/// <para>
/// <b>Sphere-correct:</b> Angle computation uses a local tangent frame, not global coordinates.
/// This ensures stable cyclic ordering anywhere on the sphere, including poles.
/// </para>
/// <para>
/// <b>Classification (§11):</b> Boundary types mapped to R/F/T letters, sorted alphabetically,
/// concatenated to form label (e.g., RTT).
/// </para>
/// </remarks>
public sealed class JunctionAnalyzer : IJunctionAnalyzer
{
    /// <inheritdoc />
    public JunctionSet BuildJunctionSet(
        CanonicalTick tick,
        IPlateTopologyStateView topology,
        JunctionAnalysisOptions? options = null)
    {
        ArgumentNullException.ThrowIfNull(topology);
        var opts = options ?? JunctionAnalysisOptions.Default;

        var junctionInfos = new List<JunctionInfo>();

        foreach (var junction in topology.Junctions.Values.Where(j => !j.IsRetired))
        {
            var info = BuildJunctionInfo(junction, topology, opts);
            junctionInfos.Add(info);
        }

        // Sort by JunctionId for determinism (§10.2)
        junctionInfos.Sort((a, b) => a.JunctionId.Value.CompareTo(b.JunctionId.Value));

        return new JunctionSet(tick, junctionInfos.ToImmutableArray());
    }

    /// <inheritdoc />
    public JunctionDiagnostics Diagnose(
        CanonicalTick tick,
        JunctionSet junctions,
        IPlateTopologyStateView topology,
        IPlateKinematicsStateView kinematics,
        IPlateVelocitySolver velocitySolver,
        JunctionAnalysisOptions? options = null)
    {
        ArgumentNullException.ThrowIfNull(topology);
        ArgumentNullException.ThrowIfNull(kinematics);
        ArgumentNullException.ThrowIfNull(velocitySolver);
        var opts = options ?? JunctionAnalysisOptions.Default;

        var closureDiagnostics = new List<JunctionClosureDiagnostic>();
        var invalidJunctions = new List<JunctionInfo>();
        int closedCount = 0;
        int unclosedCount = 0;

        foreach (var junction in junctions.Junctions)
        {
            // Skip non-triple junctions for closure analysis (they don't have standard closure)
            if (!junction.IsTriple)
            {
                invalidJunctions.Add(junction);
                continue;
            }

            var diagnostic = DiagnoseJunction(junction, tick, topology, kinematics, velocitySolver, opts);
            closureDiagnostics.Add(diagnostic);

            if (diagnostic.IsClosed)
                closedCount++;
            else
                unclosedCount++;
        }

        return new JunctionDiagnostics(
            tick,
            closureDiagnostics.ToImmutableArray(),
            invalidJunctions.ToImmutableArray(),
            junctions.Junctions.Length,
            closedCount,
            unclosedCount);
    }

    /// <inheritdoc />
    public JunctionClosureDiagnostic DiagnoseJunction(
        JunctionInfo junction,
        CanonicalTick tick,
        IPlateTopologyStateView topology,
        IPlateKinematicsStateView kinematics,
        IPlateVelocitySolver velocitySolver,
        JunctionAnalysisOptions? options = null)
    {
        ArgumentNullException.ThrowIfNull(topology);
        ArgumentNullException.ThrowIfNull(kinematics);
        ArgumentNullException.ThrowIfNull(velocitySolver);
        var opts = options ?? JunctionAnalysisOptions.Default;

        var position = junction.Position;
        var plates = junction.IncidentPlates;

        // For triple junctions, compute closure: v_AB + v_BC + v_CA = 0
        var relativeVelocities = new List<PlateRelativeVelocity>();
        var residual = Velocity3d.Zero;

        if (plates.Length >= 3)
        {
            // Compute relative velocities around the junction (A→B→C→A)
            for (int i = 0; i < 3; i++)
            {
                var fromPlate = plates[i];
                var toPlate = plates[(i + 1) % 3];

                var point = new Vector3d(position.X, position.Y, position.Z);
                var relVel = velocitySolver.GetRelativeVelocity(
                    kinematics, fromPlate, toPlate, point, tick);

                relativeVelocities.Add(new PlateRelativeVelocity(fromPlate, toPlate, relVel));
                residual = residual + relVel;
            }
        }

        var residualMagnitude = residual.Magnitude();
        var isClosed = residualMagnitude < opts.ClosureTolerance;

        return new JunctionClosureDiagnostic(
            junction.JunctionId,
            position,
            residual,
            residualMagnitude,
            relativeVelocities.ToImmutableArray(),
            isClosed);
    }

    /// <summary>
    /// Build junction info for a single junction.
    /// </summary>
    private JunctionInfo BuildJunctionInfo(
        Topology.Contracts.Entities.Junction junction,
        IPlateTopologyStateView topology,
        JunctionAnalysisOptions opts)
    {
        // Build incident list from boundary IDs
        var incidents = new List<JunctionIncident>();
        var incidentPlates = new HashSet<PlateId>();
        var boundaryTypes = new List<BoundaryType>();

        // Create local tangent frame at the junction's surface point
        var junctionFrame = junction.Location.CreateTangentFrame();

        foreach (var boundaryId in junction.BoundaryIds)
        {
            if (!topology.Boundaries.TryGetValue(boundaryId, out var boundary) || boundary.IsRetired)
                continue;

            // Determine if this is the start or end of the boundary
            var (isStartpoint, direction3d) = GetBoundaryDirection3d(boundary, junction.Location);

            // Compute tangent angle using local frame (CCW from North)
            var tangentAngle = junctionFrame.ComputeTangentAngle(direction3d);

            // Determine left/right plates based on direction
            var leftPlate = isStartpoint ? boundary.PlateIdLeft : boundary.PlateIdRight;
            var rightPlate = isStartpoint ? boundary.PlateIdRight : boundary.PlateIdLeft;

            incidents.Add(new JunctionIncident(
                boundaryId,
                isStartpoint,
                tangentAngle,
                leftPlate,
                rightPlate));

            incidentPlates.Add(boundary.PlateIdLeft);
            incidentPlates.Add(boundary.PlateIdRight);
            boundaryTypes.Add(boundary.BoundaryType);
        }

        // Sort incidents by tangent angle (§10.1), ties by BoundaryId
        incidents.Sort((a, b) => JunctionIncident.CompareByAngle(a, b));

        // Sort incident plates by PlateId (§10.3)
        var sortedPlates = incidentPlates.OrderBy(p => p.Value).ToImmutableArray();

        // Compute classification if enabled and this is a triple junction
        JunctionClassification? classification = null;
        if (opts.IncludeClassification && boundaryTypes.Count == 3)
        {
            classification = ClassifyTripleJunction(boundaryTypes);
        }

        // Convert surface point to 3D position for derived products
        var position = junction.Location.ToPositionVector();
        var point3 = new Point3(position.X, position.Y, position.Z);

        return new JunctionInfo(
            junction.JunctionId,
            point3,
            incidents.ToImmutableArray(),
            sortedPlates,
            classification);
    }

    /// <summary>
    /// Get the 3D direction vector from junction along boundary.
    /// </summary>
    /// <remarks>
    /// Returns a 3D direction vector in the global coordinate frame.
    /// The vector is NOT projected to the tangent plane - that happens during angle computation.
    /// </remarks>
    private (bool IsStartpoint, Vector3d Direction) GetBoundaryDirection3d(
        Boundary boundary,
        SurfacePoint junctionLocation)
    {
        // Get boundary geometry points in 3D
        var points3d = GetGeometryPoints3d(boundary.Geometry);
        if (points3d.Count < 2)
            return (true, Vector3d.UnitX); // Degenerate case

        var start = points3d[0];
        var end = points3d[^1];

        var junctionPos = junctionLocation.ToPositionVector();
        var distToStart = Distance3d(junctionPos, start);
        var distToEnd = Distance3d(junctionPos, end);

        if (distToStart < distToEnd)
        {
            // Junction is at start - direction is from junction toward second point
            var direction = Normalize3d(new Vector3d(
                points3d[1].X - start.X,
                points3d[1].Y - start.Y,
                points3d[1].Z - start.Z));
            return (true, direction);
        }
        else
        {
            // Junction is at end - direction is from junction toward second-to-last point
            var direction = Normalize3d(new Vector3d(
                points3d[^2].X - end.X,
                points3d[^2].Y - end.Y,
                points3d[^2].Z - end.Z));
            return (false, direction);
        }
    }

    /// <summary>
    /// Extract 3D points from geometry.
    /// </summary>
    private IReadOnlyList<Vector3d> GetGeometryPoints3d(IGeometry geometry)
    {
        // Handle different geometry types - convert all to 3D
        return geometry switch
        {
            Polyline3 polyline3 => polyline3.PointsList
                .Select(p => new Vector3d(p.X, p.Y, p.Z))
                .ToList(),
            Polyline2 polyline => polyline.PointsList
                .Select(v => new Vector3d(v.X, v.Y, 0))  // Promote 2D to 3D (z=0)
                .ToList(),
            _ => Array.Empty<Vector3d>()
        };
    }

    /// <summary>
    /// Euclidean distance between two 3D points.
    /// </summary>
    private static double Distance3d(Vector3d a, Vector3d b)
    {
        var dx = b.X - a.X;
        var dy = b.Y - a.Y;
        var dz = b.Z - a.Z;
        return Math.Sqrt(dx * dx + dy * dy + dz * dz);
    }

    /// <summary>
    /// Normalize a 3D vector.
    /// </summary>
    private static Vector3d Normalize3d(Vector3d v)
    {
        var len = Math.Sqrt(v.X * v.X + v.Y * v.Y + v.Z * v.Z);
        return len > 0 ? new Vector3d(v.X / len, v.Y / len, v.Z / len) : v;
    }

    /// <summary>
    /// Classify a triple junction by boundary types (§11).
    /// </summary>
    private static JunctionClassification ClassifyTripleJunction(IReadOnlyList<BoundaryType> types)
    {
        if (types.Count != 3)
            return JunctionClassification.Unknown;

        // Map boundary types to letters
        var letters = types.Select(MapBoundaryTypeToLetter).OrderBy(c => c).ToArray();
        var label = new string(letters);

        return label switch
        {
            "FFF" => JunctionClassification.FFF,
            "FFT" => JunctionClassification.FFT,
            "FTT" => JunctionClassification.FTT,
            "FRR" => JunctionClassification.RFF, // Sorted alphabetically: F < R
            "FFR" => JunctionClassification.RFF,
            "FRT" => JunctionClassification.RFT,
            "RRF" => JunctionClassification.RRF,
            "RRR" => JunctionClassification.RRR,
            "RRT" => JunctionClassification.RRT,
            "RTT" => JunctionClassification.RTT,
            "TTT" => JunctionClassification.TTT,
            _ => JunctionClassification.Unknown
        };
    }

    /// <summary>
    /// Map boundary type to classification letter (§11.1).
    /// </summary>
    private static char MapBoundaryTypeToLetter(BoundaryType type) => type switch
    {
        BoundaryType.Divergent => 'R',  // Ridge
        BoundaryType.Transform => 'F',  // Fault/Transform
        BoundaryType.Convergent => 'T', // Trench
        _ => '?'
    };
}


// --- PATH: plugins/Geosphere.Plate.Kinematics.Materializer/KinematicsMaterializerPlugin.cs ---
﻿using System;
using System.Threading;
using System.Threading.Tasks;
using FantaSim.Geosphere.Plate.Kinematics.Contracts.Events;
using Microsoft.Extensions.DependencyInjection;
using PluginArchi.Extensibility.Abstractions;
using ServiceArchi.Contracts;
using UnifyStorage.Abstractions;

namespace FantaSim.Geosphere.Plate.Kinematics.Materializer;

/// <summary>
/// Plugin entry point for the Kinematics Materializer.
///
/// Registers:
/// - IKinematicsEventStore: Event persistence and replay for kinematics
/// - PlateKinematicsMaterializer: State materialization from events
/// </summary>
[Plugin("fantasim.geosphere.plate.kinematics.materializer", Name = "Plate Kinematics Materializer", Tags = "geosphere,kinematics,materializer,persistence")]
public sealed class KinematicsMaterializerPlugin : ILifecyclePlugin
{
    private IRegistry? _registry;
    private PlateKinematicsEventStore? _eventStore;
    private PlateKinematicsMaterializer? _materializer;

    public IPluginDescriptor Descriptor { get; } = new PluginDescriptor
    {
        Id = "fantasim.geosphere.plate.kinematics.materializer",
        Name = "Plate Kinematics Materializer",
        Description = "Persistence and materialization layer for Plate Kinematics truth events.",
        Tags = new[] { "geosphere", "kinematics", "materializer", "persistence" },
        Version = new Version(1, 0, 0)
    };

    public ValueTask InitializeAsync(IPluginContext context, CancellationToken ct = default)
    {
        // 1. Resolve the ServiceArchi Registry from the host context
        var registry = context.Services.GetService<IRegistry>();
        if (registry == null)
        {
            return ValueTask.CompletedTask;
        }

        _registry = registry;

        // 2. Resolve the key-value store dependency
        var kvStore = context.Services.GetService<IKeyValueStore>();
        if (kvStore == null)
        {
            // KV store not available yet - this plugin may need to be initialized later
            return ValueTask.CompletedTask;
        }

        // 3. Create and register the event store
        _eventStore = new PlateKinematicsEventStore(kvStore);
        registry.Register<IKinematicsEventStore>(_eventStore);

        // 4. Create and register the materializer
        _materializer = new PlateKinematicsMaterializer(_eventStore);
        registry.Register<PlateKinematicsMaterializer>(_materializer);

        return ValueTask.CompletedTask;
    }

    public ValueTask ShutdownAsync(CancellationToken ct = default)
    {
        _registry?.UnregisterAll<PlateKinematicsMaterializer>();
        _registry?.UnregisterAll<IKinematicsEventStore>();

        _materializer = null;
        _eventStore?.Dispose();
        _eventStore = null;
        _registry = null;

        return ValueTask.CompletedTask;
    }
}


// --- PATH: plugins/Geosphere.Plate.Kinematics.Materializer/PlateKinematicsEventStore.cs ---
using System.Buffers.Binary;
using System.Text;
using FantaSim.Geosphere.Plate.Kinematics.Contracts.Events;
using FantaSim.Geosphere.Plate.Kinematics.Serializers;
using FantaSim.Geosphere.Plate.Topology.Contracts.Identity;
using UnifyStorage.Abstractions;

namespace FantaSim.Geosphere.Plate.Kinematics.Materializer;

public sealed class PlateKinematicsEventStore : IKinematicsEventStore, IDisposable
{
    private const string EventPrefix = "E:";
    private const string HeadSuffix = "Head";

    private readonly IKeyValueStore _store;
    private readonly object _lock = new();

    public PlateKinematicsEventStore(IKeyValueStore store)
    {
        ArgumentNullException.ThrowIfNull(store);
        _store = store;
    }

    public Task AppendAsync(
        TruthStreamIdentity stream,
        IEnumerable<IPlateKinematicsEvent> events,
        CancellationToken cancellationToken)
    {
        return AppendAsync(stream, events, AppendOptions.Default, cancellationToken);
    }

    public Task AppendAsync(
        TruthStreamIdentity stream,
        IEnumerable<IPlateKinematicsEvent> events,
        AppendOptions options,
        CancellationToken cancellationToken)
    {
        ArgumentNullException.ThrowIfNull(stream);
        ArgumentNullException.ThrowIfNull(events);
        options ??= AppendOptions.Default;

        if (!stream.IsValid())
        {
            throw new InvalidOperationException(
                $"TruthStreamIdentity is not valid: {stream}. " +
                "Ensure VariantId, BranchId, Model are non-empty, LLevel >= 0, and Domain is well-formed.");
        }

        var eventsList = events.ToList();
        if (eventsList.Count == 0)
            return Task.CompletedTask;

        foreach (var evt in eventsList)
        {
            if (evt.StreamIdentity != stream)
            {
                throw new ArgumentException(
                    $"Event {evt.EventId} stream identity {evt.StreamIdentity} does not match expected {stream}",
                    nameof(events));
            }
        }

        for (int i = 1; i < eventsList.Count; i++)
        {
            if (eventsList[i].Sequence <= eventsList[i - 1].Sequence)
            {
                throw new ArgumentException(
                    $"Events must have monotonically increasing Sequence numbers. Event {i} has Sequence {eventsList[i].Sequence} after {eventsList[i - 1].Sequence}",
                    nameof(events));
            }
        }

        ApplyTickMonotonicityPolicy(eventsList, options.TickPolicy);

        var prefix = BuildStreamPrefix(stream);
        using var batch = _store.CreateWriteBatch();

        var previousHash = GetPreviousHashForAppend(prefix);

        foreach (var evt in eventsList)
        {
            var eventKey = BuildEventKey(prefix, evt.Sequence);
            var eventBytes = MessagePackKinematicsEventSerializer.Serialize(evt);

            var schemaVersion = MessagePackEventRecordSerializer.SchemaVersionV1;
            var recordSequence = evt.Sequence;
            var hash = MessagePackEventRecordSerializer.ComputeHashV1(schemaVersion, recordSequence, previousHash, eventBytes);
            var recordBytes = MessagePackEventRecordSerializer.SerializeRecord(schemaVersion, recordSequence, previousHash, hash, eventBytes);

            batch.Put(eventKey, recordBytes);
            previousHash = hash;
        }

        var headKey = BuildHeadKey(prefix);
        var lastSequence = eventsList[^1].Sequence;
        Span<byte> headBytes = stackalloc byte[8];
        BinaryPrimitives.WriteInt64BigEndian(headBytes, lastSequence);
        batch.Put(headKey, headBytes);

        lock (_lock)
        {
            _store.Write(batch);
        }

        return Task.CompletedTask;
    }

    private static void ApplyTickMonotonicityPolicy(
        List<IPlateKinematicsEvent> events,
        TickMonotonicityPolicy policy)
    {
        if (policy == TickMonotonicityPolicy.Allow || events.Count < 2)
            return;

        for (int i = 1; i < events.Count; i++)
        {
            if (events[i].Tick.Value < events[i - 1].Tick.Value)
            {
                var message = $"Tick decreased from {events[i - 1].Tick.Value} to {events[i].Tick.Value} " +
                              $"at event index {i} (Sequence {events[i].Sequence})";

                switch (policy)
                {
                    case TickMonotonicityPolicy.Warn:
                        System.Diagnostics.Debug.WriteLine($"[TickMonotonicity.Warn] {message}");
                        break;
                    case TickMonotonicityPolicy.Reject:
                        throw new InvalidOperationException(
                            $"Tick monotonicity violation: {message}. " +
                            "Use TickMonotonicityPolicy.Allow or Warn to permit tick decreases.");
                }
            }
        }
    }

    public async IAsyncEnumerable<IPlateKinematicsEvent> ReadAsync(
        TruthStreamIdentity stream,
        long fromSequenceInclusive,
        [System.Runtime.CompilerServices.EnumeratorCancellation] CancellationToken cancellationToken)
    {
        ArgumentNullException.ThrowIfNull(stream);
        if (fromSequenceInclusive < 0)
            throw new ArgumentOutOfRangeException(nameof(fromSequenceInclusive), "Sequence must be non-negative");

        if (!stream.IsValid())
        {
            throw new InvalidOperationException(
                $"TruthStreamIdentity is not valid: {stream}. " +
                "Ensure VariantId, BranchId, Model are non-empty, LLevel >= 0, and Domain is well-formed.");
        }

        var prefix = BuildStreamPrefix(stream);
        var firstKey = BuildEventKey(prefix, fromSequenceInclusive);

        var expectedPreviousHash = GetExpectedPreviousHashForRead(prefix, fromSequenceInclusive);

        await Task.Yield();

        var bytesToYield = new List<byte[]>();
        lock (_lock)
        {
            using var iterator = _store.CreateIterator();
            iterator.Seek(firstKey);

            while (iterator.Valid && HasStreamPrefix(iterator.Key, prefix))
            {
                bytesToYield.Add(iterator.Value.ToArray());
                iterator.Next();
            }
        }

        foreach (var recordBytes in bytesToYield)
        {
            cancellationToken.ThrowIfCancellationRequested();

            if (MessagePackEventRecordSerializer.TryDeserializeRecord(recordBytes, out var record))
            {
                if (!record.PreviousHash.AsSpan().SequenceEqual(expectedPreviousHash))
                {
                    throw new InvalidOperationException("EventRecord previousHash mismatch");
                }

                var evt = DeserializeAndValidateRecord(record);
                expectedPreviousHash = record.Hash;
                yield return evt;
            }
            else
            {
                expectedPreviousHash = MessagePackEventRecordSerializer.GetZeroHash();
                yield return MessagePackKinematicsEventSerializer.Deserialize(recordBytes);
            }
        }
    }

    public Task<long?> GetLastSequenceAsync(TruthStreamIdentity stream, CancellationToken cancellationToken)
    {
        ArgumentNullException.ThrowIfNull(stream);

        if (!stream.IsValid())
        {
            throw new InvalidOperationException(
                $"TruthStreamIdentity is not valid: {stream}. " +
                "Ensure VariantId, BranchId, Model are non-empty, LLevel >= 0, and Domain is well-formed.");
        }

        var prefix = BuildStreamPrefix(stream);
        var headKey = BuildHeadKey(prefix);

        Span<byte> buffer = stackalloc byte[8];
        int written;

        lock (_lock)
        {
            if (!_store.TryGet(headKey, buffer, out written))
            {
                return Task.FromResult<long?>(null);
            }
        }

        if (written != 8)
            throw new InvalidOperationException($"Head value must be 8 bytes, got {written}");

        var value = BinaryPrimitives.ReadInt64BigEndian(buffer);
        return Task.FromResult<long?>(value);
    }

    private static IPlateKinematicsEvent DeserializeAndValidateRecord(MessagePackEventRecordSerializer.EventRecordV1 record)
    {
        if (record.SchemaVersion != MessagePackEventRecordSerializer.SchemaVersionV1)
            throw new InvalidOperationException($"Unsupported schemaVersion: {record.SchemaVersion}");

        var expectedHash = MessagePackEventRecordSerializer.ComputeHashV1(
            record.SchemaVersion,
            record.Tick,
            record.PreviousHash,
            record.EventBytes);

        if (!expectedHash.AsSpan().SequenceEqual(record.Hash))
            throw new InvalidOperationException("EventRecord hash mismatch");

        var evt = MessagePackKinematicsEventSerializer.Deserialize(record.EventBytes);
        if (evt.Sequence != record.Tick)
            throw new InvalidOperationException("EventRecord tick does not match event payload sequence");

        return evt;
    }

    private byte[] GetPreviousHashForAppend(byte[] prefix)
    {
        var lastSequence = ReadHead(prefix);
        if (lastSequence is null)
            return MessagePackEventRecordSerializer.GetZeroHash();

        var lastEventKey = BuildEventKey(prefix, lastSequence.Value);
        byte[]? lastValue;
        lock (_lock)
        {
            lastValue = ReadBytes(lastEventKey);
        }

        if (lastValue != null && MessagePackEventRecordSerializer.TryDeserializeRecord(lastValue, out var lastRecord))
        {
            return lastRecord.Hash;
        }

        return MessagePackEventRecordSerializer.GetZeroHash();
    }

    private byte[] GetExpectedPreviousHashForRead(byte[] prefix, long fromSequenceInclusive)
    {
        if (fromSequenceInclusive <= 0)
            return MessagePackEventRecordSerializer.GetZeroHash();

        var previousEventKey = BuildEventKey(prefix, fromSequenceInclusive - 1);

        byte[]? previousValue;
        lock (_lock)
        {
            previousValue = ReadBytes(previousEventKey);
        }

        if (previousValue != null && MessagePackEventRecordSerializer.TryDeserializeRecord(previousValue, out var previousRecord))
        {
            return previousRecord.Hash;
        }

        return MessagePackEventRecordSerializer.GetZeroHash();
    }

    private long? ReadHead(byte[] prefix)
    {
        var headKey = BuildHeadKey(prefix);

        Span<byte> buffer = stackalloc byte[8];
        int written;

        lock (_lock)
        {
            if (!_store.TryGet(headKey, buffer, out written))
                return null;
        }

        if (written != 8)
            throw new InvalidOperationException($"Head value must be 8 bytes, got {written}");

        return BinaryPrimitives.ReadInt64BigEndian(buffer);
    }

    private byte[]? ReadBytes(byte[] key)
    {
        Span<byte> initialBuffer = stackalloc byte[1];
        if (_store.TryGet(key, initialBuffer, out var written))
        {
            return initialBuffer.Slice(0, written).ToArray();
        }

        if (written > 0)
        {
            var result = new byte[written];
            if (_store.TryGet(key, result, out _))
            {
                return result;
            }
            throw new InvalidOperationException("Store state changed during read");
        }

        return null;
    }

    private static byte[] BuildStreamPrefix(TruthStreamIdentity stream)
    {
        return Encoding.UTF8.GetBytes($"S:{stream.VariantId}:{stream.BranchId}:L{stream.LLevel}:{stream.Domain}:M{stream.Model}:");
    }

    private static byte[] BuildEventKey(byte[] prefix, long sequence)
    {
        var key = new byte[prefix.Length + EventPrefix.Length + 8];
        Buffer.BlockCopy(prefix, 0, key, 0, prefix.Length);
        Encoding.UTF8.GetBytes(EventPrefix, 0, EventPrefix.Length, key, prefix.Length);
        var offset = prefix.Length + EventPrefix.Length;
        BinaryPrimitives.WriteUInt64BigEndian(key.AsSpan(offset), (ulong)sequence);
        return key;
    }

    private static byte[] BuildHeadKey(byte[] prefix)
    {
        var key = new byte[prefix.Length + HeadSuffix.Length];
        Buffer.BlockCopy(prefix, 0, key, 0, prefix.Length);
        Encoding.UTF8.GetBytes(HeadSuffix, 0, HeadSuffix.Length, key, prefix.Length);
        return key;
    }

    private static bool HasStreamPrefix(ReadOnlySpan<byte> key, byte[] prefix)
    {
        if (key.Length < prefix.Length)
            return false;
        if (!key[..prefix.Length].SequenceEqual(prefix))
            return false;

        var requiredLength = prefix.Length + EventPrefix.Length;
        if (key.Length < requiredLength)
            return false;

        return key[prefix.Length] == (byte)'E' && key[prefix.Length + 1] == (byte)':';
    }

    public void Dispose() => _store.Dispose();
}


// --- PATH: plugins/Geosphere.Plate.Kinematics.Materializer/PlateKinematicsMaterializer.cs ---
using FantaSim.Geosphere.Plate.Kinematics.Contracts.Events;
using FantaSim.Geosphere.Plate.Topology.Contracts.Identity;

namespace FantaSim.Geosphere.Plate.Kinematics.Materializer;

public sealed class PlateKinematicsMaterializer
{
    private readonly IKinematicsEventStore _store;

    public PlateKinematicsMaterializer(IKinematicsEventStore store)
    {
        ArgumentNullException.ThrowIfNull(store);
        _store = store;
    }

    public async Task<PlateKinematicsState> MaterializeAsync(
        TruthStreamIdentity stream,
        CancellationToken cancellationToken = default)
    {
        ArgumentNullException.ThrowIfNull(stream);

        var state = new PlateKinematicsState(stream);

        await foreach (var evt in _store.ReadAsync(stream, 0, cancellationToken).ConfigureAwait(false))
        {
            ApplyEvent(state, evt);
        }

        state.RebuildIndices();
        return state;
    }

    private static void ApplyEvent(PlateKinematicsState state, IPlateKinematicsEvent evt)
    {
        switch (evt)
        {
            case MotionSegmentUpsertedEvent upsert:
                state.UpsertSegment(upsert.PlateId, upsert.SegmentId, upsert.TickA, upsert.TickB, upsert.StageRotation);
                break;

            case MotionSegmentRetiredEvent retired:
                state.RetireSegment(retired.PlateId, retired.SegmentId);
                break;

            case PlateMotionModelAssignedEvent:
                // Optional metadata event: does not affect rotation computation in v0.
                break;
        }

        state.SetLastEventSequence(evt.Sequence);
    }
}


// --- PATH: plugins/Geosphere.Plate.Kinematics.Materializer/PlateKinematicsState.cs ---
using System.Runtime.InteropServices;
using Plate.TimeDete.Time.Primitives;
using FantaSim.Geosphere.Plate.Kinematics.Contracts.Derived;
using FantaSim.Geosphere.Plate.Kinematics.Contracts.Entities;
using FantaSim.Geosphere.Plate.Kinematics.Contracts.Numerics;
using FantaSim.Geosphere.Plate.Topology.Contracts.Entities;
using FantaSim.Geosphere.Plate.Topology.Contracts.Identity;
using FantaSim.Geosphere.Plate.Topology.Contracts.Numerics;

namespace FantaSim.Geosphere.Plate.Kinematics.Materializer;

public sealed class PlateKinematicsState : IPlateKinematicsStateView
{
    private readonly Dictionary<PlateId, Dictionary<MotionSegmentId, MotionSegment>> _segmentsByPlate = new();
    private readonly Dictionary<PlateId, List<MotionSegment>> _sortedSegmentsByPlate = new();

    public PlateKinematicsState(TruthStreamIdentity identity)
    {
        Identity = identity;
        LastEventSequence = -1;
    }

    public TruthStreamIdentity Identity { get; }

    public long LastEventSequence { get; private set; }

    public void SetLastEventSequence(long sequence) => LastEventSequence = sequence;

    public void UpsertSegment(
        PlateId plateId,
        MotionSegmentId segmentId,
        CanonicalTick tickA,
        CanonicalTick tickB,
        QuantizedEulerPoleRotation stageRotation)
    {
        if (tickB.Value <= tickA.Value)
            throw new InvalidOperationException($"Motion segment must satisfy TickA < TickB. Got {tickA.Value}..{tickB.Value}.");

        if (!_segmentsByPlate.TryGetValue(plateId, out var byId))
        {
            byId = new Dictionary<MotionSegmentId, MotionSegment>();
            _segmentsByPlate[plateId] = byId;
        }

        byId[segmentId] = new MotionSegment(segmentId, tickA, tickB, stageRotation);
    }

    public void RetireSegment(PlateId plateId, MotionSegmentId segmentId)
    {
        if (_segmentsByPlate.TryGetValue(plateId, out var byId))
        {
            byId.Remove(segmentId);
        }
    }

    public void RebuildIndices()
    {
        _sortedSegmentsByPlate.Clear();

        var plates = _segmentsByPlate.Keys.ToList();
        plates.Sort(static (a, b) => a.Value.CompareTo(b.Value));

        foreach (var plateId in plates)
        {
            var byId = _segmentsByPlate[plateId];
            var list = byId.Values.ToList();
            list.Sort(MotionSegmentComparer.Instance);
            _sortedSegmentsByPlate[plateId] = list;
        }
    }

    public bool TryGetRotation(PlateId plateId, CanonicalTick tick, out Quaterniond rotation)
    {
        rotation = Quaterniond.Identity;
        if (tick.Value <= 0)
            return true;

        if (!_sortedSegmentsByPlate.TryGetValue(plateId, out var segments) || segments.Count == 0)
            return true;

        rotation = ComputeAbsoluteRotation(segments, tick, new Dictionary<long, Quaterniond>());
        return true;
    }

    private static Quaterniond ComputeAbsoluteRotation(
        List<MotionSegment> segments,
        CanonicalTick tick,
        Dictionary<long, Quaterniond> memo)
    {
        if (tick.Value <= 0)
            return Quaterniond.Identity;

        if (memo.TryGetValue(tick.Value, out var cached))
            return cached;

        // Prefer a segment that covers (TickA, TickB] with TickA < tick <= TickB.
        MotionSegment? active = null;
        foreach (var seg in segments)
        {
            if (seg.TickA.Value < tick.Value && tick.Value <= seg.TickB.Value)
            {
                if (active is null || MotionSegmentComparer.Instance.Compare(seg, active.Value) < 0)
                {
                    active = seg;
                }
            }
        }

        Quaterniond result;

        if (active is not null)
        {
            var seg = active.Value;
            var baseRot = ComputeAbsoluteRotation(segments, seg.TickA, memo);
            var frac = (double)(tick.Value - seg.TickA.Value) / (seg.TickB.Value - seg.TickA.Value);
            var delta = RotationMath.FractionalStageRotation(seg.StageRotation, frac);
            result = RotationMath.Multiply(baseRot, delta);
        }
        else
        {
            // If no segment covers this tick, hold the last known end-rotation constant.
            MotionSegment? lastEnded = null;
            foreach (var seg in segments)
            {
                if (seg.TickB.Value <= tick.Value)
                {
                    if (lastEnded is null || seg.TickB.Value > lastEnded.Value.TickB.Value ||
                        (seg.TickB.Value == lastEnded.Value.TickB.Value &&
                         MotionSegmentComparer.Instance.Compare(seg, lastEnded.Value) < 0))
                    {
                        lastEnded = seg;
                    }
                }
            }

            if (lastEnded is null)
            {
                result = Quaterniond.Identity;
            }
            else
            {
                result = ComputeAbsoluteRotation(segments, lastEnded.Value.TickB, memo);
            }
        }

        memo[tick.Value] = result;
        return result;
    }

    [StructLayout(LayoutKind.Auto)]
    public readonly record struct MotionSegment(
        MotionSegmentId SegmentId,
        CanonicalTick TickA,
        CanonicalTick TickB,
        QuantizedEulerPoleRotation StageRotation);

    private sealed class MotionSegmentComparer : IComparer<MotionSegment>
    {
        public static readonly MotionSegmentComparer Instance = new();

        public int Compare(MotionSegment x, MotionSegment y)
        {
            // For deterministic selection, sort by:
            // - TickA descending (latest start first),
            // - TickB ascending (shorter first),
            // - SegmentId ascending.
            var cmp = y.TickA.Value.CompareTo(x.TickA.Value);
            if (cmp != 0) return cmp;

            cmp = x.TickB.Value.CompareTo(y.TickB.Value);
            if (cmp != 0) return cmp;

            return x.SegmentId.Value.CompareTo(y.SegmentId.Value);
        }
    }

    private static class RotationMath
    {
        private const double DegToRad = Math.PI / 180.0;

        public static Quaterniond FractionalStageRotation(QuantizedEulerPoleRotation rot, double fraction)
        {
            fraction = Math.Clamp(fraction, 0.0, 1.0);

            var axis = EulerPoleToUnitVector(rot.AxisAzimuthDeg, rot.AxisElevationDeg);
            var angleRad = rot.AngleDeg * DegToRad * fraction;
            return Quaterniond.FromAxisAngle(axis, angleRad);
        }

        private static Vector3d EulerPoleToUnitVector(double azimuthDeg, double elevationDeg)
        {
            var lon = azimuthDeg * DegToRad;
            var lat = elevationDeg * DegToRad;

            var cosLat = Math.Cos(lat);
            return new Vector3d(
                cosLat * Math.Cos(lon),
                cosLat * Math.Sin(lon),
                Math.Sin(lat));
        }

        public static Quaterniond Multiply(Quaterniond a, Quaterniond b)
        {
            // Hamilton product (a * b).
            var w = a.W * b.W - a.X * b.X - a.Y * b.Y - a.Z * b.Z;
            var x = a.W * b.X + a.X * b.W + a.Y * b.Z - a.Z * b.Y;
            var y = a.W * b.Y - a.X * b.Z + a.Y * b.W + a.Z * b.X;
            var z = a.W * b.Z + a.X * b.Y - a.Y * b.X + a.Z * b.W;
            return Normalize(new Quaterniond(x, y, z, w));
        }

        private static Quaterniond Normalize(Quaterniond q)
        {
            var norm = Math.Sqrt(q.X * q.X + q.Y * q.Y + q.Z * q.Z + q.W * q.W);
            if (norm <= 0)
                return Quaterniond.Identity;
            return new Quaterniond(q.X / norm, q.Y / norm, q.Z / norm, q.W / norm);
        }
    }
}


// --- PATH: plugins/Geosphere.Plate.Kinematics.Serializers/Formatters/CanonicalTickFormatter.cs ---
using MessagePack;
using MessagePack.Formatters;
using Plate.TimeDete.Time.Primitives;

namespace FantaSim.Geosphere.Plate.Kinematics.Serializers.Formatters;

internal sealed class CanonicalTickFormatter : IMessagePackFormatter<CanonicalTick>
{
    public void Serialize(ref MessagePackWriter writer, CanonicalTick value, MessagePackSerializerOptions options)
    {
        writer.Write(value.Value);
    }

    public CanonicalTick Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
    {
        return new CanonicalTick(reader.ReadInt64());
    }
}


// --- PATH: plugins/Geosphere.Plate.Kinematics.Serializers/Formatters/DomainFormatter.cs ---
using MessagePack;
using MessagePack.Formatters;
using FantaSim.Geosphere.Plate.Topology.Contracts.Identity;

namespace FantaSim.Geosphere.Plate.Kinematics.Serializers.Formatters;

internal sealed class DomainFormatter : IMessagePackFormatter<Domain>
{
    public void Serialize(ref MessagePackWriter writer, Domain value, MessagePackSerializerOptions options)
    {
        writer.Write(value.Value);
    }

    public Domain Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
    {
        var str = reader.ReadString();
        if (str is null)
            throw new InvalidOperationException("Domain value cannot be null");
        return Domain.Parse(str);
    }
}


// --- PATH: plugins/Geosphere.Plate.Kinematics.Serializers/Formatters/MotionSegmentIdFormatter.cs ---
using MessagePack;
using MessagePack.Formatters;
using FantaSim.Geosphere.Plate.Kinematics.Contracts.Entities;

namespace FantaSim.Geosphere.Plate.Kinematics.Serializers.Formatters;

internal sealed class MotionSegmentIdFormatter : IMessagePackFormatter<MotionSegmentId>
{
    public void Serialize(ref MessagePackWriter writer, MotionSegmentId value, MessagePackSerializerOptions options)
    {
        options.Resolver.GetFormatterWithVerify<Guid>().Serialize(ref writer, value.Value, options);
    }

    public MotionSegmentId Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
    {
        var guid = options.Resolver.GetFormatterWithVerify<Guid>().Deserialize(ref reader, options);
        return new MotionSegmentId(guid);
    }
}


// --- PATH: plugins/Geosphere.Plate.Kinematics.Serializers/Formatters/PlateIdFormatter.cs ---
using MessagePack;
using MessagePack.Formatters;
using FantaSim.Geosphere.Plate.Topology.Contracts.Entities;

namespace FantaSim.Geosphere.Plate.Kinematics.Serializers.Formatters;

internal sealed class PlateIdFormatter : IMessagePackFormatter<PlateId>
{
    public void Serialize(ref MessagePackWriter writer, PlateId value, MessagePackSerializerOptions options)
    {
        options.Resolver.GetFormatterWithVerify<Guid>().Serialize(ref writer, value.Value, options);
    }

    public PlateId Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
    {
        var guid = options.Resolver.GetFormatterWithVerify<Guid>().Deserialize(ref reader, options);
        return new PlateId(guid);
    }
}


// --- PATH: plugins/Geosphere.Plate.Kinematics.Serializers/MessagePackEventRecordSerializer.cs ---
using System.Buffers;
using System.Security.Cryptography;
using MessagePack;

namespace FantaSim.Geosphere.Plate.Kinematics.Serializers;

public static class MessagePackEventRecordSerializer
{
    public const int SchemaVersionV1 = 1;
    public const int HashSizeBytes = 32;

    private static readonly byte[] ZeroHash = new byte[HashSizeBytes];

    public static byte[] SerializeRecord(
        int schemaVersion,
        long tick,
        byte[] previousHash,
        byte[] hash,
        byte[] eventBytes)
    {
        ArgumentNullException.ThrowIfNull(previousHash);
        ArgumentNullException.ThrowIfNull(hash);
        ArgumentNullException.ThrowIfNull(eventBytes);

        if (previousHash.Length != HashSizeBytes)
            throw new ArgumentOutOfRangeException(nameof(previousHash), $"previousHash must be {HashSizeBytes} bytes");
        if (hash.Length != HashSizeBytes)
            throw new ArgumentOutOfRangeException(nameof(hash), $"hash must be {HashSizeBytes} bytes");

        var buffer = new ArrayBufferWriter<byte>();
        var writer = new MessagePackWriter(buffer);

        writer.WriteArrayHeader(5);
        writer.Write(schemaVersion);
        writer.Write(tick);
        writer.Write(previousHash);
        writer.Write(hash);
        writer.Write(eventBytes);
        writer.Flush();

        return buffer.WrittenMemory.ToArray();
    }

    public static byte[] ComputeHashV1(
        int schemaVersion,
        long tick,
        byte[] previousHash,
        byte[] eventBytes)
    {
        ArgumentNullException.ThrowIfNull(previousHash);
        ArgumentNullException.ThrowIfNull(eventBytes);

        if (previousHash.Length != HashSizeBytes)
            throw new ArgumentOutOfRangeException(nameof(previousHash), $"previousHash must be {HashSizeBytes} bytes");

        var buffer = new ArrayBufferWriter<byte>();
        var writer = new MessagePackWriter(buffer);
        writer.WriteArrayHeader(4);
        writer.Write(schemaVersion);
        writer.Write(tick);
        writer.Write(previousHash);
        writer.Write(eventBytes);
        writer.Flush();

        return SHA256.HashData(buffer.WrittenSpan);
    }

    public static EventRecordV1 DeserializeRecord(byte[] recordBytes)
    {
        ArgumentNullException.ThrowIfNull(recordBytes);

        var reader = new MessagePackReader(recordBytes);
        var length = reader.ReadArrayHeader();
        if (length != 5)
            throw new InvalidOperationException($"EventRecord must have 5 elements, got {length}");

        var schemaVersion = reader.ReadInt32();
        var tick = reader.ReadInt64();

        var previousHash = ReadFixedHash(ref reader, "previousHash");
        var hash = ReadFixedHash(ref reader, "hash");

        var eventBytes = reader.ReadBytes();
        if (!eventBytes.HasValue)
            throw new InvalidOperationException("EventRecord eventBytes cannot be null");

        return new EventRecordV1(schemaVersion, tick, previousHash, hash, eventBytes.Value.ToArray());
    }

    public static bool TryDeserializeRecord(byte[] recordBytes, out EventRecordV1 record)
    {
        try
        {
            record = DeserializeRecord(recordBytes);
            return true;
        }
        catch
        {
            record = default;
            return false;
        }
    }

    public static byte[] GetZeroHash() => (byte[])ZeroHash.Clone();

    private static byte[] ReadFixedHash(ref MessagePackReader reader, string name)
    {
        var bytes = reader.ReadBytes();
        if (!bytes.HasValue)
            throw new InvalidOperationException($"EventRecord {name} cannot be null");

        var arr = bytes.Value.ToArray();
        if (arr.Length != HashSizeBytes)
            throw new InvalidOperationException($"EventRecord {name} must be {HashSizeBytes} bytes, got {arr.Length}");

        return arr;
    }

    public readonly record struct EventRecordV1(
        int SchemaVersion,
        long Tick,
        byte[] PreviousHash,
        byte[] Hash,
        byte[] EventBytes);
}


// --- PATH: plugins/Geosphere.Plate.Kinematics.Serializers/MessagePackKinematicsEventSerializer.cs ---
using System.Buffers;
using MessagePack;
using MessagePack.Formatters;
using MessagePack.Resolvers;
using Plate.TimeDete.Time.Primitives;
using FantaSim.Geosphere.Plate.Kinematics.Contracts.Events;
using FantaSim.Geosphere.Plate.Kinematics.Serializers.Formatters;

namespace FantaSim.Geosphere.Plate.Kinematics.Serializers;

internal static class ReadOnlySequenceExtensions
{
    public static byte[] ToByteArray(this ReadOnlySequence<byte> sequence)
    {
        if (sequence.Length == 0)
            return Array.Empty<byte>();

        if (sequence.IsSingleSegment)
            return sequence.FirstSpan.ToArray();

        var bytes = new byte[checked((int)sequence.Length)];
        sequence.CopyTo(bytes);
        return bytes;
    }
}

public static class MessagePackKinematicsEventSerializer
{
    public static readonly MessagePackSerializerOptions Options = MessagePackSerializerOptions.Standard
        .WithResolver(CompositeResolver.Create(
            new IMessagePackFormatter[]
            {
                new DomainFormatter(),
                new CanonicalTickFormatter(),
                new PlateIdFormatter(),
                new MotionSegmentIdFormatter(),

                // Generated formatters
                new FantaSim.Geosphere.Plate.Topology.Contracts.Identity.TruthStreamIdentityMessagePackFormatter(),
                new FantaSim.Geosphere.Plate.Kinematics.Contracts.Events.PlateMotionModelAssignedEventMessagePackFormatter(),
                new FantaSim.Geosphere.Plate.Kinematics.Contracts.Events.MotionSegmentUpsertedEventMessagePackFormatter(),
                new FantaSim.Geosphere.Plate.Kinematics.Contracts.Events.MotionSegmentRetiredEventMessagePackFormatter()
            },
            new IFormatterResolver[]
            {
                NativeGuidResolver.Instance,
                BuiltinResolver.Instance,
                StandardResolver.Instance
            }
        ));

    private static readonly Dictionary<string, Type> EventTypeMap = new()
    {
        { nameof(PlateMotionModelAssignedEvent), typeof(PlateMotionModelAssignedEvent) },
        { nameof(MotionSegmentUpsertedEvent), typeof(MotionSegmentUpsertedEvent) },
        { nameof(MotionSegmentRetiredEvent), typeof(MotionSegmentRetiredEvent) }
    };

    public static byte[] Serialize(IPlateKinematicsEvent value)
    {
        ArgumentNullException.ThrowIfNull(value);

        var payloadBytes = MessagePackSerializer.Serialize(value.GetType(), value, Options);
        var eventType = value.EventType;

        var buffer = new ArrayBufferWriter<byte>();
        var writer = new MessagePackWriter(buffer);
        writer.WriteArrayHeader(2);
        writer.Write(eventType);
        writer.Write(payloadBytes);
        writer.Flush();

        return buffer.WrittenMemory.ToArray();
    }

    public static IPlateKinematicsEvent Deserialize(byte[] data)
    {
        var reader = new MessagePackReader(data);

        var length = reader.ReadArrayHeader();
        if (length != 2)
            throw new InvalidOperationException($"Envelope must have 2 elements, got {length}");

        var eventType = reader.ReadString();
        if (eventType is null)
            throw new InvalidOperationException("Envelope eventType cannot be null");

        var payloadBytes = reader.ReadBytes();
        if (!payloadBytes.HasValue)
            throw new InvalidOperationException("Envelope payload cannot be null");

        var payloadArray = payloadBytes.Value.ToByteArray();

        if (!EventTypeMap.TryGetValue(eventType, out var eventTypeType))
            throw new InvalidOperationException($"Unknown event type: {eventType}");

        var eventObj = MessagePackSerializer.Deserialize(eventTypeType, payloadArray, Options);
        return (IPlateKinematicsEvent)eventObj!;
    }

    public static T Deserialize<T>(byte[] data) where T : IPlateKinematicsEvent
    {
        var reader = new MessagePackReader(data);
        var length = reader.ReadArrayHeader();
        if (length != 2)
            throw new InvalidOperationException($"Invalid event envelope. Expected 2 elements, got {length}");

        var eventType = reader.ReadString();
        if (eventType is null)
            throw new InvalidOperationException("Envelope eventType cannot be null");

        var payloadBytes = reader.ReadBytes();
        if (!payloadBytes.HasValue)
            throw new InvalidOperationException("Event payload cannot be null");

        var payload = payloadBytes.Value.ToByteArray();
        return MessagePackSerializer.Deserialize<T>(payload, Options);
    }
}


// --- PATH: plugins/Geosphere.Plate.Motion.Solver/EulerFlowlineSolver.cs ---
using System.Collections.Immutable;
using Plate.TimeDete.Time.Primitives;
using FantaSim.Geosphere.Plate.Kinematics.Contracts.Derived;
using FantaSim.Geosphere.Plate.Topology.Contracts.Derived;
using FantaSim.Geosphere.Plate.Topology.Contracts.Entities;
using FantaSim.Geosphere.Plate.Velocity.Contracts;
using FantaSim.Geosphere.Plate.Motion.Contracts;

namespace FantaSim.Geosphere.Plate.Motion.Solver;

/// <summary>
/// Computes flowlines using Euler integration for motion path tracing (RFC-V2-0035 §8.2).
/// </summary>
/// <remarks>
/// <para>
/// <b>Algorithm:</b> For each boundary velocity sample, extracts the seed position and
/// resolves the plate based on PlateSide (Left uses boundary.PlateIdLeft, Right uses
/// boundary.PlateIdRight). Delegates to EulerMotionPathSolver for the actual integration.
/// </para>
/// <para>
/// <b>Determinism:</b> Pure function with no I/O. Same inputs always produce identical outputs.
/// Suitable for Solver Lab corpus verification.
/// </para>
/// </remarks>
public sealed class EulerFlowlineSolver : IFlowlineSolver
{
    private readonly EulerMotionPathSolver _motionPathSolver;

    public EulerFlowlineSolver(IPlateVelocitySolver velocitySolver)
    {
        ArgumentNullException.ThrowIfNull(velocitySolver);
        _motionPathSolver = new EulerMotionPathSolver(velocitySolver);
    }

    public Flowline ComputeFlowline(
        BoundaryId boundaryId,
        BoundaryVelocitySample seed,
        PlateSide side,
        CanonicalTick startTick,
        CanonicalTick endTick,
        IntegrationDirection direction,
        IPlateTopologyStateView topology,
        IPlateKinematicsStateView kinematics,
        MotionIntegrationSpec? spec = null)
    {
        ArgumentNullException.ThrowIfNull(topology);
        ArgumentNullException.ThrowIfNull(kinematics);

        // Resolve the plate based on side
        var plateId = ResolvePlateId(boundaryId, side, topology);

        // Extract seed position from the boundary velocity sample
        var seedPosition = new UnifyGeometry.Point3(
            seed.Position.X,
            seed.Position.Y,
            seed.Position.Z);

        // Compute motion path using the Euler solver
        var motionPath = _motionPathSolver.ComputeMotionPath(
            plateId,
            seedPosition,
            startTick,
            endTick,
            direction,
            topology,
            kinematics,
            spec);

        // Transform motion path into flowline
        return new Flowline(
            boundaryId,
            seed.SampleIndex,
            side,
            motionPath.StartTick,
            motionPath.EndTick,
            motionPath.Direction,
            motionPath.Samples);
    }

    public ImmutableArray<Flowline> ComputeFlowlinesForBoundary(
        BoundaryId boundaryId,
        IReadOnlyList<BoundaryVelocitySample> samples,
        PlateSide side,
        CanonicalTick startTick,
        CanonicalTick endTick,
        IntegrationDirection direction,
        IPlateTopologyStateView topology,
        IPlateKinematicsStateView kinematics,
        MotionIntegrationSpec? spec = null)
    {
        ArgumentNullException.ThrowIfNull(samples);
        ArgumentNullException.ThrowIfNull(topology);
        ArgumentNullException.ThrowIfNull(kinematics);

        var flowlines = new List<Flowline>(samples.Count);

        // Iterate through samples in order (by index)
        for (var i = 0; i < samples.Count; i++)
        {
            var flowline = ComputeFlowline(
                boundaryId,
                samples[i],
                side,
                startTick,
                endTick,
                direction,
                topology,
                kinematics,
                spec);

            flowlines.Add(flowline);
        }

        return flowlines.ToImmutableArray();
    }

    /// <summary>
    /// Resolves the plate ID based on the specified side of the boundary.
    /// </summary>
    private static PlateId ResolvePlateId(
        BoundaryId boundaryId,
        PlateSide side,
        IPlateTopologyStateView topology)
    {
        if (!topology.Boundaries.TryGetValue(boundaryId, out var boundary))
        {
            throw new ArgumentException(
                $"Boundary {boundaryId} not found in topology",
                nameof(boundaryId));
        }

        return side switch
        {
            PlateSide.Left => boundary.PlateIdLeft,
            PlateSide.Right => boundary.PlateIdRight,
            _ => throw new ArgumentException($"Unknown plate side: {side}", nameof(side))
        };
    }
}


// --- PATH: plugins/Geosphere.Plate.Motion.Solver/EulerMotionPathSolver.cs ---
﻿using System.Collections.Immutable;
using Plate.TimeDete.Time.Primitives;
using UnifyGeometry;
using FantaSim.Geosphere.Plate.Kinematics.Contracts.Derived;
using FantaSim.Geosphere.Plate.Topology.Contracts.Derived;
using FantaSim.Geosphere.Plate.Topology.Contracts.Entities;
using FantaSim.Geosphere.Plate.Topology.Contracts.Numerics;
using FantaSim.Geosphere.Plate.Velocity.Contracts;
using FantaSim.Geosphere.Plate.Motion.Contracts;

namespace FantaSim.Geosphere.Plate.Motion.Solver;

/// <summary>
/// Computes motion paths using Euler integration (RFC-V2-0035 §9.2).
/// </summary>
/// <remarks>
/// <para>
/// <b>Algorithm:</b>
/// <code>
/// p(t + Δt) = NormalizeToBodySurface( p(t) + v(p,t) * Δt )
/// </code>
/// where Δt = StepTicks and v(p,t) is queried via IPlateVelocitySolver.GetAbsoluteVelocity().
/// </para>
/// <para>
/// <b>Determinism:</b> Pure function with no I/O. Same inputs always produce identical outputs.
/// Suitable for Solver Lab corpus verification.
/// </para>
/// <para>
/// <b>Fallback:</b> Returns zero velocity when kinematics data is missing,
/// allowing integration to continue (the point stays stationary for that step).
/// </para>
/// </remarks>
public sealed class EulerMotionPathSolver : IMotionPathSolver
{
    private readonly IPlateVelocitySolver _velocitySolver;

    public EulerMotionPathSolver(IPlateVelocitySolver velocitySolver)
    {
        _velocitySolver = velocitySolver ?? throw new ArgumentNullException(nameof(velocitySolver));
    }

    public MotionPath ComputeMotionPath(
        PlateId plateId,
        Point3 startPoint,
        CanonicalTick startTick,
        CanonicalTick endTick,
        IntegrationDirection direction,
        IPlateTopologyStateView topology,
        IPlateKinematicsStateView kinematics,
        MotionIntegrationSpec? spec = null)
    {
        ArgumentNullException.ThrowIfNull(topology);
        ArgumentNullException.ThrowIfNull(kinematics);

        // Use default spec if not provided (use .Default, not new() due to struct semantics)
        var integrationSpec = spec ?? MotionIntegrationSpec.Default;

        // Build samples list
        var samples = new List<MotionPathSample>();
        var p = startPoint;
        var t = startTick;
        var step = 0;

        while (!ReachedEnd(t, endTick, direction) && step < integrationSpec.MaxSteps)
        {
            // Query velocity at current position and time
            var positionVector = new Vector3d(p.X, p.Y, p.Z);
            var v = _velocitySolver.GetAbsoluteVelocity(kinematics, plateId, positionVector, t);

            // Record sample
            samples.Add(new MotionPathSample(t, p, v, step));

            // Compute dt based on direction
            var dt = direction == IntegrationDirection.Forward
                ? integrationSpec.StepTicks
                : -integrationSpec.StepTicks;

            // Euler step: p' = p + v * dt
            var newPositionVector = positionVector + new Vector3d(v.X * dt, v.Y * dt, v.Z * dt);

            // Project back onto body surface (unit sphere normalization)
            p = NormalizeToBodySurface(newPositionVector);

            // Advance time
            t = new CanonicalTick(t.Value + dt);
            step++;
        }

        return new MotionPath(plateId, startTick, endTick, direction, samples.ToImmutableArray());
    }

    /// <summary>
    /// Determines if integration has reached the end tick based on direction.
    /// </summary>
    private static bool ReachedEnd(CanonicalTick currentTick, CanonicalTick endTick, IntegrationDirection direction)
    {
        return direction == IntegrationDirection.Forward
            ? currentTick.Value >= endTick.Value
            : currentTick.Value <= endTick.Value;
    }

    /// <summary>
    /// Projects a point onto the body surface (unit sphere).
    /// </summary>
    /// <remarks>
    /// For the MVP, we assume a unit sphere body frame. The point is normalized to unit length.
    /// Future extensions may support ellipsoid or custom surface functions.
    /// </remarks>
    private static Point3 NormalizeToBodySurface(Vector3d point)
    {
        var length = point.Length();
        if (length < double.Epsilon)
        {
            // If point is at origin, return a default unit vector
            return new Point3(1, 0, 0);
        }

        var normalized = point / length;
        return new Point3(normalized.X, normalized.Y, normalized.Z);
    }
}


// --- PATH: plugins/Geosphere.Plate.Polygonization.Solver/CMap/BoundaryCMapBuilder.cs ---
﻿using FantaSim.Geosphere.Plate.Polygonization.Contracts.CMap;
using FantaSim.Geosphere.Plate.Topology.Contracts.Derived;
using FantaSim.Geosphere.Plate.Topology.Contracts.Entities;
using UnifyGeometry;

namespace FantaSim.Geosphere.Plate.Polygonization.Solver.CMap;

/// <summary>
/// Builds a boundary combinatorial map from topology state.
///
/// RFC-V2-0041 §11.1: Build cmap from boundary network.
///
/// Algorithm:
/// 1. Create two darts per boundary (Forward/Backward)
/// 2. Link twin darts
/// 3. Set origin junctions
/// 4. Compute cyclic ordering at each junction (by angle)
/// 5. Set Next pointers based on cyclic ordering
/// </summary>
public sealed class BoundaryCMapBuilder : IBoundaryCMapBuilder
{
    /// <inheritdoc />
    public IBoundaryCMap Build(IPlateTopologyStateView topology)
    {
        var cmap = new InMemoryBoundaryCMap();
        var dartDirections = new Dictionary<BoundaryDart, Point3>();
        var dartDestinations = new Dictionary<BoundaryDart, JunctionId>();

        // 1. Add all junctions
        foreach (var junction in topology.Junctions.Values.Where(j => !j.IsRetired))
        {
            cmap.AddJunction(junction.JunctionId);
        }

        // 2. Create darts for each boundary
        foreach (var boundary in topology.Boundaries.Values.Where(b => !b.IsRetired))
        {
            var endpoints = GetBoundaryEndpoints(boundary, topology);
            if (endpoints == null)
            {
                throw new CMapBuildException(
                    $"Boundary {boundary.BoundaryId} is not connected to exactly two junctions");
            }

            var (startJunction, endJunction, startPoint, endPoint) = endpoints.Value;

            // Forward dart: start → end
            var forwardDart = new BoundaryDart
            {
                BoundaryId = boundary.BoundaryId,
                SegmentIndex = 0,
                Direction = DartDirection.Forward
            };

            // Backward dart: end → start
            var backwardDart = new BoundaryDart
            {
                BoundaryId = boundary.BoundaryId,
                SegmentIndex = 0,
                Direction = DartDirection.Backward
            };

            // Add darts with their origins
            cmap.AddDart(forwardDart, startJunction);
            cmap.AddDart(backwardDart, endJunction);

            // Link twins
            cmap.SetTwin(forwardDart, backwardDart);

            // Store directions for angle sorting (outgoing direction from origin)
            var forwardDir = ComputeDirection(startPoint, endPoint);
            var backwardDir = ComputeDirection(endPoint, startPoint);
            dartDirections[forwardDart] = forwardDir;
            dartDirections[backwardDart] = backwardDir;

            // Store destinations for Next pointer computation
            dartDestinations[forwardDart] = endJunction;
            dartDestinations[backwardDart] = startJunction;
        }

        // 3. Sort incidents at each junction by angle (CCW from +X)
        cmap.SortIncidentsByAngle(d => dartDirections[d]);

        // 4. Set Next pointers
        // For each dart d, Next(d) is the twin of the "next" dart in cyclic order at d's destination
        foreach (var dart in cmap.Darts)
        {
            var destination = dartDestinations[dart];
            var incidentsAtDest = cmap.IncidentOrdered(destination);

            if (incidentsAtDest.Count == 0)
            {
                throw new CMapBuildException(
                    $"Junction {destination} has no incident darts");
            }

            // Find the twin of dart in the incident list at destination
            var twinDart = cmap.Twin(dart);

            // Find index of twin in the cyclic order at destination
            var twinIndex = -1;
            for (int i = 0; i < incidentsAtDest.Count; i++)
            {
                if (incidentsAtDest[i] == twinDart)
                {
                    twinIndex = i;
                    break;
                }
            }

            if (twinIndex < 0)
            {
                throw new CMapBuildException(
                    $"Twin of dart {dart} not found in incidents at junction {destination}");
            }

            // Next in face = the dart that comes AFTER twin in CCW order (wrapped)
            // This gives us the "turn left" behavior for face walking
            var nextIndex = (twinIndex + 1) % incidentsAtDest.Count;
            var nextDart = incidentsAtDest[nextIndex];

            cmap.SetNext(dart, nextDart);
        }

        return cmap;
    }

    /// <summary>
    /// Gets the start and end junctions for a boundary.
    /// Returns null if the boundary is not properly connected to exactly two junctions.
    /// </summary>
    private static (JunctionId start, JunctionId end, Point3 startPt, Point3 endPt)?
        GetBoundaryEndpoints(Boundary boundary, IPlateTopologyStateView topology)
    {
        // Find junctions that contain this boundary
        var connectedJunctions = topology.Junctions.Values
            .Where(j => !j.IsRetired && j.BoundaryIds.Contains(boundary.BoundaryId))
            .ToList();

        if (connectedJunctions.Count != 2)
            return null;

        // Get geometry endpoints
        var (startPt, endPt) = GetPolylineEndpoints(boundary.Geometry);

        // Match junctions to endpoints by proximity
        var j0 = connectedJunctions[0];
        var j1 = connectedJunctions[1];

        // Convert SurfacePoint to Point3 for distance calculations
        var j0Pos = j0.Location.ToPositionVector();
        var j1Pos = j1.Location.ToPositionVector();
        var j0Pt = new Point3(j0Pos.X, j0Pos.Y, j0Pos.Z);
        var j1Pt = new Point3(j1Pos.X, j1Pos.Y, j1Pos.Z);

        var d0ToStart = DistanceSquared(j0Pt, startPt);
        var d1ToStart = DistanceSquared(j1Pt, startPt);

        if (d0ToStart < d1ToStart)
        {
            // j0 is at start, j1 is at end
            return (j0.JunctionId, j1.JunctionId, startPt, endPt);
        }
        else
        {
            // j1 is at start, j0 is at end
            return (j1.JunctionId, j0.JunctionId, startPt, endPt);
        }
    }

    private static (Point3 start, Point3 end) GetPolylineEndpoints(IGeometry geometry)
    {
        if (geometry is Polyline3 polyline && !polyline.IsEmpty)
        {
            return (polyline.Points[0], polyline.Points[^1]);
        }

        throw new CMapBuildException($"Boundary geometry is not a non-empty Polyline3");
    }

    private static Point3 ComputeDirection(Point3 from, Point3 to)
    {
        var dx = to.X - from.X;
        var dy = to.Y - from.Y;
        var dz = to.Z - from.Z;
        var len = Math.Sqrt(dx * dx + dy * dy + dz * dz);
        if (len < 1e-12) return new Point3(1, 0, 0); // fallback
        return new Point3(dx / len, dy / len, dz / len);
    }

    private static double DistanceSquared(Point3 a, Point3 b)
    {
        var dx = a.X - b.X;
        var dy = a.Y - b.Y;
        var dz = a.Z - b.Z;
        return dx * dx + dy * dy + dz * dz;
    }
}


// --- PATH: plugins/Geosphere.Plate.Polygonization.Solver/CMap/InMemoryBoundaryCMap.cs ---
﻿using System.Collections.Immutable;
using FantaSim.Geosphere.Plate.Polygonization.Contracts.CMap;
using FantaSim.Geosphere.Plate.Topology.Contracts.Entities;
using UnifyGeometry;

namespace FantaSim.Geosphere.Plate.Polygonization.Solver.CMap;

/// <summary>
/// In-memory implementation of the minimal boundary combinatorial map.
///
/// This is built fresh per tick from the topology state view.
/// It provides the core cmap operations needed for polygonization:
/// - Twin, Next, Origin relations
/// - Deterministic cyclic ordering at junctions
///
/// RFC-V2-0041 §11: Minimal cmap subset v0.
/// </summary>
public sealed class InMemoryBoundaryCMap : IBoundaryCMap
{
    private readonly Dictionary<BoundaryDart, BoundaryDart> _twin = new();
    private readonly Dictionary<BoundaryDart, BoundaryDart> _next = new();
    private readonly Dictionary<BoundaryDart, JunctionId> _origin = new();
    private readonly Dictionary<JunctionId, List<BoundaryDart>> _incidentDarts = new();
    private readonly SortedSet<BoundaryDart> _allDarts = new();
    private readonly SortedSet<JunctionId> _allJunctions = new(Comparer<JunctionId>.Create(
        (a, b) => a.Value.CompareTo(b.Value)));

    /// <inheritdoc />
    public IEnumerable<JunctionId> Junctions => _allJunctions;

    /// <inheritdoc />
    public IEnumerable<BoundaryDart> Darts => _allDarts;

    /// <inheritdoc />
    public JunctionId Origin(BoundaryDart dart)
    {
        if (!_origin.TryGetValue(dart, out var junction))
            throw new KeyNotFoundException($"Dart {dart} not found in cmap");
        return junction;
    }

    /// <inheritdoc />
    public BoundaryDart Twin(BoundaryDart dart)
    {
        if (!_twin.TryGetValue(dart, out var twin))
            throw new KeyNotFoundException($"Dart {dart} not found in cmap");
        return twin;
    }

    /// <inheritdoc />
    public BoundaryDart Next(BoundaryDart dart)
    {
        if (!_next.TryGetValue(dart, out var next))
            throw new KeyNotFoundException($"Dart {dart} not found in cmap");
        return next;
    }

    /// <inheritdoc />
    public IReadOnlyList<BoundaryDart> IncidentOrdered(JunctionId junction)
    {
        if (!_incidentDarts.TryGetValue(junction, out var darts))
            return Array.Empty<BoundaryDart>();
        return darts;
    }

    /// <inheritdoc />
    public bool ContainsDart(BoundaryDart dart) => _allDarts.Contains(dart);

    // ========== Builder methods (internal) ==========

    internal void AddJunction(JunctionId junction)
    {
        _allJunctions.Add(junction);
        if (!_incidentDarts.ContainsKey(junction))
            _incidentDarts[junction] = new List<BoundaryDart>();
    }

    internal void AddDart(BoundaryDart dart, JunctionId origin)
    {
        _allDarts.Add(dart);
        _origin[dart] = origin;

        if (!_incidentDarts.ContainsKey(origin))
            _incidentDarts[origin] = new List<BoundaryDart>();
        _incidentDarts[origin].Add(dart);
    }

    internal void SetTwin(BoundaryDart a, BoundaryDart b)
    {
        _twin[a] = b;
        _twin[b] = a;
    }

    internal void SetNext(BoundaryDart dart, BoundaryDart next)
    {
        _next[dart] = next;
    }

    /// <summary>
    /// Sorts incident darts at each junction by angle (CCW from +X axis).
    /// Must be called after all darts are added.
    /// </summary>
    /// <remarks>
    /// <para>
    /// <b>Determinism Contract</b>: This method uses <see cref="DeterministicOrder"/> to guarantee
    /// stable, reproducible ordering across runs and machines.
    /// </para>
    /// <para>
    /// Sort key precedence (via DeterministicOrder.CompareDarts):
    /// </para>
    /// <list type="number">
    ///   <item>Angle (with AnglePolicy epsilon tolerance)</item>
    ///   <item>BoundaryDart composite key (BoundaryId → SegmentIndex → Direction)</item>
    /// </list>
    /// <para>
    /// This ensures that when two darts have nearly the same angle (e.g., collinear boundaries),
    /// the result is stable and reproducible. Without the tie-break, iteration order
    /// could depend on hash map ordering, causing "same data, different faces" bugs.
    /// </para>
    /// </remarks>
    internal void SortIncidentsByAngle(Func<BoundaryDart, Point3> getDartDirection)
        => SortIncidentsByAngle(getDartDirection, AnglePolicy.Default);

    /// <summary>
    /// Sorts incident darts at each junction by angle with explicit angle policy.
    /// </summary>
    /// <param name="getDartDirection">Function to get outgoing direction vector for a dart.</param>
    /// <param name="anglePolicy">Policy for angle comparison (epsilon, quantization).</param>
    internal void SortIncidentsByAngle(Func<BoundaryDart, Point3> getDartDirection, AnglePolicy anglePolicy)
    {
        foreach (var junction in _allJunctions)
        {
            if (!_incidentDarts.TryGetValue(junction, out var darts) || darts.Count == 0)
                continue;

            // Use DeterministicOrder for canonical, stable sorting
            // This is the ONLY place dart ordering should happen
            darts.Sort((a, b) =>
            {
                var dirA = getDartDirection(a);
                var dirB = getDartDirection(b);

                var angleA = DeterministicOrder.ComputeAngle(dirA.X, dirA.Y);
                var angleB = DeterministicOrder.ComputeAngle(dirB.X, dirB.Y);

                return DeterministicOrder.CompareDarts(anglePolicy, angleA, a, angleB, b);
            });
        }
    }
}


// --- PATH: plugins/Geosphere.Plate.Polygonization.Solver/HoleAssigner.cs ---
﻿using System.Collections.Immutable;
using FantaSim.Geosphere.Plate.Polygonization.Contracts.Products;
using UnifyGeometry;

namespace FantaSim.Geosphere.Plate.Polygonization.Solver;

/// <summary>
/// Assigns holes to outer rings per RFC-V2-0041 §9.4.
///
/// Classification rules:
/// 1. Rings with positive signed area (CCW) are outer rings
/// 2. Rings with negative signed area (CW) are holes
/// 3. Each hole is assigned to the innermost containing outer ring via centroid point-in-polygon test
/// </summary>
public static class HoleAssigner
{
    /// <summary>
    /// Result of hole assignment for a single plate.
    /// </summary>
    public readonly record struct PlateRingGroup(
        Polyline3 OuterRing,
        ImmutableArray<Polyline3> Holes
    );

    /// <summary>
    /// Classifies and assigns rings for a single plate.
    ///
    /// All input rings belong to the same PlateId. This method:
    /// 1. Separates rings into outers (CCW/positive area) and holes (CW/negative area)
    /// 2. Assigns each hole to its containing outer ring
    /// 3. Returns grouped outer+holes structures
    /// </summary>
    /// <param name="rings">All rings belonging to a single plate.</param>
    /// <param name="winding">Winding convention (default CCW = outer is positive area).</param>
    /// <returns>List of (outer, holes) groups. Usually one group per plate, but multiple if disjoint regions.</returns>
    public static IReadOnlyList<PlateRingGroup> AssignHoles(
        IReadOnlyList<Polyline3> rings,
        WindingConvention winding = WindingConvention.CounterClockwise)
    {
        if (rings.Count == 0)
        {
            return Array.Empty<PlateRingGroup>();
        }

        if (rings.Count == 1)
        {
            // Single ring = outer, no holes
            return new[] { new PlateRingGroup(rings[0], ImmutableArray<Polyline3>.Empty) };
        }

        // Classify rings by signed area
        var classified = rings
            .Select(r => (ring: r, area: RingCanonicalizer.ComputeSignedArea(r)))
            .ToList();

        // For CCW convention: positive area = outer, negative = hole
        // For CW convention: negative area = outer, positive = hole
        var isOuterPositive = winding == WindingConvention.CounterClockwise;

        var outers = classified
            .Where(c => isOuterPositive ? c.area > 0 : c.area < 0)
            .Select(c => (ring: c.ring, absArea: Math.Abs(c.area)))
            .OrderByDescending(c => c.absArea) // Largest outer first
            .ToList();

        var holes = classified
            .Where(c => isOuterPositive ? c.area < 0 : c.area > 0)
            .Select(c => c.ring)
            .ToList();

        if (outers.Count == 0)
        {
            // All rings are holes? This shouldn't happen for valid topology.
            // Return empty - caller should handle this as an error.
            return Array.Empty<PlateRingGroup>();
        }

        if (outers.Count == 1)
        {
            // Single outer, all holes belong to it
            return new[] { new PlateRingGroup(outers[0].ring, holes.ToImmutableArray()) };
        }

        // Multiple outers (disjoint regions of the same plate)
        // Assign each hole to the innermost containing outer
        var outerHoles = outers.ToDictionary(
            o => o.ring,
            _ => new List<Polyline3>());

        foreach (var hole in holes)
        {
            var centroid = ComputeCentroid(hole);
            Polyline3? containingOuter = null;
            var containingArea = double.MaxValue;

            foreach (var (outerRing, absArea) in outers)
            {
                if (PointInPolygon(centroid, outerRing))
                {
                    // Assign to innermost (smallest area) containing outer
                    if (absArea < containingArea)
                    {
                        containingOuter = outerRing;
                        containingArea = absArea;
                    }
                }
            }

            if (containingOuter != null)
            {
                outerHoles[containingOuter].Add(hole);
            }
            // Holes not contained by any outer are orphaned (topology error, but we don't fail here)
        }

        return outers
            .Select(o => new PlateRingGroup(o.ring, outerHoles[o.ring].ToImmutableArray()))
            .ToList();
    }

    /// <summary>
    /// Computes centroid of a ring (average of vertices).
    /// </summary>
    private static Point3 ComputeCentroid(Polyline3 ring)
    {
        if (ring.IsEmpty || ring.Count < 2)
        {
            return new Point3(0, 0, 0);
        }

        // Exclude closing point if ring is closed
        var isClosed = ArePointsEqual(ring[0], ring[ring.Count - 1]);
        var count = isClosed ? ring.Count - 1 : ring.Count;

        if (count == 0) return new Point3(0, 0, 0);

        double sumX = 0, sumY = 0, sumZ = 0;
        for (var i = 0; i < count; i++)
        {
            sumX += ring[i].X;
            sumY += ring[i].Y;
            sumZ += ring[i].Z;
        }

        return new Point3(sumX / count, sumY / count, sumZ / count);
    }

    /// <summary>
    /// Point-in-polygon test using ray casting algorithm (XY projection).
    /// </summary>
    private static bool PointInPolygon(Point3 point, Polyline3 polygon)
    {
        if (polygon.IsEmpty || polygon.Count < 4)
        {
            return false;
        }

        var x = point.X;
        var y = point.Y;
        var inside = false;

        var n = polygon.Count - 1; // Exclude closing point for iteration

        for (int i = 0, j = n - 1; i < n; j = i++)
        {
            var xi = polygon[i].X;
            var yi = polygon[i].Y;
            var xj = polygon[j].X;
            var yj = polygon[j].Y;

            // Ray casting: count edge crossings
            if (((yi > y) != (yj > y)) &&
                (x < (xj - xi) * (y - yi) / (yj - yi) + xi))
            {
                inside = !inside;
            }
        }

        return inside;
    }

    private static bool ArePointsEqual(Point3 a, Point3 b, double tolerance = 1e-12)
    {
        return Math.Abs(a.X - b.X) < tolerance &&
               Math.Abs(a.Y - b.Y) < tolerance &&
               Math.Abs(a.Z - b.Z) < tolerance;
    }
}


// --- PATH: plugins/Geosphere.Plate.Polygonization.Solver/PlatePolygonizer.cs ---
﻿using System.Collections.Immutable;
using FantaSim.Geosphere.Plate.Polygonization.Contracts.CMap;
using FantaSim.Geosphere.Plate.Polygonization.Contracts.Products;
using FantaSim.Geosphere.Plate.Polygonization.Contracts.Solvers;
using FantaSim.Geosphere.Plate.Topology.Contracts.Derived;
using FantaSim.Geosphere.Plate.Topology.Contracts.Entities;
using FantaSim.Geosphere.Plate.Topology.Contracts.Numerics;
using Plate.TimeDete.Time.Primitives;
using UnifyGeometry;

namespace FantaSim.Geosphere.Plate.Polygonization.Solver;

/// <summary>
/// Extracts plate polygons from boundary network using combinatorial map face-walk.
/// RFC-V2-0041 implementation.
/// </summary>
/// <remarks>
/// <para>
/// Face→Plate attribution rule: The face lies on the LEFT side of each dart in the face loop.
/// For a dart on boundary B with direction Forward:
///   - Left side = B.PlateIdLeft
/// For a dart on boundary B with direction Backward:
///   - Left side = B.PlateIdRight (because we're walking the edge in reverse)
/// </para>
/// <para>
/// <b>Spherical-correct:</b> Uses <see cref="SphericalGeometry.ComputeSignedSphericalArea"/>
/// to determine outer vs inner rings and identify the "outside" face. This is correct
/// anywhere on the sphere, unlike planar signed area which breaks at poles and antimeridian.
/// </para>
/// <para>
/// Outside face policy: The face with largest absolute spherical area is treated as "exterior"
/// and excluded from the polygon set (or assigned PlateId.Empty).
/// </para>
/// </remarks>
public sealed class PlatePolygonizer : IPlatePolygonizer
{
    private readonly IBoundaryCMapBuilder _cmapBuilder;

    public PlatePolygonizer(IBoundaryCMapBuilder cmapBuilder)
    {
        _cmapBuilder = cmapBuilder ?? throw new ArgumentNullException(nameof(cmapBuilder));
    }

    /// <inheritdoc />
    public PlatePolygonSet PolygonizeAtTick(
        CanonicalTick tick,
        IPlateTopologyStateView topology,
        PolygonizationOptions? options = null)
    {
        ArgumentNullException.ThrowIfNull(topology);
        options ??= new PolygonizationOptions();

        // Build combinatorial map
        var cmap = _cmapBuilder.Build(topology);

        // Enumerate all faces
        var faces = cmap.EnumerateFaces().ToList();

        if (faces.Count == 0)
        {
            return new PlatePolygonSet(tick, ImmutableArray<PlatePolygon>.Empty);
        }

        // Convert faces to attributed polygons
        var attributedFaces = new List<(PlateId plateId, Polyline3 ring, double signedArea)>();
        var errors = new List<string>();

        foreach (var faceDarts in faces)
        {
            var (plateId, ring, signedArea, error) = ProcessFace(faceDarts, cmap, topology);
            if (error != null)
            {
                errors.Add(error);
                continue;
            }
            attributedFaces.Add((plateId, ring, signedArea));
        }

        if (errors.Count > 0 && !options.Value.AllowPartialPolygonization)
        {
            throw new PolygonizationException(
                $"Face attribution failed: {string.Join("; ", errors)}",
                new PolygonizationDiagnostics(
                    false,
                    ImmutableArray<OpenBoundaryDiagnostic>.Empty,
                    ImmutableArray<NonManifoldJunctionDiagnostic>.Empty,
                    ImmutableArray<DisconnectedComponentDiagnostic>.Empty));
        }

        // Identify outside face (largest absolute area)
        var outsideFaceIndex = FindOutsideFaceIndex(attributedFaces);

        // Group by PlateId (excluding outside face), keeping signed area for outer/hole determination
        var ringsByPlate = new Dictionary<PlateId, List<(Polyline3 ring, double signedArea)>>();
        for (int i = 0; i < attributedFaces.Count; i++)
        {
            if (i == outsideFaceIndex) continue;

            var (plateId, ring, signedArea) = attributedFaces[i];
            if (plateId.IsEmpty) continue; // Skip unattributed faces

            if (!ringsByPlate.TryGetValue(plateId, out var rings))
            {
                rings = new List<(Polyline3, double)>();
                ringsByPlate[plateId] = rings;
            }
            rings.Add((ring, signedArea));
        }

        // Build PlatePolygons with proper outer/hole determination
        var polygons = new List<PlatePolygon>();
        foreach (var (plateId, rings) in ringsByPlate)
        {
            if (rings.Count == 0) continue;

            // Separate outers (positive signed area) from holes (negative signed area)
            // On a unit sphere with CCW winding: positive = outer, negative = hole
            var outers = rings.Where(r => r.signedArea > 0).Select(r => CanonicalizeRing(r.ring)).ToList();
            var holes = rings.Where(r => r.signedArea <= 0).Select(r => CanonicalizeRing(r.ring)).ToList();

            if (outers.Count == 0)
            {
                // Edge case: all rings are holes (impossible on a closed surface for a valid plate)
                // Take the largest absolute area as outer
                var largest = rings.OrderByDescending(r => Math.Abs(r.signedArea)).First();
                outers.Add(CanonicalizeRing(largest.ring));
                holes = rings.Where(r => r != largest).Select(r => CanonicalizeRing(r.ring)).ToList();
            }

            if (outers.Count == 1)
            {
                // Simple case: one outer, all holes belong to it
                polygons.Add(new PlatePolygon(plateId, outers[0], holes.ToImmutableArray()));
            }
            else
            {
                // Complex case: multiple outers (archipelago) - assign holes via centroid containment
                // For now, create separate polygons for each outer; proper hole assignment
                // would require point-in-polygon testing using spherical containment
                foreach (var outer in outers)
                {
                    // Find holes whose centroids are contained in this outer
                    // For MVP, we skip complex assignment and create outer-only polygons
                    // TODO: Implement spherical point-in-polygon for proper hole assignment
                    polygons.Add(new PlatePolygon(plateId, outer, ImmutableArray<Polyline3>.Empty));
                }
                // Orphan holes go to the largest outer as a fallback
                if (holes.Count > 0)
                {
                    var largestOuter = outers.OrderByDescending(o => Math.Abs(SphericalGeometry.ComputeSignedSphericalArea(o))).First();
                    var largestIndex = polygons.FindIndex(p => p.PlateId == plateId && p.OuterRing == largestOuter);
                    if (largestIndex >= 0)
                    {
                        var existing = polygons[largestIndex];
                        polygons[largestIndex] = new PlatePolygon(plateId, existing.OuterRing, holes.ToImmutableArray());
                    }
                }
            }
        }

        // Sort by PlateId for determinism
        polygons.Sort((a, b) => a.PlateId.Value.CompareTo(b.PlateId.Value));

        return new PlatePolygonSet(tick, polygons.ToImmutableArray());
    }

    /// <inheritdoc />
    public BoundaryFaceAdjacencyMap GetBoundaryFaceAdjacency(
        CanonicalTick tick,
        IPlateTopologyStateView topology,
        PolygonizationOptions? options = null)
    {
        ArgumentNullException.ThrowIfNull(topology);

        // Build adjacencies from boundary truth (not cmap - direct from source)
        var adjacencies = new List<BoundaryFaceAdjacency>();

        foreach (var boundary in topology.Boundaries.Values.Where(b => !b.IsRetired))
        {
            // Each boundary segment maps directly to its left/right plates
            adjacencies.Add(new BoundaryFaceAdjacency(
                boundary.BoundaryId,
                SegmentIndex: 0, // Single segment for now
                boundary.PlateIdLeft,
                boundary.PlateIdRight));
        }

        // Sort for determinism
        adjacencies.Sort((a, b) =>
        {
            var cmp = a.BoundaryId.Value.CompareTo(b.BoundaryId.Value);
            return cmp != 0 ? cmp : a.SegmentIndex.CompareTo(b.SegmentIndex);
        });

        return new BoundaryFaceAdjacencyMap(tick, adjacencies.ToImmutableArray());
    }

    /// <inheritdoc />
    public PolygonizationDiagnostics Validate(
        CanonicalTick tick,
        IPlateTopologyStateView topology,
        PolygonizationOptions? options = null)
    {
        ArgumentNullException.ThrowIfNull(topology);

        var openBoundaries = new List<OpenBoundaryDiagnostic>();
        var nonManifoldJunctions = new List<NonManifoldJunctionDiagnostic>();

        try
        {
            // Check for dangling boundaries (not connected to 2 junctions)
            foreach (var boundary in topology.Boundaries.Values.Where(b => !b.IsRetired))
            {
                var connectedJunctions = topology.Junctions.Values
                    .Where(j => !j.IsRetired && j.BoundaryIds.Contains(boundary.BoundaryId))
                    .ToList();

                if (connectedJunctions.Count < 2)
                {
                    // Find the open endpoint
                    var endpoint = GetBoundaryEndpoint(boundary, connectedJunctions);
                    openBoundaries.Add(new OpenBoundaryDiagnostic(
                        boundary.BoundaryId,
                        endpoint,
                        $"Boundary connected to {connectedJunctions.Count} junctions (expected 2)"));
                }
            }

            // Check for non-manifold junctions (odd incident count is suspicious)
            foreach (var junction in topology.Junctions.Values.Where(j => !j.IsRetired))
            {
                var incidentCount = junction.BoundaryIds
                    .Count(bid => topology.Boundaries.TryGetValue(bid, out var b) && !b.IsRetired);

                // A valid manifold junction should have even incident count (each boundary enters and exits)
                // Single incident (degree 1) is always invalid for closed surfaces
                if (incidentCount == 1)
                {
                    var pos = junction.Location.ToPositionVector();
                    nonManifoldJunctions.Add(new NonManifoldJunctionDiagnostic(
                        junction.JunctionId,
                        new Point3(pos.X, pos.Y, pos.Z),
                        incidentCount,
                        "Junction has only one incident boundary (dangling)"));
                }
            }

            var isValid = openBoundaries.Count == 0 && nonManifoldJunctions.Count == 0;

            return new PolygonizationDiagnostics(
                isValid,
                openBoundaries.ToImmutableArray(),
                nonManifoldJunctions.ToImmutableArray(),
                ImmutableArray<DisconnectedComponentDiagnostic>.Empty);
        }
        catch (CMapBuildException ex)
        {
            // CMap build failure indicates fundamental topology issues
            return new PolygonizationDiagnostics(
                false,
                openBoundaries.ToImmutableArray(),
                nonManifoldJunctions.ToImmutableArray(),
                ImmutableArray.Create(new DisconnectedComponentDiagnostic(
                    0,
                    ImmutableArray<BoundaryId>.Empty,
                    $"CMap build failed: {ex.Message}")));
        }
    }

    private static Point3 GetBoundaryEndpoint(Boundary boundary, List<Junction> connectedJunctions)
    {
        if (boundary.Geometry is Polyline3 polyline && !polyline.IsEmpty)
        {
            // If we have one connected junction, return the OTHER endpoint
            if (connectedJunctions.Count == 1)
            {
                var jPos = connectedJunctions[0].Location.ToPositionVector();
                var junctionPt = new Point3(jPos.X, jPos.Y, jPos.Z);
                var startPt = polyline.Points[0];
                var endPt = polyline.Points[^1];

                // Return the endpoint farther from the connected junction
                var d0 = DistanceSquared(junctionPt, startPt);
                var d1 = DistanceSquared(junctionPt, endPt);
                return d0 > d1 ? startPt : endPt;
            }

            // No connected junctions - return start
            return polyline.Points[0];
        }

        return new Point3(0, 0, 0);
    }

    private static double DistanceSquared(Point3 a, Point3 b)
    {
        var dx = a.X - b.X;
        var dy = a.Y - b.Y;
        var dz = a.Z - b.Z;
        return dx * dx + dy * dy + dz * dz;
    }

    /// <summary>
    /// Process a face: extract ring geometry and attribute to plate.
    /// </summary>
    private static (PlateId plateId, Polyline3 ring, double signedArea, string? error)
        ProcessFace(
            IReadOnlyList<BoundaryDart> faceDarts,
            IBoundaryCMap cmap,
            IPlateTopologyStateView topology)
    {
        if (faceDarts.Count == 0)
        {
            return (default, Polyline3.Empty, 0, "Empty face");
        }

        // Collect junction positions along the face
        var points = new List<Point3>();
        PlateId? attributedPlate = null;
        string? attributionError = null;

        foreach (var dart in faceDarts)
        {
            var junctionId = cmap.Origin(dart);
            if (!topology.Junctions.TryGetValue(junctionId, out var junction))
            {
                attributionError = $"Junction {junctionId} not found";
                continue;
            }

            // Add junction position (convert from SurfacePoint to Point3)
            var junctionPos = junction.Location.ToPositionVector();
            points.Add(new Point3(junctionPos.X, junctionPos.Y, junctionPos.Z));

            // Attribute: face is on LEFT side of each dart
            var leftPlate = GetLeftPlate(dart, topology);

            if (attributedPlate == null)
            {
                attributedPlate = leftPlate;
            }
            else if (leftPlate != attributedPlate)
            {
                // Inconsistent attribution within same face - topology error
                attributionError = $"Inconsistent plate attribution: dart {dart} has left plate {leftPlate}, but face already attributed to {attributedPlate}";
            }
        }

        // Close the ring (first point = last point)
        if (points.Count > 0)
        {
            points.Add(points[0]);
        }

        var ring = new Polyline3(points);
        // Use spherical area computation for correct results on the sphere
        var signedArea = SphericalGeometry.ComputeSignedSphericalArea(ring);

        return (attributedPlate ?? default, ring, signedArea, attributionError);
    }

    /// <summary>
    /// Gets the plate on the LEFT side of a dart.
    /// For Forward dart: left side = boundary.PlateIdLeft
    /// For Backward dart: left side = boundary.PlateIdRight
    /// </summary>
    private static PlateId GetLeftPlate(BoundaryDart dart, IPlateTopologyStateView topology)
    {
        if (!topology.Boundaries.TryGetValue(dart.BoundaryId, out var boundary))
        {
            return default; // Unknown
        }

        return dart.Direction == DartDirection.Forward
            ? boundary.PlateIdLeft
            : boundary.PlateIdRight;
    }

    /// <summary>
    /// Find the index of the outside face (largest absolute signed area).
    /// </summary>
    private static int FindOutsideFaceIndex(List<(PlateId plateId, Polyline3 ring, double signedArea)> faces)
    {
        if (faces.Count == 0) return -1;

        int maxIndex = 0;
        double maxAbsArea = Math.Abs(faces[0].signedArea);

        for (int i = 1; i < faces.Count; i++)
        {
            var absArea = Math.Abs(faces[i].signedArea);
            if (absArea > maxAbsArea)
            {
                maxAbsArea = absArea;
                maxIndex = i;
            }
        }

        return maxIndex;
    }

    /// <summary>
    /// Compute signed area of a 2D polygon (shoelace formula).
    /// Positive = CCW, Negative = CW.
    /// </summary>
    private static double ComputeSignedArea(IReadOnlyList<Point3> points)
    {
        if (points.Count < 3) return 0;

        double sum = 0;
        for (int i = 0; i < points.Count - 1; i++)
        {
            var p0 = points[i];
            var p1 = points[i + 1];
            sum += (p1.X - p0.X) * (p1.Y + p0.Y);
        }

        return -sum / 2.0; // Negate for standard CCW=positive convention
    }

    /// <summary>
    /// Canonicalizes a ring by rotating its vertices so that the lexicographically
    /// smallest vertex (by X, then Y, then Z) comes first.
    ///
    /// This ensures deterministic ring representation regardless of where the
    /// face-walk started. The closing point (first=last) is preserved.
    ///
    /// Example: Ring [B, C, D, A, B] with min vertex A becomes [A, B, C, D, A].
    /// </summary>
    private static Polyline3 CanonicalizeRing(Polyline3 ring)
    {
        var points = ring.Points;
        if (points.Length < 3) return ring;

        // Find the lexicographically smallest vertex (excluding the closing duplicate)
        // Ring is closed: points[0] == points[^1], so we look at points[0..^1]
        int minIndex = 0;
        var minPoint = points[0];

        for (int i = 1; i < points.Length - 1; i++)
        {
            var p = points[i];
            if (CompareLexicographic(p, minPoint) < 0)
            {
                minIndex = i;
                minPoint = p;
            }
        }

        if (minIndex == 0)
        {
            return ring; // Already canonical
        }

        // Rotate: take points from minIndex to end-1, then 0 to minIndex-1, then close
        var rotated = new Point3[points.Length];
        int n = points.Length - 1; // Exclude closing point for rotation
        for (int i = 0; i < n; i++)
        {
            rotated[i] = points[(minIndex + i) % n];
        }
        rotated[n] = rotated[0]; // Close the ring

        return new Polyline3(rotated);
    }

    /// <summary>
    /// Lexicographic comparison of two 3D points: X, then Y, then Z.
    /// </summary>
    private static int CompareLexicographic(Point3 a, Point3 b)
    {
        var cmpX = a.X.CompareTo(b.X);
        if (cmpX != 0) return cmpX;

        var cmpY = a.Y.CompareTo(b.Y);
        if (cmpY != 0) return cmpY;

        return a.Z.CompareTo(b.Z);
    }
}


// --- PATH: plugins/Geosphere.Plate.Polygonization.Solver/RingCanonicalizer.cs ---
﻿using FantaSim.Geosphere.Plate.Polygonization.Contracts.Products;
using UnifyGeometry;

namespace FantaSim.Geosphere.Plate.Polygonization.Solver;

/// <summary>
/// Canonicalizes polygon rings per RFC-V2-0041 §9.3.
///
/// Canonicalization ensures deterministic ring representation:
/// 1. Rotate ring so lexicographically minimum vertex is first
/// 2. Enforce consistent winding convention (CCW for outers, CW for holes)
/// </summary>
public static class RingCanonicalizer
{
    /// <summary>
    /// Canonicalizes a ring by rotating to lex-min vertex and enforcing winding.
    /// </summary>
    /// <param name="ring">The input ring (closed polyline, first == last).</param>
    /// <param name="targetWinding">Desired winding convention.</param>
    /// <returns>Canonicalized ring.</returns>
    public static Polyline3 Canonicalize(Polyline3 ring, WindingConvention targetWinding)
    {
        if (ring.IsEmpty || ring.Count < 4)
        {
            // Need at least 3 unique vertices + closing point
            return ring;
        }

        // Work with unique vertices (exclude closing duplicate)
        var isClosed = ArePointsEqual(ring[0], ring[ring.Count - 1]);
        var uniqueCount = isClosed ? ring.Count - 1 : ring.Count;

        if (uniqueCount < 3)
        {
            return ring;
        }

        // Step 1: Find lexicographically minimum vertex index
        var minIndex = FindLexMinVertexIndex(ring, uniqueCount);

        // Step 2: Rotate ring so min vertex is first
        var rotated = RotateRing(ring, minIndex, uniqueCount);

        // Step 3: Compute current winding and reverse if needed
        var currentWinding = DetermineWinding(rotated);
        var needsReverse = (targetWinding == WindingConvention.CounterClockwise && currentWinding == WindingConvention.Clockwise) ||
                          (targetWinding == WindingConvention.Clockwise && currentWinding == WindingConvention.CounterClockwise);

        if (needsReverse)
        {
            rotated = ReverseRing(rotated);
        }

        return new Polyline3(rotated);
    }

    /// <summary>
    /// Finds the index of the lexicographically minimum vertex.
    /// Compares by X, then Y, then Z.
    /// </summary>
    private static int FindLexMinVertexIndex(Polyline3 ring, int count)
    {
        var minIndex = 0;
        var minPoint = ring[0];

        for (var i = 1; i < count; i++)
        {
            var p = ring[i];
            if (CompareLexicographic(p, minPoint) < 0)
            {
                minIndex = i;
                minPoint = p;
            }
        }

        return minIndex;
    }

    /// <summary>
    /// Lexicographic comparison: X, then Y, then Z.
    /// </summary>
    private static int CompareLexicographic(Point3 a, Point3 b)
    {
        var cmpX = a.X.CompareTo(b.X);
        if (cmpX != 0) return cmpX;

        var cmpY = a.Y.CompareTo(b.Y);
        if (cmpY != 0) return cmpY;

        return a.Z.CompareTo(b.Z);
    }

    /// <summary>
    /// Rotates ring so vertex at startIndex becomes first.
    /// Returns a closed ring (first == last).
    /// </summary>
    private static List<Point3> RotateRing(Polyline3 ring, int startIndex, int uniqueCount)
    {
        var result = new List<Point3>(uniqueCount + 1);

        for (var i = 0; i < uniqueCount; i++)
        {
            var srcIndex = (startIndex + i) % uniqueCount;
            result.Add(ring[srcIndex]);
        }

        // Close the ring
        result.Add(result[0]);

        return result;
    }

    /// <summary>
    /// Reverses ring order while keeping it closed (first == last).
    /// Preserves the first vertex position.
    /// </summary>
    private static List<Point3> ReverseRing(List<Point3> ring)
    {
        // For a ring [A, B, C, D, A], reversed keeping A first is [A, D, C, B, A]
        var uniqueCount = ring.Count - 1;
        var result = new List<Point3>(ring.Count) { ring[0] };

        for (var i = uniqueCount - 1; i >= 1; i--)
        {
            result.Add(ring[i]);
        }

        // Close
        result.Add(ring[0]);

        return result;
    }

    /// <summary>
    /// Determines the winding convention of a ring using signed area.
    /// </summary>
    public static WindingConvention DetermineWinding(IReadOnlyList<Point3> ring)
    {
        var signedArea = ComputeSignedArea(ring);
        // Positive area = CCW, Negative = CW (with standard coordinate system)
        return signedArea >= 0 ? WindingConvention.CounterClockwise : WindingConvention.Clockwise;
    }

    /// <summary>
    /// Computes signed area of a ring (shoelace formula, XY projection).
    /// Positive = CCW, Negative = CW.
    /// </summary>
    public static double ComputeSignedArea(IReadOnlyList<Point3> points)
    {
        if (points.Count < 3) return 0;

        double sum = 0;
        for (var i = 0; i < points.Count - 1; i++)
        {
            var p0 = points[i];
            var p1 = points[i + 1];
            sum += (p1.X - p0.X) * (p1.Y + p0.Y);
        }

        return -sum / 2.0; // Negate for standard CCW=positive convention
    }

    /// <summary>
    /// Computes signed area of a Polyline3 (shoelace formula, XY projection).
    /// Positive = CCW, Negative = CW.
    /// </summary>
    public static double ComputeSignedArea(Polyline3 ring)
    {
        if (ring.Count < 3) return 0;

        double sum = 0;
        for (var i = 0; i < ring.Count - 1; i++)
        {
            var p0 = ring[i];
            var p1 = ring[i + 1];
            sum += (p1.X - p0.X) * (p1.Y + p0.Y);
        }

        return -sum / 2.0; // Negate for standard CCW=positive convention
    }

    private static bool ArePointsEqual(Point3 a, Point3 b, double tolerance = 1e-12)
    {
        return Math.Abs(a.X - b.X) < tolerance &&
               Math.Abs(a.Y - b.Y) < tolerance &&
               Math.Abs(a.Z - b.Z) < tolerance;
    }
}


// --- PATH: plugins/Geosphere.Plate.Reconstruction.Solver/FeaturePlateAssigner.cs ---
using FantaSim.Geosphere.Plate.Reconstruction.Contracts;
using FantaSim.Geosphere.Plate.Topology.Contracts.Entities;
using FantaSim.Geosphere.Plate.Topology.Contracts.Identity;
using UnifyGeometry;
using UnifyGeometry.Operations;

namespace FantaSim.Geosphere.Plate.Reconstruction.Solver;

public sealed class FeaturePlateAssigner : IFeaturePlateAssigner
{
    public IReadOnlyList<ReconstructableFeature> AssignPlateProvenance(
        IReadOnlyList<ReconstructableFeature> features,
        IReadOnlyList<PlatePartitionRegion> partition)
    {
        ArgumentNullException.ThrowIfNull(features);
        ArgumentNullException.ThrowIfNull(partition);

        var sortedPartition = partition
            .OrderBy(p => p.PlateId.Value, GuidOrdering.Rfc4122Comparer)
            .ToArray();

        var output = new List<ReconstructableFeature>(features.Count);

        for (var i = 0; i < features.Count; i++)
        {
            var f = features[i];

            if (f.PlateIdProvenance.HasValue)
            {
                output.Add(f);
                continue;
            }

            if (!TryGetRepresentativePoint(f.Geometry, out var point))
            {
                output.Add(f);
                continue;
            }

            PlateId? assigned = null;
            for (var j = 0; j < sortedPartition.Length; j++)
            {
                var region = sortedPartition[j].Region;
                if (PolygonRegion2Ops.ContainsPoint(region, point))
                {
                    assigned = sortedPartition[j].PlateId;
                    break;
                }
            }

            output.Add(f with { PlateIdProvenance = assigned });
        }

        return output;
    }

    private static bool TryGetRepresentativePoint(IGeometry geometry, out Point2 point)
    {
        switch (geometry)
        {
            case Point2 p:
                point = p;
                return !p.IsEmpty;
            case Polyline2 line when line.Count > 0:
                point = line[0];
                return !point.IsEmpty;
            default:
                point = Point2.Empty;
                return false;
        }
    }

}


// --- PATH: plugins/Geosphere.Plate.Reconstruction.Solver/NaivePlateReconstructionSolver.cs ---
using Plate.TimeDete.Time.Primitives;
using FantaSim.Geosphere.Plate.Kinematics.Contracts.Derived;
using FantaSim.Geosphere.Plate.Reconstruction.Contracts;
using FantaSim.Geosphere.Plate.Reconstruction.Contracts.Output;
using FantaSim.Geosphere.Plate.Topology.Contracts.Derived;
using FantaSim.Geosphere.Plate.Topology.Contracts.Identity;
using FantaSim.Geosphere.Plate.Topology.Contracts.Numerics;
using UnifyGeometry;

namespace FantaSim.Geosphere.Plate.Reconstruction.Solver;

/// <summary>
/// Minimal reconstruction solver implementation for RFC-V2-0024.
/// </summary>
/// <remarks>
/// <para>
/// <b>Geometry rotation:</b> Applies quaternion rotation to all 3D geometry types
/// (Point3, Segment3, Polyline3). 2D geometry types are returned unchanged.
/// </para>
/// <para>
/// <b>Topology assumptions:</b> Expects topology slice boundaries at the target tick
/// (topology already time-cutoff materialized by caller). Retired boundaries are excluded.
/// </para>
/// <para>
/// <b>Provenance policy:</b> Attaches single-plate provenance (left plate) per boundary.
/// </para>
/// <para>
/// <b>Kinematics fallback policy:</b> If <c>kinematics.TryGetRotation()</c> returns false
/// for a given plate at the target tick, the solver uses <see cref="Quaterniond.Identity"/>
/// (no rotation). This means geometry is returned unchanged when kinematics data is missing.
/// This behavior is deterministic and suitable for Solver Lab verification.
/// </para>
/// <para>
/// <b>Determinism:</b> Output is ordered by BoundaryId/FeatureId using RFC4122 byte ordering
/// for reproducible results across runs.
/// </para>
/// </remarks>
public sealed class NaivePlateReconstructionSolver : IPlateReconstructionSolver, IPlateFeatureReconstructionSolver
{
    public IReadOnlyList<ReconstructedBoundary> ReconstructBoundaries(
        IPlateTopologyStateView topology,
        IPlateKinematicsStateView kinematics,
        CanonicalTick targetTick,
        ReconstructionOptions? options = null)
    {
        ArgumentNullException.ThrowIfNull(topology);
        ArgumentNullException.ThrowIfNull(kinematics);

        var boundaries = topology.Boundaries.Values
            .Where(b => !b.IsRetired)
            .OrderBy(b => b.BoundaryId.Value)
            .Select(b =>
            {
                var rotation = Quaterniond.Identity;
                if (kinematics.TryGetRotation(b.PlateIdLeft, targetTick, out var r))
                    rotation = r;

                var geometry = ApplyRotation(b.Geometry, rotation);

                return new ReconstructedBoundary(
                    b.BoundaryId,
                    b.PlateIdLeft,
                    geometry);
            })
            .ToArray();

        return boundaries;
    }

    public IReadOnlyList<ReconstructedFeature> ReconstructFeatures(
        IReadOnlyList<ReconstructableFeature> features,
        IPlateKinematicsStateView kinematics,
        CanonicalTick targetTick,
        ReconstructionOptions? options = null)
    {
        ArgumentNullException.ThrowIfNull(features);
        ArgumentNullException.ThrowIfNull(kinematics);

        var reconstructed = features
            .Where(f => f.PlateIdProvenance.HasValue)
            .OrderBy(f => f.FeatureId.Value, GuidOrdering.Rfc4122Comparer)
            .Select(f =>
            {
                var plateId = f.PlateIdProvenance!.Value;

                var rotation = Quaterniond.Identity;
                if (kinematics.TryGetRotation(plateId, targetTick, out var r))
                    rotation = r;

                var geometry = ApplyRotation(f.Geometry, rotation);

                return new ReconstructedFeature(
                    f.FeatureId,
                    plateId,
                    geometry);
            })
            .ToArray();

        return reconstructed;
    }

    private static IGeometry ApplyRotation(IGeometry geometry, Quaterniond rotation)
    {
        return geometry switch
        {
            Point3 point => Rotate(point, rotation),
            Segment3 segment => Rotate(segment, rotation),
            Polyline3 polyline => Rotate(polyline, rotation),
            _ => geometry
        };
    }

    private static Point3 Rotate(Point3 point, Quaterniond rotation)
    {
        if (point.IsEmpty)
            return point;

        var v = RotateVector(new Vector3d(point.X, point.Y, point.Z), rotation);
        return new Point3(v.X, v.Y, v.Z);
    }

    private static Segment3 Rotate(Segment3 segment, Quaterniond rotation)
    {
        if (segment.IsEmpty)
            return segment;

        return new Segment3(Rotate(segment.Start, rotation), Rotate(segment.End, rotation));
    }

    private static Polyline3 Rotate(Polyline3 polyline, Quaterniond rotation)
    {
        if (polyline.IsEmpty)
            return polyline;

        var points = new Point3[polyline.PointCount];
        for (var i = 0; i < points.Length; i++)
        {
            points[i] = Rotate(polyline[i], rotation);
        }

        return new Polyline3(points);
    }

    private static Vector3d RotateVector(Vector3d vector, Quaterniond rotation)
    {
        var v = new Quaterniond(vector.X, vector.Y, vector.Z, 0d);
        var inv = rotation.Inverse();
        var rotated = Quaterniond.Multiply(Quaterniond.Multiply(rotation, v), inv);
        return new Vector3d(rotated.X, rotated.Y, rotated.Z);
    }
}


// --- PATH: plugins/Geosphere.Plate.Runtime.Des/Core/DesWorkKind.cs ---
namespace FantaSim.Geosphere.Plate.Runtime.Des.Core;

public enum DesWorkKind : int
{
    // Reserved 0-99
    Undefined = 0,

    // Geosphere 100-199
    RunPlateSolver = 100,
    EmitBoundaryGeometryUpdate = 101,

    // Expansion...
}


// --- PATH: plugins/Geosphere.Plate.Runtime.Des/Core/ScheduledWorkItem.cs ---
using FantaSim.World.Contracts.Time;
using Plate.TimeDete.Time.Primitives;

namespace FantaSim.Geosphere.Plate.Runtime.Des.Core;

public readonly record struct ScheduledWorkItem(
    CanonicalTick When,
    SphereId Sphere,
    DesWorkKind Kind,
    ulong TieBreak,
    object? Payload = null
) : IComparable<ScheduledWorkItem>
{
    public int CompareTo(ScheduledWorkItem other)
    {
        // 1. When (ascending)
        int tickComparison = When.CompareTo(other.When);
        if (tickComparison != 0) return tickComparison;

        // 2. Sphere (ascending by fixed enum numeric order)
        int sphereComparison = GetSpherePriority(Sphere).CompareTo(GetSpherePriority(other.Sphere));
        if (sphereComparison != 0) return sphereComparison;

        // 3. Kind (ascending)
        int kindComparison = Kind.CompareTo(other.Kind);
        if (kindComparison != 0) return kindComparison;

        // 4. TieBreak (ascending)
        return TieBreak.CompareTo(other.TieBreak);
    }

    private static int GetSpherePriority(SphereId sphere)
    {
        // RFC-V2-0014: Geosphere -> Others
        if (sphere == SphereIds.Geosphere) return 100;
        if (sphere == SphereIds.Biosphere) return 200;
        if (sphere == SphereIds.Noosphere) return 300;

        // Default / Unknown
        return 999;
    }
}


// --- PATH: plugins/Geosphere.Plate.Runtime.Des/DesRuntimeFactory.cs ---
﻿using System;
using FantaSim.Geosphere.Plate.Runtime.Des.Core;
using FantaSim.Geosphere.Plate.Runtime.Des.Drivers;
using FantaSim.Geosphere.Plate.Runtime.Des.Events;
using FantaSim.Geosphere.Plate.Runtime.Des.Runtime;
using FantaSim.Geosphere.Plate.Topology.Contracts.Determinism;
using FantaSim.Geosphere.Plate.Topology.Contracts.Events;
using FantaSim.Geosphere.Plate.Topology.Contracts.Identity;
using FantaSim.Geosphere.Plate.Topology.Materializer;

namespace FantaSim.Geosphere.Plate.Runtime.Des;

public sealed class DesRuntimeFactory : IDesRuntimeFactory
{
    private readonly ITopologyEventStore _eventStore;
    private readonly PlateTopologyTimeline _timeline;
    private readonly ISolverSeedProvider _seedProvider;

    public DesRuntimeFactory(
        ITopologyEventStore eventStore,
        PlateTopologyTimeline timeline,
        ISolverSeedProvider seedProvider)
    {
        _eventStore = eventStore ?? throw new ArgumentNullException(nameof(eventStore));
        _timeline = timeline ?? throw new ArgumentNullException(nameof(timeline));
        _seedProvider = seedProvider ?? throw new ArgumentNullException(nameof(seedProvider));
    }

    public IDesRuntime Create(TruthStreamIdentity streamIdentity)
    {
        // 1. Core Components
        var queue = new PriorityQueueDesQueue();
        var appender = new PlateTopologyEventAppender(_eventStore);
        var scheduler = new DesScheduler(queue);

        // 2. Dispatcher & Handlers
        var dispatcher = new StandardDesDispatcher();

        // Register MVP Geosphere Handlers
        var driver = new GeospherePlateDriver();
        var trigger = new GeospherePlateTrigger(streamIdentity); // Injects stream identity

        dispatcher.Register(DesWorkKind.RunPlateSolver, driver, trigger);

        // 3. Runtime with deterministic seed provider for reproducible event IDs
        return new DesRuntime(queue, appender, _timeline, dispatcher, _seedProvider);
    }
}


// --- PATH: plugins/Geosphere.Plate.Runtime.Des/Drivers/GeospherePlateDriver.cs ---
using System.Threading;
using System.Threading.Tasks;
using FantaSim.World.Contracts.Time;
using FantaSim.Geosphere.Plate.Runtime.Des.Core;
using FantaSim.Geosphere.Plate.Runtime.Des.Runtime;
using Plate.TimeDete.Time.Primitives;
using FantaSim.Geosphere.Plate.Topology.Materializer;

namespace FantaSim.Geosphere.Plate.Runtime.Des.Drivers;

public sealed class GeospherePlateDriver : IDriver
{
    public DriverId Id => new("GeospherePlateDriver");
    public SphereId Sphere => SphereIds.Geosphere;

    public Task<DriverOutput> EvaluateAsync(DesContext context, CancellationToken ct = default)
    {
        // 1. Read state
        var plateCount = context.State.Plates.Count;
        object? signal = null;

        if (plateCount == 0)
        {
            // Genesis logic: Create initial plate
            signal = "Genesis";
        }
        else
        {
            // Normal simulation step
            // For MVP, just log or no-op
            signal = "Step";
        }

        // 2. Schedule next step
        // Schedule RunPlateSolver 10 ticks later
        // Note: In strict DES, we might only schedule if there's active work.
        // For this MVP, we keep the heartbeat alive.
        var nextTick = context.CurrentTick + 10;

        // Scheduler assigns monotonic TieBreak automatically for deterministic ordering
        context.Scheduler.Schedule(nextTick, SphereIds.Geosphere, DesWorkKind.RunPlateSolver);

        return Task.FromResult(new DriverOutput(signal));
    }
}


// --- PATH: plugins/Geosphere.Plate.Runtime.Des/Drivers/GeospherePlateTrigger.cs ---
﻿using System;
using System.Collections.Generic;
using FantaSim.World.Contracts.Time;
using FantaSim.Geosphere.Plate.Runtime.Des.Events;
using FantaSim.Geosphere.Plate.Topology.Contracts.Events;
using FantaSim.Geosphere.Plate.Topology.Contracts.Entities;
using Plate.TimeDete.Determinism.Abstractions;
using Plate.TimeDete.Time.Primitives;
using FantaSim.Geosphere.Plate.Topology.Contracts.Identity;

namespace FantaSim.Geosphere.Plate.Runtime.Des.Drivers;

public sealed class GeospherePlateTrigger : ITrigger
{
    private readonly TruthStreamIdentity _streamIdentity;

    public GeospherePlateTrigger(TruthStreamIdentity streamIdentity)
    {
        _streamIdentity = streamIdentity;
    }

    public TriggerId Id => new("GeospherePlateTrigger");

    public IReadOnlyList<ITruthEventDraft> EmitDrafts(DriverOutput output, CanonicalTick tick, ISeededRng rng)
    {
        if (output.Signal is string s && s == "Genesis")
        {
            // Emit PlateCreatedEvent for Plate "P:0" (using deterministic UUID)
            var plateId = new PlateId(Guid.Parse("00000000-0000-0000-0000-000000000001"));

            // Generate deterministic event ID from seeded RNG for reproducibility
            var eventId = EventId.NewId(rng);

            var draft = new GenericTruthEventDraft(
                tick,
                _streamIdentity,
                (seq) => new PlateCreatedEvent(
                    eventId.Value,
                    plateId,
                    tick,
                    seq,
                    _streamIdentity,
                    ReadOnlyMemory<byte>.Empty, // Filled by store
                    ReadOnlyMemory<byte>.Empty  // Filled by store
                )
            );

            return new[] { draft };
        }

        return Array.Empty<ITruthEventDraft>();
    }
}


// --- PATH: plugins/Geosphere.Plate.Runtime.Des/Drivers/IDriver.cs ---
using System.Threading;
using System.Threading.Tasks;
using FantaSim.World.Contracts.Time;
using FantaSim.Geosphere.Plate.Runtime.Des.Runtime;

namespace FantaSim.Geosphere.Plate.Runtime.Des.Drivers;

public readonly record struct DriverId(string Value);

public record DriverOutput(
    object? Signal // Opaque for now
);

public interface IDriver
{
    DriverId Id { get; }
    SphereId Sphere { get; }

    // Called at a scheduled tick with a read-only view of state.
    Task<DriverOutput> EvaluateAsync(
        DesContext context,
        CancellationToken ct = default);
}


// --- PATH: plugins/Geosphere.Plate.Runtime.Des/Drivers/ITrigger.cs ---
﻿using System.Collections.Generic;
using FantaSim.Geosphere.Plate.Runtime.Des.Events;
using Plate.TimeDete.Determinism.Abstractions;
using Plate.TimeDete.Time.Primitives;

namespace FantaSim.Geosphere.Plate.Runtime.Des.Drivers;

public readonly record struct TriggerId(string Value);

public interface ITrigger
{
    TriggerId Id { get; }

    /// <summary>
    /// Returns 0..n truth event drafts for this tick.
    /// </summary>
    /// <param name="output">The driver output containing any signal data.</param>
    /// <param name="tick">The current canonical tick.</param>
    /// <param name="rng">Seeded RNG for deterministic ID generation. Callers MUST provide
    /// a tick-scoped RNG instance to ensure reproducibility.</param>
    /// <returns>A collection of truth event drafts to be committed.</returns>
    IReadOnlyList<ITruthEventDraft> EmitDrafts(DriverOutput output, CanonicalTick tick, ISeededRng rng);
}


// --- PATH: plugins/Geosphere.Plate.Runtime.Des/Events/GenericTruthEventDraft.cs ---
using System;
using FantaSim.Geosphere.Plate.Topology.Contracts.Events;
using FantaSim.Geosphere.Plate.Topology.Contracts.Identity;
using Plate.TimeDete.Time.Primitives;

namespace FantaSim.Geosphere.Plate.Runtime.Des.Events;

public class GenericTruthEventDraft : ITruthEventDraft
{
    private readonly Func<long, IPlateTopologyEvent> _factory;

    public GenericTruthEventDraft(
        CanonicalTick tick,
        TruthStreamIdentity stream,
        Func<long, IPlateTopologyEvent> factory)
    {
        Tick = tick;
        Stream = stream;
        _factory = factory ?? throw new ArgumentNullException(nameof(factory));
    }

    public CanonicalTick Tick { get; }
    public TruthStreamIdentity Stream { get; }

    public IPlateTopologyEvent ToTruthEvent(long sequence)
    {
        return _factory(sequence);
    }
}


// --- PATH: plugins/Geosphere.Plate.Runtime.Des/Events/ITruthEventAppender.cs ---
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;

namespace FantaSim.Geosphere.Plate.Runtime.Des.Events;

public record AppendDraftsResult(
    long LastSequence,
    ReadOnlyMemory<byte> LastHash
);

public record AppendOptions(
    bool EnforceMonotonicity = true
);

public interface ITruthEventAppender
{
    Task<AppendDraftsResult> AppendAsync(
        IReadOnlyList<ITruthEventDraft> drafts,
        AppendOptions options,
        CancellationToken ct = default);
}


// --- PATH: plugins/Geosphere.Plate.Runtime.Des/Events/ITruthEventDraft.cs ---
using FantaSim.Geosphere.Plate.Topology.Contracts.Identity;
using FantaSim.Geosphere.Plate.Topology.Contracts.Events;
using Plate.TimeDete.Time.Primitives;

namespace FantaSim.Geosphere.Plate.Runtime.Des.Events;

public interface ITruthEventDraft
{
    CanonicalTick Tick { get; }
    TruthStreamIdentity Stream { get; }

    // Converts to a concrete truth event type (e.g., PlateCreatedEvent).
    // Must NOT set Hash/PreviousHash; store will do that.
    // The sequence is assigned by the appender.
    IPlateTopologyEvent ToTruthEvent(long sequence);
}


// --- PATH: plugins/Geosphere.Plate.Runtime.Des/Events/PlateTopologyEventAppender.cs ---
﻿using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using FantaSim.Geosphere.Plate.Topology.Contracts.Events;
using FantaSim.Geosphere.Plate.Topology.Contracts.Identity;

namespace FantaSim.Geosphere.Plate.Runtime.Des.Events;

/// <summary>
/// Appends truth events to the topology event store with optimistic concurrency control.
///
/// Design rationale (RFC-V2-0005 review):
/// - Uses <see cref="ITopologyEventStore.GetHeadAsync"/> to get current head state
/// - Passes <see cref="HeadPrecondition"/> to guard against concurrent writes
/// - Per-stream locking in the store ensures in-process atomicity
/// - <see cref="ConcurrencyConflictException"/> enables retry logic if needed
/// </summary>
public sealed class PlateTopologyEventAppender : ITruthEventAppender
{
    private readonly ITopologyEventStore _store;

    public PlateTopologyEventAppender(ITopologyEventStore store)
    {
        _store = store ?? throw new ArgumentNullException(nameof(store));
    }

    public async Task<AppendDraftsResult> AppendAsync(
        IReadOnlyList<ITruthEventDraft> drafts,
        AppendOptions options,
        CancellationToken ct = default)
    {
        if (drafts.Count == 0)
        {
            // If empty, we should ideally return the current head.
            // But we don't know the stream identity if drafts is empty!
            // The drafts list carries the stream identity.
            // If the list is empty, we can't determine the stream.
            // Assuming this is a no-op that returns default/empty result.
            return new AppendDraftsResult(0, ReadOnlyMemory<byte>.Empty);
        }

        var stream = drafts[0].Stream;

        // 1. Get the current head state (sequence + hash) for optimistic concurrency
        var head = await _store.GetHeadAsync(stream, ct).ConfigureAwait(false);
        long nextSeq = head.Sequence + 1;

        var eventsToAppend = new List<IPlateTopologyEvent>(drafts.Count);

        foreach (var draft in drafts)
        {
            if (draft.Stream != stream)
            {
                 throw new ArgumentException("All drafts must belong to the same stream", nameof(drafts));
            }
            eventsToAppend.Add(draft.ToTruthEvent(nextSeq++));
        }

        // 2. Append to store with optimistic concurrency precondition
        var storeOptions = new FantaSim.Geosphere.Plate.Topology.Contracts.Events.AppendOptions
        {
            TickPolicy = options.EnforceMonotonicity
                ? TickMonotonicityPolicy.Reject
                : TickMonotonicityPolicy.Allow,
            ExpectedHead = head.ToPrecondition()
        };

        await _store.AppendAsync(stream, eventsToAppend, storeOptions, ct).ConfigureAwait(false);

        // 3. Return result from the last appended event
        // The store computes the hash but doesn't return it directly.
        // We can either:
        // a) Read back the event (current approach, slight overhead)
        // b) Have the store return the computed hash (would require API change)
        //
        // Using GetHeadAsync is more efficient than reading the full event:
        var newHead = await _store.GetHeadAsync(stream, ct).ConfigureAwait(false);

        return new AppendDraftsResult(newHead.Sequence, newHead.Hash);
    }
}


// --- PATH: plugins/Geosphere.Plate.Runtime.Des/Extensions/ServiceCollectionExtensions.cs ---
using Microsoft.Extensions.DependencyInjection;
using FantaSim.Geosphere.Plate.Runtime.Des.Core;
using FantaSim.Geosphere.Plate.Runtime.Des.Drivers;
using FantaSim.Geosphere.Plate.Runtime.Des.Events;
using FantaSim.Geosphere.Plate.Runtime.Des.Runtime;

namespace FantaSim.Geosphere.Plate.Runtime.Des.Extensions;

public static class DesRuntimeServiceCollectionExtensions
{
    public static IServiceCollection AddDesRuntime(this IServiceCollection services)
    {
        // Core Runtime Components
        services.AddScoped<IDesRuntime, DesRuntime>();
        services.AddScoped<IDesQueue, PriorityQueueDesQueue>();
        services.AddScoped<IDesScheduler, DesScheduler>();
        services.AddScoped<ITruthEventAppender, PlateTopologyEventAppender>();

        // Dispatcher
        services.AddScoped<StandardDesDispatcher>();
        services.AddScoped<IDesDispatcher>(sp =>
        {
            var dispatcher = sp.GetRequiredService<StandardDesDispatcher>();

            // Register MVP Geosphere Handlers
            var driver = sp.GetRequiredService<GeospherePlateDriver>();
            var trigger = sp.GetRequiredService<GeospherePlateTrigger>();

            dispatcher.Register(DesWorkKind.RunPlateSolver, driver, trigger);

            return dispatcher;
        });

        // MVP Drivers & Triggers
        services.AddScoped<GeospherePlateDriver>();
        services.AddScoped<GeospherePlateTrigger>();

        return services;
    }
}


// --- PATH: plugins/Geosphere.Plate.Runtime.Des/GeosphereDesPlugin.cs ---
﻿using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using FantaSim.Geosphere.Plate.Runtime.Des.Extensions;
using FantaSim.Geosphere.Plate.Topology.Contracts.Determinism;
using Microsoft.Extensions.DependencyInjection;
using PluginArchi.Extensibility.Abstractions;
using ServiceArchi.Contracts;

namespace FantaSim.Geosphere.Plate.Runtime.Des;

/// <summary>
/// Plugin entry point for the Geosphere DES Runtime.
/// </summary>
[Plugin("fantasim.geosphere.plate.runtime.des", Name = "Geosphere DES Runtime", Tags = "geosphere,des,runtime,sim")]
public sealed class GeosphereDesPlugin : ILifecyclePlugin
{
    private IRegistry? _registry;
    private IDesRuntimeFactory? _factory;

    public IPluginDescriptor Descriptor { get; } = new PluginDescriptor
    {
        Id = "fantasim.geosphere.plate.runtime.des",
        Name = "Geosphere DES Runtime",
        Description = "Discrete Event Simulation runtime for Geosphere Plate Tectonics.",
        Tags = new[] { "geosphere", "des", "runtime", "sim" },
        Version = new Version(1, 0, 0)
    };

    public ValueTask InitializeAsync(IPluginContext context, CancellationToken ct = default)
    {
        // 1. Resolve the ServiceArchi Registry from the host context
        var registry = context.Services.GetService<IRegistry>();
        if (registry == null)
        {
            return ValueTask.CompletedTask;
        }

        _registry = registry;

        // 2. Resolve dependencies required for our factory
        var eventStore = context.Services.GetService<FantaSim.Geosphere.Plate.Topology.Contracts.Events.ITopologyEventStore>();
        var timeline = context.Services.GetService<FantaSim.Geosphere.Plate.Topology.Materializer.PlateTopologyTimeline>();
        var seedProvider = context.Services.GetService<ISolverSeedProvider>();

        if (eventStore != null && timeline != null && seedProvider != null)
        {
            // 3. Create and register the DesRuntimeFactory with deterministic seed provider
            _factory = new DesRuntimeFactory(eventStore, timeline, seedProvider);

            // Register as the singleton factory
            registry.Register<IDesRuntimeFactory>(_factory);
        }

        return ValueTask.CompletedTask;
    }

    public ValueTask ShutdownAsync(CancellationToken ct = default)
    {
        _registry?.UnregisterAll<IDesRuntimeFactory>();
        _factory = null;
        _registry = null;
        return ValueTask.CompletedTask;
    }
}


// --- PATH: plugins/Geosphere.Plate.Runtime.Des/Runtime/DesContext.cs ---
﻿using FantaSim.Geosphere.Plate.Topology.Contracts.Identity;
using FantaSim.Geosphere.Plate.Topology.Materializer;
using Plate.TimeDete.Determinism.Abstractions;
using Plate.TimeDete.Time.Primitives;

namespace FantaSim.Geosphere.Plate.Runtime.Des.Runtime;

public sealed class DesContext
{
    public required TruthStreamIdentity Stream { get; init; }
    public required CanonicalTick CurrentTick { get; init; }

    // Read-only world access
    public required IPlateTopologyIndexedStateView State { get; init; }

    // Helper hooks
    public required IDesScheduler Scheduler { get; init; }

    /// <summary>
    /// Tick-scoped seeded RNG for deterministic ID generation.
    /// Each tick MUST receive a fresh RNG instance derived from the scenario seed
    /// and stream identity to ensure reproducibility across runs.
    /// </summary>
    public required ISeededRng Rng { get; init; }
}


// --- PATH: plugins/Geosphere.Plate.Runtime.Des/Runtime/DesRuntime.cs ---
﻿using System;
using System.Threading;
using System.Threading.Tasks;
using FantaSim.Geosphere.Plate.Runtime.Des.Events;
using FantaSim.Geosphere.Plate.Runtime.Des.Core;
using FantaSim.Geosphere.Plate.Topology.Materializer;
using FantaSim.Geosphere.Plate.Topology.Contracts.Identity;
using FantaSim.Geosphere.Plate.Topology.Contracts.Determinism;
using Plate.TimeDete.Time.Primitives;
using FantaSim.Geosphere.Plate.Topology.Contracts.Capabilities; // Added for TickMaterializationMode

namespace FantaSim.Geosphere.Plate.Runtime.Des.Runtime;

public sealed class DesRuntime : IDesRuntime
{
    private readonly IDesQueue _queue;
    private readonly ITruthEventAppender _appender;
    private readonly PlateTopologyTimeline _timeline;
    private readonly IDesDispatcher _dispatcher;
    private readonly IDesScheduler _scheduler;
    private readonly ISolverSeedProvider _seedProvider;

    public DesRuntime(
        IDesQueue queue,
        ITruthEventAppender appender,
        PlateTopologyTimeline timeline,
        IDesDispatcher dispatcher,
        ISolverSeedProvider seedProvider)
    {
        _queue = queue ?? throw new ArgumentNullException(nameof(queue));
        _appender = appender ?? throw new ArgumentNullException(nameof(appender));
        _timeline = timeline ?? throw new ArgumentNullException(nameof(timeline));
        _dispatcher = dispatcher ?? throw new ArgumentNullException(nameof(dispatcher));
        _seedProvider = seedProvider ?? throw new ArgumentNullException(nameof(seedProvider));
        _scheduler = new DesScheduler(_queue);
    }

    public async Task<DesRunResult> RunAsync(
        TruthStreamIdentity stream,
        DesRunOptions options,
        CancellationToken ct = default)
    {
        int itemsProcessed = 0;
        int eventsAppended = 0;

        while (itemsProcessed < options.MaxItemsProcessed && eventsAppended < options.MaxEventsAppended)
        {
            ct.ThrowIfCancellationRequested();

            if (!_queue.TryPeek(out var nextItem))
            {
                break; // Queue empty
            }

            // Check start tick (skip if earlier, though queue should be ordered)
            if (nextItem.When < options.StartTick)
            {
                // This shouldn't happen if queue was initialized correctly,
                // but if it does, we just dequeue and ignore?
                // Or we process it anyway?
                // RFC says "advance simulation time".
                // If we are resuming, we assume queue items are valid pending work.
                // Let's assume we process everything in queue.
                // BUT, options.StartTick might define where we *start* processing.
                // If item is before StartTick, maybe it's stale?
                // For now, let's assume we process it.
            }

            // Check end tick
            if (options.EndTick.HasValue && nextItem.When > options.EndTick.Value)
            {
                // Reached time limit
                break;
            }

            // Dequeue
            _queue.TryDequeue(out var item); // Should match peek

            // Materialize state (ReadOnly)
            // RFC says: state = MaterializeAtTick(currentTick)
            // We use the timeline facade.
            // Note: TickMaterializationMode is passed in options?
            // DesRunOptions doesn't have TickMode in my previous definition?
            // Let me check DesRunOptions.
            // I defined it as: record DesRunOptions(CanonicalTick StartTick, CanonicalTick? EndTick, int MaxItemsProcessed, int MaxEventsAppended);
            // I should have added TickMaterializationMode?
            // RFC says "TickMaterializationMode TickMode" in DesRunOptions.
            // I'll assume Auto for now or update DesRunOptions.
            // Let's assume Auto.

            var slice = await _timeline.GetSliceAtTickAsync(stream, item.When, TickMaterializationMode.Auto, ct).ConfigureAwait(false);

            // Create tick-scoped RNG for deterministic event ID generation
            var tickRng = _seedProvider.CreateRngForTick(options.ScenarioSeed, stream, item.When);

            var context = new DesContext
            {
                Stream = stream,
                CurrentTick = item.When,
                State = slice.State,
                Scheduler = _scheduler,
                Rng = tickRng
            };

            // Dispatch
            var drafts = await _dispatcher.DispatchAsync(item, context, ct).ConfigureAwait(false);

            // Append drafts
            if (drafts.Count > 0)
            {
                var appendResult = await _appender.AppendAsync(drafts, new AppendOptions { EnforceMonotonicity = true }, ct).ConfigureAwait(false);
                eventsAppended += drafts.Count;
            }

            itemsProcessed++;
        }

        return new DesRunResult(itemsProcessed, eventsAppended);
    }
}


// --- PATH: plugins/Geosphere.Plate.Runtime.Des/Runtime/DesScheduler.cs ---
using FantaSim.Geosphere.Plate.Runtime.Des.Core;
using FantaSim.World.Contracts.Time;
using Plate.TimeDete.Time.Primitives;

namespace FantaSim.Geosphere.Plate.Runtime.Des.Runtime;

/// <summary>
/// DES scheduler that assigns monotonically increasing TieBreak values
/// to ensure deterministic ordering of work items.
/// </summary>
/// <remarks>
/// The TieBreak counter is global across all (When, Sphere, Kind) tuples.
/// This guarantees that items scheduled in a specific order will always
/// be processed in that same order, even if they share the same key tuple.
/// </remarks>
public sealed class DesScheduler : IDesScheduler
{
    private readonly IDesQueue _queue;
    private ulong _tieBreakCounter;

    public DesScheduler(IDesQueue queue)
    {
        _queue = queue ?? throw new ArgumentNullException(nameof(queue));
        _tieBreakCounter = 0;
    }

    /// <inheritdoc />
    public void Schedule(CanonicalTick when, SphereId sphere, DesWorkKind kind, object? payload = null)
    {
        // Assign monotonically increasing TieBreak for deterministic ordering
        var tieBreak = _tieBreakCounter++;

        var item = new ScheduledWorkItem(when, sphere, kind, tieBreak, payload);
        _queue.Enqueue(item);
    }
}


// --- PATH: plugins/Geosphere.Plate.Runtime.Des/Runtime/IDesDispatcher.cs ---
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using FantaSim.Geosphere.Plate.Runtime.Des.Core;
using FantaSim.Geosphere.Plate.Runtime.Des.Events;

namespace FantaSim.Geosphere.Plate.Runtime.Des.Runtime;

public interface IDesDispatcher
{
    Task<IReadOnlyList<ITruthEventDraft>> DispatchAsync(
        ScheduledWorkItem item,
        DesContext context,
        CancellationToken ct);
}


// --- PATH: plugins/Geosphere.Plate.Runtime.Des/Runtime/IDesQueue.cs ---
using FantaSim.Geosphere.Plate.Runtime.Des.Core;

namespace FantaSim.Geosphere.Plate.Runtime.Des.Runtime;

public interface IDesQueue
{
    void Enqueue(ScheduledWorkItem item);
    bool TryDequeue(out ScheduledWorkItem item);
    int Count { get; }
    bool TryPeek(out ScheduledWorkItem item);
}


// --- PATH: plugins/Geosphere.Plate.Runtime.Des/Runtime/IDesScheduler.cs ---
using FantaSim.Geosphere.Plate.Runtime.Des.Core;
using FantaSim.World.Contracts.Time;
using Plate.TimeDete.Time.Primitives;

namespace FantaSim.Geosphere.Plate.Runtime.Des.Runtime;

/// <summary>
/// Scheduler interface for the DES runtime.
/// </summary>
/// <remarks>
/// The scheduler is responsible for assigning monotonically increasing TieBreak values
/// to ensure deterministic ordering when multiple work items share the same
/// (When, Sphere, Kind) tuple. Callers should NOT provide TieBreak values directly.
/// </remarks>
public interface IDesScheduler
{
    /// <summary>
    /// Schedules a work item for execution at the specified tick.
    /// The scheduler assigns a deterministic TieBreak value automatically.
    /// </summary>
    /// <param name="when">The tick at which to execute the work.</param>
    /// <param name="sphere">The sphere responsible for this work.</param>
    /// <param name="kind">The type of work to perform.</param>
    /// <param name="payload">Optional payload data for the work item.</param>
    void Schedule(CanonicalTick when, SphereId sphere, DesWorkKind kind, object? payload = null);
}


// --- PATH: plugins/Geosphere.Plate.Runtime.Des/Runtime/PriorityQueueDesQueue.cs ---
using System.Collections.Generic;
using FantaSim.Geosphere.Plate.Runtime.Des.Core;

namespace FantaSim.Geosphere.Plate.Runtime.Des.Runtime;

public sealed class PriorityQueueDesQueue : IDesQueue
{
    private readonly PriorityQueue<ScheduledWorkItem, ScheduledWorkItem> _queue;

    public PriorityQueueDesQueue()
    {
        // ScheduledWorkItem implements IComparable<ScheduledWorkItem>
        // using the canonical ordering key defined in RFC-V2-0012
        _queue = new PriorityQueue<ScheduledWorkItem, ScheduledWorkItem>(Comparer<ScheduledWorkItem>.Default);
    }

    public int Count => _queue.Count;

    public void Enqueue(ScheduledWorkItem item)
    {
        _queue.Enqueue(item, item);
    }

    public bool TryDequeue(out ScheduledWorkItem item)
    {
        return _queue.TryDequeue(out item, out _);
    }

    public bool TryPeek(out ScheduledWorkItem item)
    {
        return _queue.TryPeek(out item, out _);
    }
}


// --- PATH: plugins/Geosphere.Plate.Runtime.Des/Runtime/StandardDesDispatcher.cs ---
﻿using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using FantaSim.Geosphere.Plate.Runtime.Des.Core;
using FantaSim.Geosphere.Plate.Runtime.Des.Drivers;
using FantaSim.Geosphere.Plate.Runtime.Des.Events;

namespace FantaSim.Geosphere.Plate.Runtime.Des.Runtime;

public sealed class StandardDesDispatcher : IDesDispatcher
{
    private readonly Dictionary<DesWorkKind, (IDriver Driver, ITrigger Trigger)> _registry = new();

    public void Register(DesWorkKind kind, IDriver driver, ITrigger trigger)
    {
        _registry[kind] = (driver, trigger);
    }

    public async Task<IReadOnlyList<ITruthEventDraft>> DispatchAsync(
        ScheduledWorkItem item,
        DesContext context,
        CancellationToken ct)
    {
        if (!_registry.TryGetValue(item.Kind, out var handler))
        {
            throw new InvalidOperationException($"No handler registered for DesWorkKind {item.Kind}");
        }

        var (driver, trigger) = handler;

        // In a real system we might validate driver.Sphere == item.Sphere

        var output = await driver.EvaluateAsync(context, ct).ConfigureAwait(false);

        // Pass tick-scoped RNG from context for deterministic ID generation
        return trigger.EmitDrafts(output, context.CurrentTick, context.Rng);
    }
}


// --- PATH: plugins/Geosphere.Plate.Topology.Materializer/CachedPlateTopologyMaterializer.cs ---
using System.Collections.Concurrent;
using Plate.TimeDete.Time.Primitives;
using FantaSim.Geosphere.Plate.Topology.Contracts.Capabilities;
using FantaSim.Geosphere.Plate.Topology.Contracts.Derived;
using FantaSim.Geosphere.Plate.Topology.Contracts.Events;
using FantaSim.Geosphere.Plate.Topology.Contracts.Identity;

namespace FantaSim.Geosphere.Plate.Topology.Materializer;

/// <summary>
/// A caching wrapper around PlateTopologyMaterializer.
///
/// Caches materialized states by (stream, tick, lastSequence) key to avoid redundant replays.
/// </summary>
/// <remarks>
/// <para>
/// <b>Cache key includes last sequence number</b> to handle back-in-time events correctly.
/// If an event is later appended with tick <= targetTick, the cache entry becomes invalid
/// because the sequence number will have increased. This ensures correctness while still
/// providing cache hits when the event stream is unchanged.
/// </para>
/// </remarks>
public sealed class CachedPlateTopologyMaterializer
{
    private readonly ITopologyEventStore _store;
    private readonly PlateTopologyMaterializer _inner;
    private readonly ConcurrentDictionary<PlateTopologyMaterializationKey, PlateTopologyState> _cache = new();

    public CachedPlateTopologyMaterializer(ITopologyEventStore store)
    {
        ArgumentNullException.ThrowIfNull(store);
        _store = store;
        _inner = new PlateTopologyMaterializer(store);
    }

    /// <summary>
    /// Materializes topology state at a specific tick, using cache if available.
    /// </summary>
    /// <param name="stream">The truth stream identity.</param>
    /// <param name="targetTick">The target simulation tick.</param>
    /// <param name="mode">Tick materialization mode (default: Auto).</param>
    /// <param name="cancellationToken">Cancellation token.</param>
    /// <returns>The materialization result with cache hit indicator.</returns>
    public async Task<MaterializationResult> MaterializeAtTickAsync(
        TruthStreamIdentity stream,
        CanonicalTick targetTick,
        TickMaterializationMode mode = TickMaterializationMode.Auto,
        CancellationToken cancellationToken = default)
    {
        ArgumentNullException.ThrowIfNull(stream);

        // Query last sequence to include in cache key (correctness for back-in-time events)
        var lastSeq = await GetLastSequenceAsync(stream, cancellationToken).ConfigureAwait(false);
        var key = new PlateTopologyMaterializationKey(stream, targetTick.Value, lastSeq);

        if (_cache.TryGetValue(key, out var cached))
        {
            return new MaterializationResult(key, cached, true);
        }

        var state = await _inner.MaterializeAtTickAsync(stream, targetTick, mode, cancellationToken).ConfigureAwait(false);
        _cache.TryAdd(key, state);
        return new MaterializationResult(key, state, false);
    }


    /// <summary>
    /// Materializes topology state at a specific sequence, using cache if available.
    /// </summary>
    /// <param name="stream">The truth stream identity.</param>
    /// <param name="targetSequence">The target sequence number.</param>
    /// <param name="cancellationToken">Cancellation token.</param>
    /// <returns>The materialization result with cache hit indicator.</returns>
    public async Task<MaterializationResult> MaterializeAtSequenceAsync(
        TruthStreamIdentity stream,
        long targetSequence,
        CancellationToken cancellationToken = default)
    {
        ArgumentNullException.ThrowIfNull(stream);

        // Query last sequence to include in cache key
        var lastSeq = await GetLastSequenceAsync(stream, cancellationToken).ConfigureAwait(false);

        // Use sequence as the tick component for cache key (sequence-based queries)
        var key = new PlateTopologyMaterializationKey(stream, targetSequence, lastSeq);
        if (_cache.TryGetValue(key, out var cached))
        {
            return new MaterializationResult(key, cached, true);
        }

        var state = await _inner.MaterializeAtSequenceAsync(stream, targetSequence, cancellationToken).ConfigureAwait(false);
        _cache.TryAdd(key, state);
        return new MaterializationResult(key, state, false);
    }

    /// <summary>
    /// [OBSOLETE] Use MaterializeAtTickAsync(stream, CanonicalTick) or MaterializeAtSequenceAsync instead.
    /// </summary>
    [Obsolete("Use MaterializeAtTickAsync(stream, CanonicalTick) or MaterializeAtSequenceAsync instead.")]
    public Task<MaterializationResult> MaterializeAtTickAsync(
        TruthStreamIdentity stream,
        long tick,
        CancellationToken cancellationToken = default)
    {
        // Old behavior was sequence-based
        return MaterializeAtSequenceAsync(stream, tick, cancellationToken);
    }

    public void Clear() => _cache.Clear();

    /// <summary>
    /// Gets the last sequence number for a stream, or -1 if stream is empty.
    /// </summary>
    /// <remarks>
    /// Uses <see cref="ITopologyEventStore.GetLastSequenceAsync"/> when available,
    /// returning -1 for empty/non-existent streams to ensure consistent cache keys.
    /// </remarks>
    private async Task<long> GetLastSequenceAsync(
        TruthStreamIdentity stream,
        CancellationToken cancellationToken)
    {
        var lastSeq = await _store.GetLastSequenceAsync(stream, cancellationToken).ConfigureAwait(false);
        return lastSeq ?? -1L;
    }

    public readonly record struct MaterializationResult(
        PlateTopologyMaterializationKey Key,
        PlateTopologyState State,
        bool FromCache);
}


// --- PATH: plugins/Geosphere.Plate.Topology.Materializer/DiagnosticSwitches.cs ---
using System.Diagnostics;

namespace FantaSim.Geosphere.Plate.Topology.Materializer;

/// <summary>
/// Diagnostic trace switches for FantaSim.Geosphere.Plate.Topology.Materializer.
///
/// Enable these switches via app.config, environment variables, or code:
/// <code>
/// // Via code (useful for tests)
/// DiagnosticSwitches.MaterializationOptimization.Level = TraceLevel.Info;
///
/// // Via environment variable
/// PLATE_TOPOLOGY_MATERIALIZATION_OPTIMIZATION=4  // TraceLevel.Info
/// </code>
///
/// Trace levels:
/// - Off (0): No tracing
/// - Error (1): Only errors
/// - Warning (2): Errors and warnings
/// - Info (3): Informational messages (optimization decisions, etc.)
/// - Verbose (4): Detailed diagnostic output
/// </summary>
public static class DiagnosticSwitches
{
    /// <summary>
    /// Controls tracing for materialization optimization decisions.
    ///
    /// When enabled at Info level, logs when Auto mode resolves to
    /// BreakOnFirstBeyondTick vs ScanAll, helping diagnose performance differences.
    /// </summary>
    public static readonly TraceSwitch MaterializationOptimization = new(
        "FantaSim.Geosphere.Plate.Topology.MaterializationOptimization",
        "Controls tracing for tick materialization optimization decisions");

    /// <summary>
    /// Controls tracing for capability validation warnings.
    ///
    /// When enabled, logs warnings when capability metadata appears inconsistent
    /// with runtime behavior (e.g., monotone flag set but Reject policy not used).
    /// </summary>
    public static readonly TraceSwitch CapabilityValidation = new(
        "FantaSim.Geosphere.Plate.Topology.CapabilityValidation",
        "Controls tracing for stream capability validation warnings");
}


// --- PATH: plugins/Geosphere.Plate.Topology.Materializer/IPlateTopologyIndexedStateView.cs ---
using FantaSim.Geosphere.Plate.Topology.Contracts.Derived;

namespace FantaSim.Geosphere.Plate.Topology.Materializer;

public interface IPlateTopologyIndexedStateView : IPlateTopologyStateView
{
    PlateTopologyIndices Indices { get; }
}


// --- PATH: plugins/Geosphere.Plate.Topology.Materializer/InvariantValidator.cs ---
﻿using FantaSim.Geosphere.Plate.Topology.Contracts.Entities;
using FantaSim.Geosphere.Plate.Topology.Contracts.Events;
using FantaSim.Geosphere.Plate.Topology.Contracts.Numerics;
using System.Linq;

namespace FantaSim.Geosphere.Plate.Topology.Materializer;

/// <summary>
/// Validates topology invariants for plate topology state per FR-010, FR-016.
///
/// The validator enforces critical topological constraints to ensure the
/// materialized state is valid and consistent. Violations are surfaced as
/// InvalidOperationException with clear messages indicating the invariant,
/// sequence number, and affected entities.
///
/// Invariants enforced:
/// 1. Boundary separates two plates: PlateIdLeft and PlateIdRight must exist in state
/// 2. No orphan boundaries/junctions: junctions must only reference existing non-retired boundaries
/// 3. Lifecycle ordering: no mutation after retirement
/// 4. Reference validity: events referencing missing/retired entities are rejected
/// 5. FR-016 boundary deletion: junctions referencing retired boundaries must be resolved via explicit events
/// </summary>
public static class InvariantValidator
{
    /// <summary>
    /// Validates all invariants for the materialized state.
    ///
    /// Throws InvalidOperationException if any invariant is violated, with a clear
    /// message indicating the invariant, sequence number, and affected entities.
    /// </summary>
    /// <param name="state">The materialized topology state to validate.</param>
    /// <exception cref="InvalidOperationException">
    /// Thrown when any invariant is violated.
    /// </exception>
    public static void Validate(PlateTopologyState state)
    {
        ArgumentNullException.ThrowIfNull(state);

        var violations = new List<InvariantViolation>();

        // Validate boundary plate references
        ValidateBoundaryPlateReferences(state, violations);

        // Validate junction boundary references (no orphan junctions)
        ValidateJunctionBoundaryReferences(state, violations);

        // Check for any violations and throw if found
        if (violations.Count > 0)
        {
            throw CreateViolationException(violations);
        }
    }

    /// <summary>
    /// Validates invariants during event application (pre-materialization validation).
    ///
    /// This is called during event application to validate event-specific invariants
    /// such as reference validity and lifecycle ordering.
    /// </summary>
    /// <param name="state">The current materialized state.</param>
    /// <param name="evt">The event being applied.</param>
    /// <exception cref="InvalidOperationException">
    /// Thrown when the event violates invariants.
    /// </exception>
    public static void ValidateEvent(PlateTopologyState state, IPlateTopologyEvent evt)
    {
        ArgumentNullException.ThrowIfNull(state);
        ArgumentNullException.ThrowIfNull(evt);

        switch (evt)
        {
            case BoundaryCreatedEvent boundaryCreated:
                ValidateBoundaryCreated(state, boundaryCreated);
                break;

            case BoundaryTypeChangedEvent boundaryTypeChanged:
                ValidateBoundaryTypeChanged(state, boundaryTypeChanged);
                break;

            case BoundaryGeometryUpdatedEvent boundaryGeometryUpdated:
                ValidateBoundaryGeometryUpdated(state, boundaryGeometryUpdated);
                break;

            case BoundaryRetiredEvent boundaryRetired:
                ValidateBoundaryRetired(state, boundaryRetired);
                break;

            case JunctionCreatedEvent junctionCreated:
                ValidateJunctionCreated(state, junctionCreated);
                break;

            case JunctionUpdatedEvent junctionUpdated:
                ValidateJunctionUpdated(state, junctionUpdated);
                break;

            case JunctionRetiredEvent junctionRetired:
                ValidateJunctionRetired(state, junctionRetired);
                break;

            case PlateRetiredEvent plateRetired:
                ValidatePlateRetired(state, plateRetired);
                break;
        }
    }

    private static void ValidateBoundaryPlateReferences(PlateTopologyState state, List<InvariantViolation> violations)
    {
        // Invariant 1: boundary must separate two plates
        // Both PlateIdLeft and PlateIdRight must exist in state and not be retired
        foreach (var (_, boundary) in state.Boundaries)
        {
            if (boundary.IsRetired)
                continue; // Retired boundaries don't need to satisfy this invariant

            if (boundary.PlateIdLeft == boundary.PlateIdRight)
            {
                violations.Add(new InvariantViolation(
                    "BoundarySeparatesTwoPlates",
                    $"Boundary {boundary.BoundaryId} has identical left and right plate {boundary.PlateIdLeft}",
                    state.LastEventSequence
                ));
            }

            // Check if left plate exists
            if (!state.Plates.ContainsKey(boundary.PlateIdLeft))
            {
                violations.Add(new InvariantViolation(
                    "BoundarySeparatesTwoPlates",
                    $"Boundary {boundary.BoundaryId} references non-existent left plate {boundary.PlateIdLeft}",
                    state.LastEventSequence
                ));
            }
            else if (state.Plates[boundary.PlateIdLeft].IsRetired)
            {
                violations.Add(new InvariantViolation(
                    "BoundarySeparatesTwoPlates",
                    $"Boundary {boundary.BoundaryId} references retired left plate {boundary.PlateIdLeft}",
                    state.LastEventSequence
                ));
            }

            // Check if right plate exists
            if (!state.Plates.ContainsKey(boundary.PlateIdRight))
            {
                violations.Add(new InvariantViolation(
                    "BoundarySeparatesTwoPlates",
                    $"Boundary {boundary.BoundaryId} references non-existent right plate {boundary.PlateIdRight}",
                    state.LastEventSequence
                ));
            }
            else if (state.Plates[boundary.PlateIdRight].IsRetired)
            {
                violations.Add(new InvariantViolation(
                    "BoundarySeparatesTwoPlates",
                    $"Boundary {boundary.BoundaryId} references retired right plate {boundary.PlateIdRight}",
                    state.LastEventSequence
                ));
            }
        }
    }

    private static void ValidateJunctionBoundaryReferences(PlateTopologyState state, List<InvariantViolation> violations)
    {
        // Invariant 2: no orphan boundaries/junctions
        // Junctions must only reference existing non-retired boundaries
        // Invariant 5: FR-016 - junctions referencing retired boundaries must be resolved
        foreach (var (_, junction) in state.Junctions)
        {
            if (junction.IsRetired)
                continue; // Retired junctions don't need to satisfy this invariant

            // Validate sphere-native geometry
            ValidateJunctionGeometry(junction, violations);

            foreach (var boundaryId in junction.BoundaryIds)
            {
                // Check if boundary exists
                if (!state.Boundaries.ContainsKey(boundaryId))
                {
                    violations.Add(new InvariantViolation(
                        "NoOrphanJunctions",
                        $"Junction {junction.JunctionId} references non-existent boundary {boundaryId}",
                        state.LastEventSequence
                    ));
                }
                // Check if boundary is retired (FR-016 violation)
                else if (state.Boundaries[boundaryId].IsRetired)
                {
                    violations.Add(new InvariantViolation(
                        "NoOrphanJunctions",
                        $"Junction {junction.JunctionId} references retired boundary {boundaryId} (FR-016: must update or retire junction via explicit event)",
                        state.LastEventSequence
                    ));
                }
            }
        }
    }

    private static void ValidateBoundaryCreated(PlateTopologyState state, BoundaryCreatedEvent evt)
    {
        if (evt.PlateIdLeft == evt.PlateIdRight)
        {
            throw new InvalidOperationException(
                $"Invariant violation: BoundarySeparatesTwoPlates " +
                $"[Sequence {evt.Sequence}] " +
                $"Boundary {evt.BoundaryId} creation has identical left and right plate {evt.PlateIdLeft}");
        }

        // Invariant 1: boundary must separate two existing plates
        if (!state.Plates.ContainsKey(evt.PlateIdLeft))
        {
            throw new InvalidOperationException(
                $"Invariant violation: BoundarySeparatesTwoPlates " +
                $"[Sequence {evt.Sequence}] " +
                $"Boundary {evt.BoundaryId} creation references non-existent left plate {evt.PlateIdLeft}");
        }

        if (!state.Plates.ContainsKey(evt.PlateIdRight))
        {
            throw new InvalidOperationException(
                $"Invariant violation: BoundarySeparatesTwoPlates " +
                $"[Sequence {evt.Sequence}] " +
                $"Boundary {evt.BoundaryId} creation references non-existent right plate {evt.PlateIdRight}");
        }

        // Check if referenced plates are retired
        if (state.Plates[evt.PlateIdLeft].IsRetired)
        {
            throw new InvalidOperationException(
                $"Invariant violation: BoundarySeparatesTwoPlates " +
                $"[Sequence {evt.Sequence}] " +
                $"Boundary {evt.BoundaryId} creation references retired left plate {evt.PlateIdLeft}");
        }

        if (state.Plates[evt.PlateIdRight].IsRetired)
        {
            throw new InvalidOperationException(
                $"Invariant violation: BoundarySeparatesTwoPlates " +
                $"[Sequence {evt.Sequence}] " +
                $"Boundary {evt.BoundaryId} creation references retired right plate {evt.PlateIdRight}");
        }
    }

    private static void ValidateBoundaryTypeChanged(PlateTopologyState state, BoundaryTypeChangedEvent evt)
    {
        // Invariant 3: lifecycle ordering - no mutation after retirement
        // Invariant 4: reference validity - boundary must exist and not be retired
        if (!state.Boundaries.ContainsKey(evt.BoundaryId))
        {
            throw new InvalidOperationException(
                $"Invariant violation: ReferenceValidity " +
                $"[Sequence {evt.Sequence}] " +
                $"Boundary type change references non-existent boundary {evt.BoundaryId}");
        }

        var boundary = state.Boundaries[evt.BoundaryId];
        if (boundary.IsRetired)
        {
            throw new InvalidOperationException(
                $"Invariant violation: LifecycleOrdering " +
                $"[Sequence {evt.Sequence}] " +
                $"Cannot change type of retired boundary {evt.BoundaryId} (no mutation after retirement)");
        }
    }

    private static void ValidateBoundaryGeometryUpdated(PlateTopologyState state, BoundaryGeometryUpdatedEvent evt)
    {
        // Invariant 3: lifecycle ordering - no mutation after retirement
        // Invariant 4: reference validity - boundary must exist and not be retired
        if (!state.Boundaries.ContainsKey(evt.BoundaryId))
        {
            throw new InvalidOperationException(
                $"Invariant violation: ReferenceValidity " +
                $"[Sequence {evt.Sequence}] " +
                $"Boundary geometry update references non-existent boundary {evt.BoundaryId}");
        }

        var boundary = state.Boundaries[evt.BoundaryId];
        if (boundary.IsRetired)
        {
            throw new InvalidOperationException(
                $"Invariant violation: LifecycleOrdering " +
                $"[Sequence {evt.Sequence}] " +
                $"Cannot update geometry of retired boundary {evt.BoundaryId} (no mutation after retirement)");
        }
    }

    private static void ValidateBoundaryRetired(PlateTopologyState state, BoundaryRetiredEvent evt)
    {
        // Invariant 4: reference validity - boundary must exist
        if (!state.Boundaries.ContainsKey(evt.BoundaryId))
        {
            throw new InvalidOperationException(
                $"Invariant violation: ReferenceValidity " +
                $"[Sequence {evt.Sequence}] " +
                $"Boundary retirement references non-existent boundary {evt.BoundaryId}");
        }

        var boundary = state.Boundaries[evt.BoundaryId];
        if (boundary.IsRetired)
        {
            throw new InvalidOperationException(
                $"Invariant violation: LifecycleOrdering " +
                $"[Sequence {evt.Sequence}] " +
                $"Boundary {evt.BoundaryId} is already retired");
        }

        // FR-016: Check if any active junctions reference this boundary
        var activeJunctionsReferencingBoundary = state.Junctions
            .Where(kvp => !kvp.Value.IsRetired && kvp.Value.BoundaryIds.Contains(evt.BoundaryId))
            .Select(kvp => kvp.Key)
            .ToArray();

        if (activeJunctionsReferencingBoundary.Length > 0)
        {
            throw new InvalidOperationException(
                $"Invariant violation: FR-016 BoundaryDeletion " +
                $"[Sequence {evt.Sequence}] " +
                $"Cannot retire boundary {evt.BoundaryId} while {activeJunctionsReferencingBoundary.Length} active junction(s) reference it: " +
                $"{string.Join(", ", activeJunctionsReferencingBoundary)}. " +
                $"Must update or retire these junctions via explicit JunctionUpdated/JunctionRetired events first.");
        }
    }

    /// <summary>
    /// Validates that a junction's location is a valid surface point on the unit sphere.
    /// </summary>
    private static void ValidateJunctionGeometry(Junction junction, List<InvariantViolation> violations)
    {
        // Check that surface point normal is unit length
        var normal = junction.Location.Normal;
        var len = Math.Sqrt(normal.X * normal.X + normal.Y * normal.Y + normal.Z * normal.Z);
        const double tolerance = 1e-6;

        if (Math.Abs(len - 1.0) > tolerance)
        {
            violations.Add(new InvariantViolation(
                "JunctionGeometry",
                $"Junction {junction.JunctionId} surface normal is not unit length (length={len:G9})",
                null
            ));
        }

        // Check radius is positive
        if (junction.Location.Radius <= 0)
        {
            violations.Add(new InvariantViolation(
                "JunctionGeometry",
                $"Junction {junction.JunctionId} has invalid radius ({junction.Location.Radius})",
                null
            ));
        }

        // Check boundary count (minimum 2 for a valid junction, typically 3+)
        if (junction.BoundaryIds.IsDefaultOrEmpty || junction.BoundaryIds.Length < 2)
        {
            violations.Add(new InvariantViolation(
                "JunctionGeometry",
                $"Junction {junction.JunctionId} has insufficient boundaries ({junction.BoundaryIds.Length})",
                null
            ));
        }
    }

    private static void ValidateJunctionCreated(PlateTopologyState state, JunctionCreatedEvent evt)
    {
        // Invariant 2: no orphan junctions - all referenced boundaries must exist and be non-retired
        foreach (var boundaryId in evt.BoundaryIds)
        {
            if (!state.Boundaries.ContainsKey(boundaryId))
            {
                throw new InvalidOperationException(
                    $"Invariant violation: NoOrphanJunctions " +
                    $"[Sequence {evt.Sequence}] " +
                    $"Junction {evt.JunctionId} creation references non-existent boundary {boundaryId}");
            }

            if (state.Boundaries[boundaryId].IsRetired)
            {
                throw new InvalidOperationException(
                    $"Invariant violation: NoOrphanJunctions " +
                    $"[Sequence {evt.Sequence}] " +
                    $"Junction {evt.JunctionId} creation references retired boundary {boundaryId}");
            }
        }
    }

    private static void ValidateJunctionUpdated(PlateTopologyState state, JunctionUpdatedEvent evt)
    {
        // Invariant 3: lifecycle ordering - no mutation after retirement
        // Invariant 4: reference validity - junction must exist and not be retired
        if (!state.Junctions.ContainsKey(evt.JunctionId))
        {
            throw new InvalidOperationException(
                $"Invariant violation: ReferenceValidity " +
                $"[Sequence {evt.Sequence}] " +
                $"Junction update references non-existent junction {evt.JunctionId}");
        }

        var junction = state.Junctions[evt.JunctionId];
        if (junction.IsRetired)
        {
            throw new InvalidOperationException(
                $"Invariant violation: LifecycleOrdering " +
                $"[Sequence {evt.Sequence}] " +
                $"Cannot update retired junction {evt.JunctionId} (no mutation after retirement)");
        }

        // Validate new boundary references if provided
        if (!evt.NewBoundaryIds.IsDefaultOrEmpty)
        {
            foreach (var boundaryId in evt.NewBoundaryIds)
            {
                if (!state.Boundaries.ContainsKey(boundaryId))
                {
                    throw new InvalidOperationException(
                        $"Invariant violation: NoOrphanJunctions " +
                        $"[Sequence {evt.Sequence}] " +
                        $"Junction {evt.JunctionId} update references non-existent boundary {boundaryId}");
                }

                if (state.Boundaries[boundaryId].IsRetired)
                {
                    throw new InvalidOperationException(
                        $"Invariant violation: NoOrphanJunctions " +
                        $"[Sequence {evt.Sequence}] " +
                        $"Junction {evt.JunctionId} update references retired boundary {boundaryId}");
                }
            }
        }
    }

    private static void ValidateJunctionRetired(PlateTopologyState state, JunctionRetiredEvent evt)
    {
        // Invariant 4: reference validity - junction must exist
        if (!state.Junctions.ContainsKey(evt.JunctionId))
        {
            throw new InvalidOperationException(
                $"Invariant violation: ReferenceValidity " +
                $"[Sequence {evt.Sequence}] " +
                $"Junction retirement references non-existent junction {evt.JunctionId}");
        }

        var junction = state.Junctions[evt.JunctionId];
        if (junction.IsRetired)
        {
            throw new InvalidOperationException(
                $"Invariant violation: LifecycleOrdering " +
                $"[Sequence {evt.Sequence}] " +
                $"Junction {evt.JunctionId} is already retired");
        }
    }

    private static void ValidatePlateRetired(PlateTopologyState state, PlateRetiredEvent evt)
    {
        // Invariant 4: reference validity - plate must exist
        if (!state.Plates.ContainsKey(evt.PlateId))
        {
            throw new InvalidOperationException(
                $"Invariant violation: ReferenceValidity " +
                $"[Sequence {evt.Sequence}] " +
                $"Plate retirement references non-existent plate {evt.PlateId}");
        }

        var plate = state.Plates[evt.PlateId];
        if (plate.IsRetired)
        {
            throw new InvalidOperationException(
                $"Invariant violation: LifecycleOrdering " +
                $"[Sequence {evt.Sequence}] " +
                $"Plate {evt.PlateId} is already retired");
        }
    }

    private static InvalidOperationException CreateViolationException(List<InvariantViolation> violations)
    {
        var message = $"Invariant violation(s) detected [{violations.Count} total]:\n";

        for (int i = 0; i < violations.Count; i++)
        {
            var violation = violations[i];
            message += $"  {i + 1}. [{violation.Invariant}]";
            if (violation.Sequence.HasValue)
            {
                message += $" [Sequence {violation.Sequence.Value}]";
            }
            message += $": {violation.Message}\n";
        }

        return new InvalidOperationException(message);
    }
}


// --- PATH: plugins/Geosphere.Plate.Topology.Materializer/PlateAdjacencyGenerator.cs ---
using System;
using System.Collections.Generic;
using System.Linq;
using FantaSim.Geosphere.Plate.Topology.Contracts.Derived;
using FantaSim.Geosphere.Plate.Topology.Contracts.Entities;
using FantaSim.Geosphere.Plate.Topology.Contracts.Identity;

namespace FantaSim.Geosphere.Plate.Topology.Materializer;

public sealed class PlateAdjacencyGenerator : IDerivedProductGenerator<PlateAdjacencyGraph>
{
    public PlateAdjacencyGraph Generate(IPlateTopologyStateView state)
    {
        ArgumentNullException.ThrowIfNull(state);

        var indices = PlateTopologyIndexAccess.GetPlateAdjacency(state);
        var graph = indices.PlateAdjacencyGraph;

        var plateIdComparer = PlateIdRfcComparer.Instance;
        var adjacencies = new SortedDictionary<PlateId, List<(PlateAdjacency adjacency, Guid boundaryIdGuid)>>(plateIdComparer);

        foreach (var node in graph.Nodes)
        {
            if (!indices.NodeToPlate.TryGetValue(node, out var plateId))
                continue;

            var list = new List<(PlateAdjacency adjacency, Guid boundaryIdGuid)>();

            foreach (var edge in graph.GetOutEdges(node))
            {
                if (!indices.EdgeToBoundary.TryGetValue(edge, out var boundaryId))
                    continue;

                if (!state.Boundaries.TryGetValue(boundaryId, out var boundary) || boundary.IsRetired)
                    continue;

                var endpoints = graph.GetEndpoints(edge);
                var otherNode = endpoints.From == node ? endpoints.To : endpoints.From;

                if (!indices.NodeToPlate.TryGetValue(otherNode, out var neighborPlateId))
                    continue;

                // Ensure plate entries exist and are active
                if (!state.Plates.TryGetValue(plateId, out var plate) || plate.IsRetired)
                    continue;
                if (!state.Plates.TryGetValue(neighborPlateId, out var neighbor) || neighbor.IsRetired)
                    continue;

                list.Add((new PlateAdjacency(neighborPlateId, boundary.BoundaryType), boundaryId.Value));
            }

            if (list.Count == 0)
                continue;

            list.Sort(PlateAdjacencySortComparer.Instance);
            adjacencies[plateId] = list;
        }

        var projected = new SortedDictionary<PlateId, List<PlateAdjacency>>(plateIdComparer);
        foreach (var (plateId, list) in adjacencies)
        {
            projected[plateId] = list.Select(x => x.adjacency).ToList();
        }

        return new PlateAdjacencyGraph(projected);
    }

    private sealed class PlateIdRfcComparer : IComparer<PlateId>
    {
        public static PlateIdRfcComparer Instance { get; } = new();

        public int Compare(PlateId x, PlateId y) => GuidOrdering.CompareRfc4122(x.Value, y.Value);
    }

    private sealed class PlateAdjacencySortComparer : IComparer<(PlateAdjacency adjacency, Guid boundaryIdGuid)>
    {
        public static PlateAdjacencySortComparer Instance { get; } = new();

        public int Compare((PlateAdjacency adjacency, Guid boundaryIdGuid) x, (PlateAdjacency adjacency, Guid boundaryIdGuid) y)
        {
            var plateCmp = GuidOrdering.CompareRfc4122(x.adjacency.PlateId.Value, y.adjacency.PlateId.Value);
            if (plateCmp != 0)
                return plateCmp;

            return GuidOrdering.CompareRfc4122(x.boundaryIdGuid, y.boundaryIdGuid);
        }
    }
}


// --- PATH: plugins/Geosphere.Plate.Topology.Materializer/PlateTopologyEventStore.cs ---
﻿using System.Buffers.Binary;
using System.Collections.Concurrent;
using System.Diagnostics;
using System.Text;
using FantaSim.Geosphere.Plate.Topology.Contracts.Capabilities;
using FantaSim.Geosphere.Plate.Topology.Contracts.Derived;
using FantaSim.Geosphere.Plate.Topology.Contracts.Events;
using FantaSim.Geosphere.Plate.Topology.Contracts.Identity;
using FantaSim.Geosphere.Plate.Topology.Serializers;
using UnifyStorage.Abstractions;

namespace FantaSim.Geosphere.Plate.Topology.Materializer;

/// <summary>
/// Implementation of ITopologyEventStore per RFC-V2-0004 and RFC-V2-0005.
///
/// Key design per persistence RFC:
/// - Stream prefix: "S:{variant}:{branch}:L{l}:{domain}:M{m}:"
/// - Event key: "{prefix}E:{seq}" where seq is big-endian uint64 (8 bytes fixed-width)
/// - Last sequence key: "{prefix}Head"
/// - Snapshot key: "{prefix}Snap:{tick}" where tick is big-endian uint64
/// - Capabilities key: "{prefix}Meta:Caps" ??9-byte bitset
/// - Event value: MessagePack envelope [eventType:string, payload:binary]
///
/// Features:
/// - Atomic batch append per stream
/// - Deterministic replay by Sequence ordering
/// - Stream isolation by TruthStreamIdentity
/// - Efficient range queries via lexicographic key ordering
/// - Stream capability tracking for safe optimizations
/// </summary>
public sealed class PlateTopologyEventStore : ITopologyEventStore, IPlateTopologySnapshotStore, ITruthStreamCapabilities, IDisposable
{
    private const string EventPrefix = "E:";
    private const string HeadSuffix = "Head";
    private const string SnapshotPrefix = "Snap:";
    private const string MetaCapsKey = "Meta:Caps";
    private readonly IKeyValueStore _store;
    private readonly object _lock = new();

    /// <summary>
    /// Per-stream locks for optimistic concurrency control.
    /// Ensures read-modify-write atomicity within a single process.
    /// Key is the stream prefix string for efficient lookup.
    /// </summary>
    private readonly ConcurrentDictionary<string, SemaphoreSlim> _streamLocks = new();

    /// <summary>
    /// Opens or creates an event store at the specified path.
    /// </summary>
    /// <param name="store">Ordered key-value store implementation.</param>
    public PlateTopologyEventStore(IKeyValueStore store)
    {
        ArgumentNullException.ThrowIfNull(store);
        _store = store;
    }

    /// <summary>
    /// Appends a batch of events to the specified stream atomically.
    ///
    /// Uses WriteBatch to ensure atomicity: either all events succeed
    /// or none are persisted. Validates that all events match the stream identity
    /// and have monotonically increasing Sequence numbers.
    ///
    /// Note: This overload uses default options (tick policy = Allow).
    /// </summary>
    /// <exception cref="ArgumentException">
    /// If events don't match stream identity or sequences are not monotonic.
    /// </exception>
    /// <exception cref="InvalidOperationException">
    /// If stream identity is not valid.
    /// </exception>
    public Task AppendAsync(
        TruthStreamIdentity stream,
        IEnumerable<IPlateTopologyEvent> events,
        CancellationToken cancellationToken)
    {
        return AppendAsync(stream, events, AppendOptions.Default, cancellationToken);
    }

    /// <summary>
    /// Appends a batch of events to the specified stream atomically with custom options.
    ///
    /// Uses WriteBatch to ensure atomicity: either all events succeed
    /// or none are persisted. Validates that all events match the stream identity
    /// and have monotonically increasing Sequence numbers.
    ///
    /// Tick monotonicity policy is controlled via options:
    /// - Allow: tick can decrease without any action (default)
    /// - Warn: tick decrease logs a warning but allows append
    /// - Reject: tick decrease throws InvalidOperationException
    /// </summary>
    /// <exception cref="ArgumentException">
    /// If events don't match stream identity or sequences are not monotonic.
    /// </exception>
    /// <exception cref="InvalidOperationException">
    /// If stream identity is not valid, or if tick decreases and policy is Reject.
    /// </exception>
    /// <exception cref="ConcurrencyConflictException">
    /// If <see cref="AppendOptions.ExpectedHead"/> is set and the actual head doesn't match.
    /// </exception>
    public async Task AppendAsync(
        TruthStreamIdentity stream,
        IEnumerable<IPlateTopologyEvent> events,
        AppendOptions options,
        CancellationToken cancellationToken)
    {
        ArgumentNullException.ThrowIfNull(stream);
        ArgumentNullException.ThrowIfNull(events);
        options ??= AppendOptions.Default;

        // Validate stream identity per RFC-V2-0001 review recommendation
        if (!stream.IsValid())
        {
            throw new InvalidOperationException(
                $"TruthStreamIdentity is not valid: {stream}. " +
                "Ensure VariantId, BranchId, Model are non-empty, LLevel >= 0, and Domain is well-formed.");
        }

        var eventsList = events.ToList();
        if (eventsList.Count == 0)
            return;

        // Validate all events belong to the same stream
        foreach (var evt in eventsList)
        {
            if (evt.StreamIdentity != stream)
            {
                throw new ArgumentException(
                    $"Event {evt.EventId} stream identity {evt.StreamIdentity} does not match expected {stream}",
                    nameof(events));
            }
        }

        // Validate sequences are monotonically increasing
        for (int i = 1; i < eventsList.Count; i++)
        {
            if (eventsList[i].Sequence <= eventsList[i - 1].Sequence)
            {
                throw new ArgumentException(
                    $"Events must have monotonically increasing Sequence numbers. Event {i} has Sequence {eventsList[i].Sequence} after {eventsList[i - 1].Sequence}",
                    nameof(events));
            }
        }

        // Apply tick monotonicity policy
        ApplyTickMonotonicityPolicy(eventsList, options.TickPolicy);

        // Build batch atomically
        var prefix = BuildStreamPrefix(stream);
        var prefixString = Encoding.UTF8.GetString(prefix);

        // Acquire per-stream lock for optimistic concurrency
        // This ensures read-check-write atomicity within a single process
        var streamLock = _streamLocks.GetOrAdd(prefixString, _ => new SemaphoreSlim(1, 1));
        await streamLock.WaitAsync(cancellationToken).ConfigureAwait(false);
        try
        {
            // Check optimistic concurrency precondition if specified
            if (options.ExpectedHead.HasValue)
            {
                var expected = options.ExpectedHead.Value;
                var actual = GetHeadInternal(prefix);

                if (expected.Sequence != actual.Sequence ||
                    !expected.Hash.AsSpan().SequenceEqual(actual.Hash))
                {
                    throw new ConcurrencyConflictException(stream, expected, actual);
                }
            }

            using var batch = _store.CreateWriteBatch();

            // Check if this is a genesis append (brand new stream)
            var isGenesisAppend = !StreamExists(prefix);

            var previousHash = GetPreviousHashForAppend(prefix);

            byte[] lastHash = previousHash;
            long lastTick = 0;

            foreach (var evt in eventsList)
            {
                var eventKey = BuildEventKey(prefix, evt.Sequence);
                var eventBytes = MessagePackEventSerializer.Serialize((IPlateTopologyEvent)evt);

                var schemaVersion = MessagePackEventRecordSerializer.SchemaVersionV1;
                // RFC-V2-0005: tick is hash-critical and must use the event's Tick, not Sequence
                var tick = evt.Tick.Value;
                var hash = MessagePackEventRecordSerializer.ComputeHashV1(schemaVersion, tick, previousHash, eventBytes);
                var recordBytes = MessagePackEventRecordSerializer.SerializeRecord(schemaVersion, tick, previousHash, hash, eventBytes);

                batch.Put(eventKey, recordBytes);
                previousHash = hash;
                lastHash = hash;
                lastTick = tick;
            }

            // Update head metadata per RFC-V2-0004: {lastSeq, lastHash, lastTick}
            var headKey = BuildHeadKey(prefix);
            var lastSequence = eventsList[^1].Sequence;
            var headBytes = HeadRecordSerializer.Serialize(lastSequence, lastHash, lastTick);
            batch.Put(headKey, headBytes);

            // For genesis appends with Reject policy, mark stream as tick-monotone
            // This is the ONLY safe time to set this flag - at stream creation with strict policy
            if (isGenesisAppend && options.TickPolicy == TickMonotonicityPolicy.Reject)
            {
                SetCapabilitiesInBatch(batch, prefix, StreamCapabilities.GenesisWithRejectPolicy);
            }

            // Write batch atomically
            lock (_lock)
            {
                _store.Write(batch);
            }
        }
        finally
        {
            streamLock.Release();
        }
    }

    /// <summary>
    /// Applies the tick monotonicity policy to a list of events.
    /// </summary>
    private static void ApplyTickMonotonicityPolicy(
        List<IPlateTopologyEvent> events,
        TickMonotonicityPolicy policy)
    {
        if (policy == TickMonotonicityPolicy.Allow || events.Count < 2)
            return;

        for (int i = 1; i < events.Count; i++)
        {
            if (events[i].Tick.Value < events[i - 1].Tick.Value)
            {
                var message = $"Tick decreased from {events[i - 1].Tick.Value} to {events[i].Tick.Value} " +
                              $"at event index {i} (Sequence {events[i].Sequence})";

                switch (policy)
                {
                    case TickMonotonicityPolicy.Warn:
                        // Log warning - implementation should use a proper logging framework
                        // For now, use Debug.WriteLine which is visible in tests
                        System.Diagnostics.Debug.WriteLine($"[TickMonotonicity.Warn] {message}");
                        break;

                    case TickMonotonicityPolicy.Reject:
                        throw new InvalidOperationException(
                            $"Tick monotonicity violation: {message}. " +
                            "Use TickMonotonicityPolicy.Allow or Warn to permit tick decreases.");
                }
            }
        }
    }

    /// <summary>
    /// Reads events from a stream starting from a specific Sequence number.
    ///
    /// Returns events in ascending Sequence order for deterministic replay.
    /// Uses range scan starting from the first key >= fromSequenceInclusive.
    /// Stream isolation is enforced via key prefix.
    /// </summary>
    /// <exception cref="InvalidOperationException">
    /// If stream identity is not valid.
    /// </exception>
    public async IAsyncEnumerable<IPlateTopologyEvent> ReadAsync(
        TruthStreamIdentity stream,
        long fromSequenceInclusive,
        [System.Runtime.CompilerServices.EnumeratorCancellation] CancellationToken cancellationToken)
    {
        ArgumentNullException.ThrowIfNull(stream);
        if (fromSequenceInclusive < 0)
            throw new ArgumentOutOfRangeException(nameof(fromSequenceInclusive), "Sequence must be non-negative");

        // Validate stream identity per RFC-V2-0001 review recommendation
        if (!stream.IsValid())
        {
            throw new InvalidOperationException(
                $"TruthStreamIdentity is not valid: {stream}. " +
                "Ensure VariantId, BranchId, Model are non-empty, LLevel >= 0, and Domain is well-formed.");
        }

        var prefix = BuildStreamPrefix(stream);
        var firstKey = BuildEventKey(prefix, fromSequenceInclusive);

        var expectedPreviousHash = GetExpectedPreviousHashForRead(prefix, fromSequenceInclusive);

        await Task.Yield(); // Ensure async pattern

        var bytesToYield = new List<byte[]>();
        lock (_lock)
        {
            using var iterator = _store.CreateIterator();
            iterator.Seek(firstKey);

            while (iterator.Valid && HasStreamPrefix(iterator.Key, prefix))
            {
                bytesToYield.Add(iterator.Value.ToArray());
                iterator.Next();
            }
        }

        foreach (var eventBytes in bytesToYield)
        {
            cancellationToken.ThrowIfCancellationRequested();

            if (MessagePackEventRecordSerializer.TryDeserializeRecord(eventBytes, out var record))
            {
                if (!record.PreviousHash.AsSpan().SequenceEqual(expectedPreviousHash))
                {
                    throw new InvalidOperationException("EventRecord previousHash mismatch");
                }

                var evt = DeserializeAndValidateRecord(record);
                expectedPreviousHash = record.Hash;
                yield return evt;
            }
            else
            {
                expectedPreviousHash = MessagePackEventRecordSerializer.GetZeroHash();
                yield return MessagePackEventSerializer.Deserialize(eventBytes);
            }
        }
    }

    /// <summary>
    /// Gets the highest Sequence number for a stream.
    ///
    /// Returns null if the stream is empty or does not exist.
    /// Reads from the Head metadata key which stores the last sequence number
    /// as a big-endian uint64.
    /// </summary>
    /// <exception cref="InvalidOperationException">
    /// If stream identity is not valid.
    /// </exception>
    public Task<long?> GetLastSequenceAsync(
        TruthStreamIdentity stream,
        CancellationToken cancellationToken)
    {
        ArgumentNullException.ThrowIfNull(stream);

        // Validate stream identity per RFC-V2-0001 review recommendation
        if (!stream.IsValid())
        {
            throw new InvalidOperationException(
                $"TruthStreamIdentity is not valid: {stream}. " +
                "Ensure VariantId, BranchId, Model are non-empty, LLevel >= 0, and Domain is well-formed.");
        }

        var prefix = BuildStreamPrefix(stream);
        var headKey = BuildHeadKey(prefix);

        Span<byte> buffer = stackalloc byte[8];
        int written;

        lock (_lock)
        {
            if (!_store.TryGet(headKey, buffer, out written))
            {
                return Task.FromResult<long?>(null);
            }
        }

        if (written != 8)
        {
            throw new InvalidOperationException($"Head value must be 8 bytes, got {written}");
        }

        // Decode big-endian uint64 to long
        var value = BinaryPrimitives.ReadInt64BigEndian(buffer);
        return Task.FromResult<long?>(value);
    }

    /// <summary>
    /// Gets the current head state (sequence + hash) of a stream.
    ///
    /// Use this method to obtain the precondition for optimistic concurrency control.
    /// The returned <see cref="StreamHead"/> can be converted to a <see cref="HeadPrecondition"/>
    /// via <see cref="StreamHead.ToPrecondition"/> and passed to <see cref="AppendOptions.ExpectedHead"/>.
    /// </summary>
    /// <exception cref="InvalidOperationException">
    /// If stream identity is not valid.
    /// </exception>
    public Task<StreamHead> GetHeadAsync(
        TruthStreamIdentity stream,
        CancellationToken cancellationToken)
    {
        ArgumentNullException.ThrowIfNull(stream);

        // Validate stream identity per RFC-V2-0001 review recommendation
        if (!stream.IsValid())
        {
            throw new InvalidOperationException(
                $"TruthStreamIdentity is not valid: {stream}. " +
                "Ensure VariantId, BranchId, Model are non-empty, LLevel >= 0, and Domain is well-formed.");
        }

        var prefix = BuildStreamPrefix(stream);
        return Task.FromResult(GetHeadInternal(prefix));
    }

    /// <summary>
    /// Internal helper to get stream head without validation.
    /// Used by both GetHeadAsync and AppendAsync precondition check.
    /// </summary>
    private StreamHead GetHeadInternal(byte[] prefix)
    {
        var headKey = BuildHeadKey(prefix);

        Span<byte> headBuffer = stackalloc byte[8];
        int headWritten;

        lock (_lock)
        {
            if (!_store.TryGet(headKey, headBuffer, out headWritten))
            {
                return StreamHead.Empty;
            }
        }

        if (headWritten != 8)
        {
            throw new InvalidOperationException($"Head value must be 8 bytes, got {headWritten}");
        }

        var lastSequence = BinaryPrimitives.ReadInt64BigEndian(headBuffer);
        var lastEventKey = BuildEventKey(prefix, lastSequence);

        byte[]? lastValue;
        lock (_lock)
        {
            lastValue = ReadBytes(lastEventKey);
        }

        if (lastValue != null && MessagePackEventRecordSerializer.TryDeserializeRecord(lastValue, out var lastRecord))
        {
            return new StreamHead(lastSequence, lastRecord.Hash);
        }

        // Stream has head key but no event - shouldn't happen but return empty
        return StreamHead.Empty;
    }

    public Task SaveSnapshotAsync(PlateTopologySnapshot snapshot, CancellationToken cancellationToken)
    {
        ArgumentNullException.ThrowIfNull(snapshot);

        if (!snapshot.Key.Stream.IsValid())
        {
            throw new InvalidOperationException(
                $"TruthStreamIdentity is not valid: {snapshot.Key.Stream}. " +
                "Ensure VariantId, BranchId, Model are non-empty, LLevel >= 0, and Domain is well-formed.");
        }

        if (snapshot.Key.Tick < 0)
            throw new ArgumentOutOfRangeException(nameof(snapshot), "Snapshot tick must be non-negative");

        var prefix = BuildStreamPrefix(snapshot.Key.Stream);
        var key = BuildSnapshotKey(prefix, snapshot.Key.Tick);
        var bytes = MessagePackPlateTopologySnapshotSerializer.Serialize(snapshot);

        lock (_lock)
        {
            _store.Put(key, bytes);
        }

        return Task.CompletedTask;
    }

    public Task<PlateTopologySnapshot?> GetSnapshotAsync(PlateTopologyMaterializationKey key, CancellationToken cancellationToken)
    {
        ArgumentNullException.ThrowIfNull(key);

        if (!key.Stream.IsValid())
        {
            throw new InvalidOperationException(
                $"TruthStreamIdentity is not valid: {key.Stream}. " +
                "Ensure VariantId, BranchId, Model are non-empty, LLevel >= 0, and Domain is well-formed.");
        }

        if (key.Tick < 0)
            return Task.FromResult<PlateTopologySnapshot?>(null);

        var prefix = BuildStreamPrefix(key.Stream);
        var snapshotKey = BuildSnapshotKey(prefix, key.Tick);

        byte[]? bytes;
        lock (_lock)
        {
            try
            {
                bytes = ReadBytes(snapshotKey);
            }
            catch
            {
                bytes = null;
            }
        }

        if (bytes == null || bytes.Length == 0)
            return Task.FromResult<PlateTopologySnapshot?>(null);

        var snapshot = MessagePackPlateTopologySnapshotSerializer.Deserialize(bytes);
        return Task.FromResult<PlateTopologySnapshot?>(snapshot);
    }

    /// <inheritdoc />
    public Task<PlateTopologySnapshot?> GetLatestSnapshotBeforeAsync(
        TruthStreamIdentity stream,
        long targetTick,
        CancellationToken cancellationToken)
    {
        ArgumentNullException.ThrowIfNull(stream);

        if (!stream.IsValid())
        {
            throw new InvalidOperationException(
                $"TruthStreamIdentity is not valid: {stream}. " +
                "Ensure VariantId, BranchId, Model are non-empty, LLevel >= 0, and Domain is well-formed.");
        }

        if (targetTick < 0)
            return Task.FromResult<PlateTopologySnapshot?>(null);

        var prefix = BuildStreamPrefix(stream);
        var snapshotPrefix = BuildSnapshotPrefix(prefix);
        var targetKey = BuildSnapshotKey(prefix, targetTick);

        byte[]? bytes = null;

        lock (_lock)
        {
            using var iterator = _store.CreateIterator();
            iterator.SeekForPrev(targetKey);

            if (!iterator.Valid)
                return Task.FromResult<PlateTopologySnapshot?>(null);

            var foundKey = iterator.Key;

            // Check if the found key starts with our snapshot prefix
            // (ensures we don't accidentally read a snapshot from another stream)
            if (!foundKey.StartsWith(snapshotPrefix))
                return Task.FromResult<PlateTopologySnapshot?>(null);

            bytes = iterator.Value.ToArray();
        }

        if (bytes == null || bytes.Length == 0)
            return Task.FromResult<PlateTopologySnapshot?>(null);

        var snapshot = MessagePackPlateTopologySnapshotSerializer.Deserialize(bytes);
        return Task.FromResult<PlateTopologySnapshot?>(snapshot);
    }

    /// <summary>
    /// Builds the stream prefix key component.
    ///
    /// Format: "S:{variant}:{branch}:L{l}:{domain}:M{m}:"
    /// </summary>
    private static byte[] BuildStreamPrefix(TruthStreamIdentity stream)
    {
        return Encoding.UTF8.GetBytes($"S:{stream.VariantId}:{stream.BranchId}:L{stream.LLevel}:{stream.Domain}:M{stream.Model}:");
    }

    private byte[] GetPreviousHashForAppend(byte[] prefix)
    {
        var headKey = BuildHeadKey(prefix);

        Span<byte> headBuffer = stackalloc byte[8];
        int headWritten;

        lock (_lock)
        {
            if (!_store.TryGet(headKey, headBuffer, out headWritten))
            {
                return MessagePackEventRecordSerializer.GetZeroHash();
            }
        }

        if (headWritten != 8)
        {
            throw new InvalidOperationException($"Head value must be 8 bytes, got {headWritten}");
        }

        var lastSequence = BinaryPrimitives.ReadInt64BigEndian(headBuffer);
        var lastEventKey = BuildEventKey(prefix, lastSequence);

        byte[]? lastValue;
        lock (_lock)
        {
            lastValue = ReadBytes(lastEventKey);
        }

        if (lastValue != null && MessagePackEventRecordSerializer.TryDeserializeRecord(lastValue, out var lastRecord))
        {
            return lastRecord.Hash;
        }

        return MessagePackEventRecordSerializer.GetZeroHash();
    }

    private byte[] GetExpectedPreviousHashForRead(byte[] prefix, long fromSequenceInclusive)
    {
        if (fromSequenceInclusive <= 0)
        {
            return MessagePackEventRecordSerializer.GetZeroHash();
        }

        var previousEventKey = BuildEventKey(prefix, fromSequenceInclusive - 1);

        byte[]? previousValue;
        lock (_lock)
        {
            previousValue = ReadBytes(previousEventKey);
        }

        if (previousValue != null && MessagePackEventRecordSerializer.TryDeserializeRecord(previousValue, out var previousRecord))
        {
            return previousRecord.Hash;
        }

        return MessagePackEventRecordSerializer.GetZeroHash();
    }

    private static IPlateTopologyEvent DeserializeAndValidateRecord(MessagePackEventRecordSerializer.EventRecordV1 record)
    {
        if (record.SchemaVersion != MessagePackEventRecordSerializer.SchemaVersionV1)
        {
            throw new InvalidOperationException($"Unsupported schemaVersion: {record.SchemaVersion}");
        }

        var expectedHash = MessagePackEventRecordSerializer.ComputeHashV1(
            record.SchemaVersion,
            record.Tick,
            record.PreviousHash,
            record.EventBytes);

        if (!expectedHash.AsSpan().SequenceEqual(record.Hash))
        {
            throw new InvalidOperationException("EventRecord hash mismatch");
        }

        var evt = MessagePackEventSerializer.Deserialize(record.EventBytes);
        if (evt.Sequence != record.Tick)
        {
            throw new InvalidOperationException("EventRecord tick does not match event payload sequence");
        }

        return evt;
    }

    /// <summary>
    /// Builds an event key from stream prefix and Sequence number.
    ///
    /// Format: "{prefix}E:{seq}" where seq is big-endian uint64 (8 bytes).
    /// Big-endian encoding ensures lexicographic ordering matches numeric ordering.
    /// </summary>
    private static byte[] BuildEventKey(byte[] prefix, long sequence)
    {
        var key = new byte[prefix.Length + EventPrefix.Length + 8];

        // Copy prefix
        Buffer.BlockCopy(prefix, 0, key, 0, prefix.Length);

        // Copy "E:" suffix
        Encoding.UTF8.GetBytes(EventPrefix, 0, EventPrefix.Length, key, prefix.Length);

        // Encode sequence as big-endian uint64
        var offset = prefix.Length + EventPrefix.Length;
        BinaryPrimitives.WriteUInt64BigEndian(key.AsSpan(offset), (ulong)sequence);

        return key;
    }

    /// <summary>
    /// Builds the Head metadata key for a stream.
    ///
    /// Format: "{prefix}Head"
    /// </summary>
    private static byte[] BuildHeadKey(byte[] prefix)
    {
        var key = new byte[prefix.Length + HeadSuffix.Length];
        Buffer.BlockCopy(prefix, 0, key, 0, prefix.Length);
        Encoding.UTF8.GetBytes(HeadSuffix, 0, HeadSuffix.Length, key, prefix.Length);
        return key;
    }

    private static byte[] BuildSnapshotKey(byte[] prefix, long tick)
    {
        var key = new byte[prefix.Length + SnapshotPrefix.Length + 8];

        Buffer.BlockCopy(prefix, 0, key, 0, prefix.Length);
        Encoding.UTF8.GetBytes(SnapshotPrefix, 0, SnapshotPrefix.Length, key, prefix.Length);

        var offset = prefix.Length + SnapshotPrefix.Length;
        BinaryPrimitives.WriteUInt64BigEndian(key.AsSpan(offset), (ulong)tick);

        return key;
    }

    /// <summary>
    /// Builds the snapshot key prefix (without tick suffix).
    /// Used to verify SeekForPrev results belong to the same stream.
    /// </summary>
    private static byte[] BuildSnapshotPrefix(byte[] streamPrefix)
    {
        var key = new byte[streamPrefix.Length + SnapshotPrefix.Length];
        Buffer.BlockCopy(streamPrefix, 0, key, 0, streamPrefix.Length);
        Encoding.UTF8.GetBytes(SnapshotPrefix, 0, SnapshotPrefix.Length, key, streamPrefix.Length);
        return key;
    }

    /// <summary>
    /// Checks if a key starts with the given stream prefix.
    ///
    /// Used for range scan termination to ensure we don't read into another stream.
    /// </summary>
    private static bool HasStreamPrefix(ReadOnlySpan<byte> key, byte[] prefix)
    {
        if (key.Length < prefix.Length)
            return false;

        if (!key[..prefix.Length].SequenceEqual(prefix))
            return false;

        var requiredLength = prefix.Length + EventPrefix.Length;
        if (key.Length < requiredLength)
            return false;

        return key[prefix.Length] == (byte)'E' && key[prefix.Length + 1] == (byte)':';
    }

    /// <summary>
    /// Builds the metadata capabilities key for a stream.
    ///
    /// Format: "{prefix}Meta:Caps"
    /// </summary>
    private static byte[] BuildMetaCapsKey(byte[] prefix)
    {
        var key = new byte[prefix.Length + MetaCapsKey.Length];
        Buffer.BlockCopy(prefix, 0, key, 0, prefix.Length);
        Encoding.UTF8.GetBytes(MetaCapsKey, 0, MetaCapsKey.Length, key, prefix.Length);
        return key;
    }

    #region ITruthStreamCapabilities

    /// <inheritdoc />
    public ValueTask<bool> IsTickMonotoneFromGenesisAsync(
        TruthStreamIdentity stream,
        CancellationToken cancellationToken = default)
    {
        ArgumentNullException.ThrowIfNull(stream);

        if (!stream.IsValid())
            return ValueTask.FromResult(false);

        var prefix = BuildStreamPrefix(stream);
        var capsKey = BuildMetaCapsKey(prefix);

        lock (_lock)
        {
            var capsBytes = ReadBytes(capsKey);
            if (capsBytes == null || capsBytes.Length < StreamCapabilities.StorageSize)
                return ValueTask.FromResult(false);

            var caps = StreamCapabilities.FromBytes(capsBytes);

            // Guard: If monotone flag is set but RejectFromGenesis isn't, something is wrong
            // This protects against corrupted metadata or future misuse
            if (caps.IsTickMonotoneFromGenesis && !caps.IsTickPolicyRejectFromGenesis)
            {
                Trace.WriteLineIf(
                    DiagnosticSwitches.CapabilityValidation.TraceWarning,
                    $"[EventStore] Stream {stream} has TickMonotoneFromGenesis=true but TickPolicyRejectFromGenesis=false. " +
                    "This is inconsistent - ignoring monotone flag for safety.");
                return ValueTask.FromResult(false);
            }

            return ValueTask.FromResult(caps.IsTickMonotoneFromGenesis);
        }
    }

    /// <summary>
    /// Gets the full capabilities for a stream.
    /// </summary>
    /// <param name="stream">The truth stream identity.</param>
    /// <returns>Stream capabilities, or None if not set.</returns>
    public StreamCapabilities GetCapabilities(TruthStreamIdentity stream)
    {
        ArgumentNullException.ThrowIfNull(stream);

        if (!stream.IsValid())
            return StreamCapabilities.None;

        var prefix = BuildStreamPrefix(stream);
        var capsKey = BuildMetaCapsKey(prefix);

        lock (_lock)
        {
            var capsBytes = ReadBytes(capsKey);
            if (capsBytes != null)
            {
                return StreamCapabilities.FromBytes(capsBytes);
            }
            return StreamCapabilities.None;
        }
    }

    /// <summary>
    /// Sets the capabilities for a stream atomically in a write batch.
    ///
    /// This is typically called during the first append to a new stream
    /// when using TickMonotonicityPolicy.Reject.
    /// </summary>
    private void SetCapabilitiesInBatch(IWriteBatch batch, byte[] prefix, StreamCapabilities caps)
    {
        var capsKey = BuildMetaCapsKey(prefix);
        var capsBytes = caps.ToBytes();
        batch.Put(capsKey, capsBytes);
    }

    /// <summary>
    /// Checks if a stream exists (has any events).
    /// </summary>
    private bool StreamExists(byte[] prefix)
    {
        var headKey = BuildHeadKey(prefix);
        lock (_lock)
        {
            Span<byte> buffer = stackalloc byte[0];
            int written;
            return _store.TryGet(headKey, buffer, out written);
        }
    }

    private byte[]? ReadBytes(byte[] key)
    {
        // First try with a small stack buffer to get size
        Span<byte> initialBuffer = stackalloc byte[1];
        if (_store.TryGet(key, initialBuffer, out var written))
        {
            // Value fit in 1 byte (or was empty)
            return initialBuffer.Slice(0, written).ToArray();
        }

        if (written > 0)
        {
            var result = new byte[written];
            if (_store.TryGet(key, result, out var finalWritten))
            {
                return result;
            }
            // Should not happen if store is consistent under lock
            throw new InvalidOperationException("Store state changed during read");
        }

        return null;
    }

    #endregion

    /// <summary>
    /// Disposes the store and releases resources.
    /// </summary>
    public void Dispose()
    {
        _store.Dispose();
    }
}


// --- PATH: plugins/Geosphere.Plate.Topology.Materializer/PlateTopologyIndexAccess.cs ---
using FantaSim.Geosphere.Plate.Topology.Contracts.Derived;

namespace FantaSim.Geosphere.Plate.Topology.Materializer;

public static class PlateTopologyIndexAccess
{
    public static PlateTopologyIndices GetPlateAdjacency(IPlateTopologyStateView state)
    {
        ArgumentNullException.ThrowIfNull(state);

        if (state is IPlateTopologyIndexedStateView indexed)
            return indexed.Indices;

        return PlateTopologyIndicesBuilder.BuildPlateAdjacency(state);
    }
}


// --- PATH: plugins/Geosphere.Plate.Topology.Materializer/PlateTopologyIndices.cs ---
using System.Collections.Generic;
using FantaSim.Geosphere.Plate.Topology.Contracts.Derived;
using FantaSim.Geosphere.Plate.Topology.Contracts.Entities;
using UnifyTopology.Graph;

namespace FantaSim.Geosphere.Plate.Topology.Materializer;

/// <summary>
/// Derived indices built from a <see cref="IPlateTopologyStateView"/> for efficient graph-like queries.
/// </summary>
/// <remarks>
/// <para>
/// <see cref="NodeId"/> and <see cref="EdgeId"/> are <b>ephemeral handles</b>: they are only meaningful
/// for the accompanying maps (<see cref="PlateToNode"/>, <see cref="NodeToPlate"/>,
/// <see cref="BoundaryToEdge"/>, <see cref="EdgeToBoundary"/>) within this specific index instance.
/// </para>
/// <para>
/// Never persist <see cref="NodeId"/>/<see cref="EdgeId"/>. Always persist <see cref="PlateId"/> and
/// <see cref="BoundaryId"/>.
/// </para>
/// </remarks>
public sealed class PlateTopologyIndices
{
    public PlateTopologyIndices(
        ITopologyGraph plateAdjacencyGraph,
        IReadOnlyDictionary<PlateId, NodeId> plateToNode,
        IReadOnlyDictionary<NodeId, PlateId> nodeToPlate,
        IReadOnlyDictionary<BoundaryId, EdgeId> boundaryToEdge,
        IReadOnlyDictionary<EdgeId, BoundaryId> edgeToBoundary)
    {
        PlateAdjacencyGraph = plateAdjacencyGraph;
        PlateToNode = plateToNode;
        NodeToPlate = nodeToPlate;
        BoundaryToEdge = boundaryToEdge;
        EdgeToBoundary = edgeToBoundary;
    }

    public ITopologyGraph PlateAdjacencyGraph { get; }

    public IReadOnlyDictionary<PlateId, NodeId> PlateToNode { get; }

    public IReadOnlyDictionary<NodeId, PlateId> NodeToPlate { get; }

    public IReadOnlyDictionary<BoundaryId, EdgeId> BoundaryToEdge { get; }

    public IReadOnlyDictionary<EdgeId, BoundaryId> EdgeToBoundary { get; }
}


// --- PATH: plugins/Geosphere.Plate.Topology.Materializer/PlateTopologyIndicesBuilder.cs ---
using System;
using System.Collections.Generic;
using System.Linq;
using FantaSim.Geosphere.Plate.Topology.Contracts.Derived;
using FantaSim.Geosphere.Plate.Topology.Contracts.Entities;
using FantaSim.Geosphere.Plate.Topology.Contracts.Identity;
using UnifyTopology.Graph;
using UnifyTopology.Graph.InMemory;

namespace FantaSim.Geosphere.Plate.Topology.Materializer;

public static class PlateTopologyIndicesBuilder
{
    public static PlateTopologyIndices BuildPlateAdjacency(IPlateTopologyStateView state)
    {
        ArgumentNullException.ThrowIfNull(state);

        var activePlates = state.Plates
            .Where(kvp => !kvp.Value.IsRetired)
            .Select(kvp => kvp.Key)
            .OrderBy(x => x.Value, GuidOrdering.Rfc4122Comparer)
            .ToArray();

        var activeBoundaries = state.Boundaries
            .Where(kvp => !kvp.Value.IsRetired)
            .Select(kvp => kvp.Value)
            .OrderBy(x => x.BoundaryId.Value, GuidOrdering.Rfc4122Comparer)
            .ToArray();

        var graph = new MutableTopologyGraph(GraphKind.Undirected);

        var plateToNode = new Dictionary<PlateId, NodeId>(activePlates.Length);
        var nodeToPlate = new Dictionary<NodeId, PlateId>(activePlates.Length);

        var nextNode = 1UL;
        foreach (var plateId in activePlates)
        {
            var nodeId = new NodeId(nextNode++);
            graph.AddNode(nodeId);

            plateToNode.Add(plateId, nodeId);
            nodeToPlate.Add(nodeId, plateId);
        }

        var boundaryToEdge = new Dictionary<BoundaryId, EdgeId>();
        var edgeToBoundary = new Dictionary<EdgeId, BoundaryId>();

        var nextEdge = 1UL;
        foreach (var boundary in activeBoundaries)
        {
            if (!plateToNode.TryGetValue(boundary.PlateIdLeft, out var leftNode))
                continue;
            if (!plateToNode.TryGetValue(boundary.PlateIdRight, out var rightNode))
                continue;

            var edgeId = new EdgeId(nextEdge++);
            graph.AddEdge(edgeId, leftNode, rightNode);

            boundaryToEdge.Add(boundary.BoundaryId, edgeId);
            edgeToBoundary.Add(edgeId, boundary.BoundaryId);
        }

        return new PlateTopologyIndices(
            graph,
            plateToNode,
            nodeToPlate,
            boundaryToEdge,
            edgeToBoundary);
    }
}


// --- PATH: plugins/Geosphere.Plate.Topology.Materializer/PlateTopologyMaterializer.cs ---
﻿using System.Collections.Immutable;
using System.Diagnostics;
using Plate.TimeDete.Time.Primitives;
using FantaSim.Geosphere.Plate.Topology.Contracts.Capabilities;
using FantaSim.Geosphere.Plate.Topology.Contracts.Entities;
using FantaSim.Geosphere.Plate.Topology.Contracts.Events;
using FantaSim.Geosphere.Plate.Topology.Contracts.Identity;
using BoundaryEntity = FantaSim.Geosphere.Plate.Topology.Contracts.Entities.Boundary;
using JunctionEntity = FantaSim.Geosphere.Plate.Topology.Contracts.Entities.Junction;
using PlateEntity = FantaSim.Geosphere.Plate.Topology.Contracts.Entities.Plate;

namespace FantaSim.Geosphere.Plate.Topology.Materializer;

/// <summary>
/// Materializes PlateTopologyState by replaying events from ITopologyEventStore per FR-007.
///
/// The materializer reads events from the event store for a given truth stream and
/// applies them in order to build the current topology state. This enables deterministic
/// replay where the same event stream always produces identical state.
///
/// Per FR-007, materialization is event-only: no external data sources or solver
/// execution is required. All information needed to reconstruct state is contained
/// in the event stream.
///
/// Two cutoff modes are supported:
/// - Sequence-based: applies events up to a target sequence number (for deterministic replay)
/// - Tick-based: applies events where event.Tick &lt;= targetTick (for simulation time queries)
///
/// Tick-based materialization supports three modes via <see cref="TickMaterializationMode"/>:
/// - ScanAll: always correct, scans all events
/// - BreakOnFirstBeyondTick: fast but only safe for tick-monotone streams
/// - Auto: uses stream capabilities to choose the best mode
/// </summary>
public sealed class PlateTopologyMaterializer
{
    private readonly ITopologyEventStore _store;
    private readonly ITruthStreamCapabilities? _capabilities;

    /// <summary>
    /// Initializes a new instance of PlateTopologyMaterializer.
    /// </summary>
    /// <param name="store">The event store to read events from.</param>
    public PlateTopologyMaterializer(ITopologyEventStore store)
        : this(store, store as ITruthStreamCapabilities)
    {
    }

    /// <summary>
    /// Initializes a new instance of PlateTopologyMaterializer with explicit capabilities.
    /// </summary>
    /// <param name="store">The event store to read events from.</param>
    /// <param name="capabilities">
    /// Optional stream capabilities provider for tick-based optimization.
    /// If null, Auto mode behaves like ScanAll.
    /// </param>
    public PlateTopologyMaterializer(ITopologyEventStore store, ITruthStreamCapabilities? capabilities)
    {
        ArgumentNullException.ThrowIfNull(store);
        _store = store;
        _capabilities = capabilities;
    }

    /// <summary>
    /// Materializes the current topology state by replaying all events from the stream.
    ///
    /// Reads all events from the event store starting from sequence 0 and applies
    /// them in order to build the materialized state. This produces deterministic
    /// results: the same event stream always produces identical state (per SC-001).
    ///
    /// For empty streams, returns an empty state with LastEventSequence = -1 (per SC-008).
    /// </summary>
    /// <param name="stream">The truth stream identity to materialize.</param>
    /// <param name="cancellationToken">Token to cancel the operation.</param>
    /// <returns>
    /// The materialized topology state containing all plates, boundaries, and junctions.
    /// </returns>
    public async Task<PlateTopologyState> MaterializeAsync(
        TruthStreamIdentity stream,
        CancellationToken cancellationToken = default)
    {
        ArgumentNullException.ThrowIfNull(stream);

        var state = new PlateTopologyState(stream);

        await foreach (var evt in _store.ReadAsync(stream, 0, cancellationToken).ConfigureAwait(false))
        {
            ApplyEvent(state, evt);
        }

        state.RebuildIndices();

        return state;
    }

    /// <summary>
    /// Materializes topology state up to and including a target sequence number.
    ///
    /// This is the sequence-based cutoff: applies events where event.Sequence &lt;= targetSequence.
    /// Use this for deterministic replay or debugging specific event prefixes.
    /// </summary>
    /// <param name="stream">The truth stream identity to materialize.</param>
    /// <param name="targetSequence">The maximum sequence number to include (inclusive).</param>
    /// <param name="cancellationToken">Token to cancel the operation.</param>
    /// <returns>The materialized topology state.</returns>
    public async Task<PlateTopologyState> MaterializeAtSequenceAsync(
        TruthStreamIdentity stream,
        long targetSequence,
        CancellationToken cancellationToken = default)
    {
        ArgumentNullException.ThrowIfNull(stream);
        if (targetSequence < -1)
            throw new ArgumentOutOfRangeException(nameof(targetSequence), "Sequence must be >= -1");

        var state = new PlateTopologyState(stream);
        if (targetSequence < 0)
            return state;

        await foreach (var evt in _store.ReadAsync(stream, 0, cancellationToken).ConfigureAwait(false))
        {
            // Events are in sequence order, so we can break early
            if (evt.Sequence > targetSequence)
                break;

            ApplyEvent(state, evt);
        }

        state.RebuildIndices();

        return state;
    }

    /// <summary>
    /// Materializes topology state up to and including a target tick (simulation time).
    ///
    /// This is the tick-based cutoff: applies events where event.Tick &lt;= targetTick.
    /// Use this for "what did the world look like at tick X?" queries.
    ///
    /// The mode parameter controls iteration behavior:
    /// - ScanAll: Scans all events (always correct, but slower)
    /// - BreakOnFirstBeyondTick: Breaks early (fast, but only safe for monotone streams)
    /// - Auto: Queries stream capabilities and chooses the best mode
    ///
    /// When in doubt, use Auto (the default). It will only optimize when safe.
    /// </summary>
    /// <param name="stream">The truth stream identity to materialize.</param>
    /// <param name="targetTick">The maximum tick to include (inclusive).</param>
    /// <param name="mode">Controls iteration behavior. Default is Auto.</param>
    /// <param name="cancellationToken">Token to cancel the operation.</param>
    /// <returns>The materialized topology state containing entities at or before the target tick.</returns>
    public async Task<PlateTopologyState> MaterializeAtTickAsync(
        TruthStreamIdentity stream,
        CanonicalTick targetTick,
        TickMaterializationMode mode = TickMaterializationMode.Auto,
        CancellationToken cancellationToken = default)
    {
        ArgumentNullException.ThrowIfNull(stream);

        // Determine effective mode
        var effectiveMode = await ResolveEffectiveModeAsync(stream, mode, cancellationToken).ConfigureAwait(false);

        var state = new PlateTopologyState(stream);

        await foreach (var evt in _store.ReadAsync(stream, 0, cancellationToken).ConfigureAwait(false))
        {
            if (effectiveMode == TickMaterializationMode.BreakOnFirstBeyondTick)
            {
                // Fast path: break early (only safe for monotone streams)
                if (evt.Tick > targetTick)
                    break;

                ApplyEvent(state, evt);
            }
            else
            {
                // Safe path: scan all, filter by tick
                if (evt.Tick <= targetTick)
                {
                    ApplyEvent(state, evt);
                }
                // Continue scanning - later events may have earlier ticks
            }
        }

        state.RebuildIndices();

        return state;
    }

    /// <summary>
    /// Resolves the effective materialization mode based on stream capabilities.
    /// </summary>
    private async ValueTask<TickMaterializationMode> ResolveEffectiveModeAsync(
        TruthStreamIdentity stream,
        TickMaterializationMode requestedMode,
        CancellationToken cancellationToken)
    {
        // Explicit modes are used as-is
        if (requestedMode != TickMaterializationMode.Auto)
            return requestedMode;

        // Auto: check stream capabilities
        if (_capabilities == null)
        {
            Trace.WriteLineIf(
                DiagnosticSwitches.MaterializationOptimization.TraceInfo,
                $"[Materializer] Auto resolved to ScanAll for {stream} (no capabilities provider)");
            return TickMaterializationMode.ScanAll;
        }

        var isMonotone = await _capabilities.IsTickMonotoneFromGenesisAsync(stream, cancellationToken).ConfigureAwait(false);

        if (isMonotone)
        {
            Trace.WriteLineIf(
                DiagnosticSwitches.MaterializationOptimization.TraceInfo,
                $"[Materializer] Auto resolved to BreakOnFirstBeyondTick for {stream} (TickMonotoneFromGenesis=true)");
            return TickMaterializationMode.BreakOnFirstBeyondTick;
        }
        else
        {
            Trace.WriteLineIf(
                DiagnosticSwitches.MaterializationOptimization.TraceInfo,
                $"[Materializer] Auto resolved to ScanAll for {stream} (TickMonotoneFromGenesis=false)");
            return TickMaterializationMode.ScanAll;
        }
    }

    /// <summary>
    /// Incrementally materializes topology state from a snapshot up to a target tick.
    ///
    /// This is the key method for efficient "deep time" queries:
    /// 1. Load a nearby snapshot
    /// 2. Replay only the tail of events (seq > snapshot.LastEventSequence)
    /// 3. Filter by tick as usual
    ///
    /// The snapshot's LastEventSequence is used as the sequence boundary, NOT the tick.
    /// This is crucial because ticks may be non-monotone: an event appended at seq=11
    /// might have tick=900 even if the snapshot was at tick=1000 seq=10.
    /// By using sequence as the boundary, we don't miss "back-in-time" events.
    /// </summary>
    /// <param name="state">
    /// The state restored from a snapshot. This will be mutated in place.
    /// </param>
    /// <param name="targetTick">The maximum tick to include (inclusive).</param>
    /// <param name="mode">Controls iteration behavior. Default is Auto.</param>
    /// <param name="cancellationToken">Token to cancel the operation.</param>
    /// <returns>
    /// The same state instance, updated with events from snapshot through target tick.
    /// </returns>
    public async Task<PlateTopologyState> MaterializeIncrementallyAsync(
        PlateTopologyState state,
        CanonicalTick targetTick,
        TickMaterializationMode mode = TickMaterializationMode.Auto,
        CancellationToken cancellationToken = default)
    {
        ArgumentNullException.ThrowIfNull(state);

        var stream = state.Identity;
        var startSeq = state.LastEventSequence + 1;

        Trace.WriteLineIf(
            DiagnosticSwitches.MaterializationOptimization.TraceInfo,
            $"[Materializer] Incremental replay for {stream}: startSeq={startSeq}, targetTick={targetTick.Value}");

        // Determine effective mode for the tail (the snapshot prefix was already correct)
        var effectiveMode = await ResolveEffectiveModeAsync(stream, mode, cancellationToken).ConfigureAwait(false);

        await foreach (var evt in _store.ReadAsync(stream, startSeq, cancellationToken).ConfigureAwait(false))
        {
            if (effectiveMode == TickMaterializationMode.BreakOnFirstBeyondTick)
            {
                // Fast path: break early (only safe for monotone streams)
                if (evt.Tick > targetTick)
                    break;

                ApplyEvent(state, evt);
            }
            else
            {
                // Safe path: scan all, filter by tick
                if (evt.Tick <= targetTick)
                {
                    ApplyEvent(state, evt);
                }
                // Continue scanning - later events may have earlier ticks
            }
        }

        state.RebuildIndices();

        return state;
    }

    /// <summary>
    /// [OBSOLETE] Use MaterializeAtSequenceAsync or MaterializeAtTickAsync instead.
    /// This method is kept for backward compatibility but delegates to MaterializeAtSequenceAsync.
    /// </summary>
    [Obsolete("Use MaterializeAtSequenceAsync (for sequence cutoff) or MaterializeAtTickAsync (for tick cutoff) instead.")]
    public Task<PlateTopologyState> MaterializeAtTickAsync(
        TruthStreamIdentity stream,
        long tick,
        CancellationToken cancellationToken = default)
    {
        // Old behavior was sequence-based despite the name
        return MaterializeAtSequenceAsync(stream, tick, cancellationToken);
    }

    /// <summary>
    /// Materializes topology state from a specific sequence onwards.
    ///
    /// Useful for incremental updates or replaying from a checkpoint. Reads events
    /// starting from the specified sequence and applies them to build state.
    /// </summary>
    /// <param name="stream">The truth stream identity to materialize.</param>
    /// <param name="fromSequence">The starting sequence number (inclusive).</param>
    /// <param name="cancellationToken">Token to cancel the operation.</param>
    /// <returns>
    /// The materialized topology state from the specified sequence onwards.
    /// </returns>
    public async Task<PlateTopologyState> MaterializeFromAsync(
        TruthStreamIdentity stream,
        long fromSequence,
        CancellationToken cancellationToken = default)
    {
        ArgumentNullException.ThrowIfNull(stream);
        if (fromSequence < 0)
            throw new ArgumentOutOfRangeException(nameof(fromSequence), "Sequence must be non-negative");

        var state = new PlateTopologyState(stream);

        await foreach (var evt in _store.ReadAsync(stream, fromSequence, cancellationToken).ConfigureAwait(false))
        {
            ApplyEvent(state, evt);
        }

        state.RebuildIndices();

        return state;
    }

    /// <summary>
    /// Applies a single event to the materialized state.
    ///
    /// First validates the event against invariants, then applies it if valid.
    /// For invalid events, throws InvalidOperationException with clear error message.
    /// </summary>
    /// <param name="state">The state to update.</param>
    /// <param name="evt">The event to apply.</param>
    private static void ApplyEvent(PlateTopologyState state, IPlateTopologyEvent evt)
    {
        // Validate event against invariants (throws on violation)
        InvariantValidator.ValidateEvent(state, evt);

        // Apply the event to state
        switch (evt)
        {
            case PlateCreatedEvent plateCreated:
                ApplyPlateCreated(state, plateCreated);
                break;

            case PlateRetiredEvent plateRetired:
                ApplyPlateRetired(state, plateRetired);
                break;

            case BoundaryCreatedEvent boundaryCreated:
                ApplyBoundaryCreated(state, boundaryCreated);
                break;

            case BoundaryTypeChangedEvent boundaryTypeChanged:
                ApplyBoundaryTypeChanged(state, boundaryTypeChanged);
                break;

            case BoundaryGeometryUpdatedEvent boundaryGeometryUpdated:
                ApplyBoundaryGeometryUpdated(state, boundaryGeometryUpdated);
                break;

            case BoundaryRetiredEvent boundaryRetired:
                ApplyBoundaryRetired(state, boundaryRetired);
                break;

            case JunctionCreatedEvent junctionCreated:
                ApplyJunctionCreated(state, junctionCreated);
                break;

            case JunctionUpdatedEvent junctionUpdated:
                ApplyJunctionUpdated(state, junctionUpdated);
                break;

            case JunctionRetiredEvent junctionRetired:
                ApplyJunctionRetired(state, junctionRetired);
                break;

            default:
                state.Violations.Add(new InvariantViolation(
                    "UnknownEvent",
                    $"Unknown event type: {evt.EventType}",
                    evt.Sequence
                ));
                break;
        }

        state.SetLastEventSequence(evt.Sequence);
    }

    private static void ApplyPlateCreated(PlateTopologyState state, PlateCreatedEvent evt)
    {
        state.Plates[evt.PlateId] = new PlateEntity(evt.PlateId, false, null);
    }

    private static void ApplyPlateRetired(PlateTopologyState state, PlateRetiredEvent evt)
    {
        var plate = state.Plates[evt.PlateId];
        state.Plates[evt.PlateId] = plate with { IsRetired = true, RetirementReason = evt.Reason };
    }

    private static void ApplyBoundaryCreated(PlateTopologyState state, BoundaryCreatedEvent evt)
    {
        state.Boundaries[evt.BoundaryId] = new BoundaryEntity(
            evt.BoundaryId,
            evt.PlateIdLeft,
            evt.PlateIdRight,
            evt.BoundaryType,
            evt.Geometry,
            false,
            null
        );
    }

    private static void ApplyBoundaryTypeChanged(PlateTopologyState state, BoundaryTypeChangedEvent evt)
    {
        var boundary = state.Boundaries[evt.BoundaryId];
        state.Boundaries[evt.BoundaryId] = boundary with { BoundaryType = evt.NewType };
    }

    private static void ApplyBoundaryGeometryUpdated(PlateTopologyState state, BoundaryGeometryUpdatedEvent evt)
    {
        var boundary = state.Boundaries[evt.BoundaryId];
        state.Boundaries[evt.BoundaryId] = boundary with { Geometry = evt.NewGeometry };
    }

    private static void ApplyBoundaryRetired(PlateTopologyState state, BoundaryRetiredEvent evt)
    {
        var boundary = state.Boundaries[evt.BoundaryId];
        state.Boundaries[evt.BoundaryId] = boundary with { IsRetired = true, RetirementReason = evt.Reason };
    }

    private static void ApplyJunctionCreated(PlateTopologyState state, JunctionCreatedEvent evt)
    {
        state.Junctions[evt.JunctionId] = new JunctionEntity(
            evt.JunctionId,
            evt.BoundaryIds,
            evt.Location,
            false,
            null
        );
    }

    private static void ApplyJunctionUpdated(PlateTopologyState state, JunctionUpdatedEvent evt)
    {
        var junction = state.Junctions[evt.JunctionId];
        var updatedJunction = junction;

        if (!evt.NewBoundaryIds.IsDefaultOrEmpty)
        {
            updatedJunction = updatedJunction with { BoundaryIds = evt.NewBoundaryIds };
        }

        if (evt.NewLocation is not null)
        {
            updatedJunction = updatedJunction with { Location = evt.NewLocation.Value };
        }

        state.Junctions[evt.JunctionId] = updatedJunction;
    }

    private static void ApplyJunctionRetired(PlateTopologyState state, JunctionRetiredEvent evt)
    {
        var junction = state.Junctions[evt.JunctionId];
        state.Junctions[evt.JunctionId] = junction with { IsRetired = true, RetirementReason = evt.Reason };
    }
}


// --- PATH: plugins/Geosphere.Plate.Topology.Materializer/PlateTopologyState.cs ---
using FantaSim.Geosphere.Plate.Topology.Contracts.Derived;
using FantaSim.Geosphere.Plate.Topology.Contracts.Entities;
using BoundaryEntity = FantaSim.Geosphere.Plate.Topology.Contracts.Entities.Boundary;
using JunctionEntity = FantaSim.Geosphere.Plate.Topology.Contracts.Entities.Junction;
using PlateEntity = FantaSim.Geosphere.Plate.Topology.Contracts.Entities.Plate;
using FantaSim.Geosphere.Plate.Topology.Contracts.Identity;

namespace FantaSim.Geosphere.Plate.Topology.Materializer;

public sealed class PlateTopologyState : IPlateTopologyIndexedStateView
{
    public PlateTopologyState(TruthStreamIdentity identity)
    {
        ArgumentNullException.ThrowIfNull(identity);
        Identity = identity;
        LastEventSequence = -1;
        Indices = PlateTopologyIndicesBuilder.BuildPlateAdjacency(this);
    }

    public TruthStreamIdentity Identity { get; }

    public Dictionary<PlateId, PlateEntity> Plates { get; } = new();

    public Dictionary<BoundaryId, BoundaryEntity> Boundaries { get; } = new();

    public Dictionary<JunctionId, JunctionEntity> Junctions { get; } = new();

    public long LastEventSequence { get; private set; }

    public PlateTopologyIndices Indices { get; private set; }

    public List<InvariantViolation> Violations { get; } = new();

    internal void SetLastEventSequence(long sequence)
    {
        LastEventSequence = sequence;
    }

    internal void RebuildIndices()
    {
        Indices = PlateTopologyIndicesBuilder.BuildPlateAdjacency(this);
    }

    TruthStreamIdentity IPlateTopologyStateView.Identity => Identity;

    IReadOnlyDictionary<PlateId, PlateEntity> IPlateTopologyStateView.Plates => Plates;

    IReadOnlyDictionary<BoundaryId, BoundaryEntity> IPlateTopologyStateView.Boundaries => Boundaries;

    IReadOnlyDictionary<JunctionId, JunctionEntity> IPlateTopologyStateView.Junctions => Junctions;

    long IPlateTopologyStateView.LastEventSequence => LastEventSequence;
}


// --- PATH: plugins/Geosphere.Plate.Topology.Materializer/PlateTopologyTimeline.cs ---
using Plate.TimeDete.Time.Primitives;
using FantaSim.Geosphere.Plate.Topology.Contracts.Capabilities;
using FantaSim.Geosphere.Plate.Topology.Contracts.Derived;
using FantaSim.Geosphere.Plate.Topology.Contracts.Events;
using FantaSim.Geosphere.Plate.Topology.Contracts.Identity;

namespace FantaSim.Geosphere.Plate.Topology.Materializer;

/// <summary>
/// High-level facade for querying plate topology at specific points in time.
///
/// This is the recommended entry point for downstream consumers (e.g., Godot UI,
/// time sliders, simulation queries). It provides a clean API that hides the
/// complexity of snapshotting and caching.
///
/// Key methods:
/// - GetSliceAtTickAsync: Get topology state at a specific simulation tick
/// - GetLatestSliceAsync: Get the most recent topology state
/// - GetSliceAtSequenceAsync: Get topology state at a specific event sequence (for debugging)
/// </summary>
public sealed class PlateTopologyTimeline
{
    private readonly SnapshottingPlateTopologyMaterializer _materializer;

    /// <summary>
    /// Creates a timeline facade with snapshotting support.
    /// </summary>
    /// <param name="eventStore">The event store to read events from.</param>
    /// <param name="snapshotStore">The snapshot store for acceleration.</param>
    public PlateTopologyTimeline(
        ITopologyEventStore eventStore,
        IPlateTopologySnapshotStore snapshotStore)
    {
        ArgumentNullException.ThrowIfNull(eventStore);
        ArgumentNullException.ThrowIfNull(snapshotStore);

        _materializer = new SnapshottingPlateTopologyMaterializer(eventStore, snapshotStore);
    }

    /// <summary>
    /// Gets the topology state at a specific simulation tick.
    ///
    /// Returns the state containing all entities with tick <= targetTick.
    /// This is the correct method for "what did the world look like at tick X?" queries.
    /// </summary>
    /// <param name="stream">The truth stream identity.</param>
    /// <param name="targetTick">The target simulation tick.</param>
    /// <param name="mode">Tick materialization mode (default: Auto).</param>
    /// <param name="cancellationToken">Cancellation token.</param>
    /// <returns>A read-only view of the topology state at the target tick.</returns>
    public async Task<TimelineSlice> GetSliceAtTickAsync(
        TruthStreamIdentity stream,
        CanonicalTick targetTick,
        TickMaterializationMode mode = TickMaterializationMode.Auto,
        CancellationToken cancellationToken = default)
    {
        ArgumentNullException.ThrowIfNull(stream);

        var result = await _materializer.MaterializeAtTickAsync(stream, targetTick, mode, cancellationToken).ConfigureAwait(false);
        return new TimelineSlice(
            stream,
            targetTick,
            result.State,
            result.FromSnapshot);
    }

    /// <summary>
    /// Gets the latest (most recent) topology state.
    ///
    /// Equivalent to GetSliceAtTickAsync with CanonicalTick.MaxValue.
    /// </summary>
    /// <param name="stream">The truth stream identity.</param>
    /// <param name="cancellationToken">Cancellation token.</param>
    /// <returns>A read-only view of the latest topology state.</returns>
    public Task<TimelineSlice> GetLatestSliceAsync(
        TruthStreamIdentity stream,
        CancellationToken cancellationToken = default)
    {
        return GetSliceAtTickAsync(stream, CanonicalTick.MaxValue, TickMaterializationMode.Auto, cancellationToken);
    }

    /// <summary>
    /// Gets the topology state at a specific event sequence number.
    ///
    /// This is a debugging/replay method that uses sequence-based cutoff instead
    /// of tick-based cutoff. Use GetSliceAtTickAsync for simulation queries.
    /// </summary>
    /// <param name="stream">The truth stream identity.</param>
    /// <param name="targetSequence">The target sequence number.</param>
    /// <param name="cancellationToken">Cancellation token.</param>
    /// <returns>A read-only view of the topology state at the target sequence.</returns>
    public async Task<TimelineSlice> GetSliceAtSequenceAsync(
        TruthStreamIdentity stream,
        long targetSequence,
        CancellationToken cancellationToken = default)
    {
        ArgumentNullException.ThrowIfNull(stream);

        var result = await _materializer.MaterializeAtSequenceAsync(stream, targetSequence, cancellationToken).ConfigureAwait(false);

        // For sequence-based queries, use the sequence as the tick value in the slice
        var tick = new CanonicalTick(Math.Max(0, targetSequence));
        return new TimelineSlice(
            stream,
            tick,
            result.State,
            result.FromSnapshot);
    }

    /// <summary>
    /// Represents a topology slice at a specific point in time.
    /// </summary>
    /// <param name="Stream">The truth stream identity.</param>
    /// <param name="Tick">The tick at which this slice was materialized.</param>
    /// <param name="State">The topology state (read-only view recommended).</param>
    /// <param name="FromSnapshot">True if the slice was loaded from a snapshot.</param>
    public readonly record struct TimelineSlice(
        TruthStreamIdentity Stream,
        CanonicalTick Tick,
        IPlateTopologyIndexedStateView State,
        bool FromSnapshot);
}


// --- PATH: plugins/Geosphere.Plate.Topology.Materializer/SnapshottingPlateTopologyMaterializer.cs ---
using System.Linq;
using Plate.TimeDete.Time.Primitives;
using FantaSim.Geosphere.Plate.Topology.Contracts.Capabilities;
using FantaSim.Geosphere.Plate.Topology.Contracts.Derived;
using FantaSim.Geosphere.Plate.Topology.Contracts.Entities;
using FantaSim.Geosphere.Plate.Topology.Contracts.Events;
using FantaSim.Geosphere.Plate.Topology.Contracts.Identity;

namespace FantaSim.Geosphere.Plate.Topology.Materializer;

/// <summary>
/// A materializer that uses snapshots to accelerate replay.
///
/// Checks for existing snapshots before replaying events. If a snapshot exists
/// at or before the target tick, it loads the snapshot and replays only the
/// tail of events after the snapshot.
/// </summary>
public sealed class SnapshottingPlateTopologyMaterializer
{
    private readonly ITopologyEventStore _eventStore;
    private readonly IPlateTopologySnapshotStore _snapshotStore;
    private readonly PlateTopologyMaterializer _inner;

    public SnapshottingPlateTopologyMaterializer(
        ITopologyEventStore eventStore,
        IPlateTopologySnapshotStore snapshotStore)
    {
        ArgumentNullException.ThrowIfNull(eventStore);
        ArgumentNullException.ThrowIfNull(snapshotStore);

        _eventStore = eventStore;
        _snapshotStore = snapshotStore;
        _inner = new PlateTopologyMaterializer(eventStore);
    }

    /// <summary>
    /// Materializes topology state at a specific tick, using snapshots if available.
    /// </summary>
    /// <param name="stream">The truth stream identity.</param>
    /// <param name="targetTick">The target simulation tick.</param>
    /// <param name="mode">Tick materialization mode (default: Auto).</param>
    /// <param name="cancellationToken">Cancellation token.</param>
    /// <returns>The materialization result with snapshot hit indicator.</returns>
    public async Task<MaterializationResult> MaterializeAtTickAsync(
        TruthStreamIdentity stream,
        CanonicalTick targetTick,
        TickMaterializationMode mode = TickMaterializationMode.Auto,
        CancellationToken cancellationToken = default)
    {
        ArgumentNullException.ThrowIfNull(stream);

        // Query last sequence to include in cache key (correctness for back-in-time events)
        var currentHead = await _eventStore.GetLastSequenceAsync(stream, cancellationToken).ConfigureAwait(false);
        var lastSeq = currentHead ?? 0;
        var key = new PlateTopologyMaterializationKey(stream, targetTick.Value, lastSeq);

        // Try to find the latest snapshot at or before the target tick
        // This uses SeekForPrev internally for O(log n) lookup
        var snapshot = await _snapshotStore.GetLatestSnapshotBeforeAsync(stream, targetTick.Value, cancellationToken).ConfigureAwait(false);
        if (snapshot.HasValue)
        {
            // Load snapshot into state
            var stateFromSnapshot = FromSnapshot(snapshot.Value);

            // If we found an exact tick match, we can only skip tail replay if the snapshot
            // is also at the current head sequence. Otherwise, late-arriving events with
            // earlier/equal ticks (non-monotone streams) would be missed.
            if (snapshot.Value.Key.Tick == targetTick.Value)
            {
                var headSeq = await _eventStore.GetLastSequenceAsync(stream, cancellationToken).ConfigureAwait(false);
                if (headSeq.HasValue && headSeq.Value == snapshot.Value.LastEventSequence)
                {
                    return new MaterializationResult(key, stateFromSnapshot, true);
                }
            }

            // Incremental replay: use sequence boundary, not tick
            // This is crucial for non-monotone ticks: we don't miss "back-in-time" events
            var incrementalState = await _inner.MaterializeIncrementallyAsync(
                stateFromSnapshot,
                targetTick,
                mode,
                cancellationToken).ConfigureAwait(false);

            return new MaterializationResult(key, incrementalState, true);
        }

        // No usable snapshot - do full replay with tick-based cutoff
        var state = await _inner.MaterializeAtTickAsync(stream, targetTick, mode, cancellationToken).ConfigureAwait(false);

        // Save snapshot for "latest" queries (when targetTick is at or beyond head)
        var head = await _eventStore.GetLastSequenceAsync(stream, cancellationToken).ConfigureAwait(false);
        if (head.HasValue && state.LastEventSequence >= head.Value)
        {
            var toSave = ToSnapshot(new PlateTopologyMaterializationKey(stream, state.LastEventSequence, state.LastEventSequence), state);
            await _snapshotStore.SaveSnapshotAsync(toSave, cancellationToken).ConfigureAwait(false);
        }

        return new MaterializationResult(key, state, false);
    }

    /// <summary>
    /// Materializes topology state at a specific sequence, using snapshots if available.
    /// </summary>
    /// <param name="stream">The truth stream identity.</param>
    /// <param name="targetSequence">The target sequence number.</param>
    /// <param name="cancellationToken">Cancellation token.</param>
    /// <returns>The materialization result with snapshot hit indicator.</returns>
    public async Task<MaterializationResult> MaterializeAtSequenceAsync(
        TruthStreamIdentity stream,
        long targetSequence,
        CancellationToken cancellationToken = default)
    {
        ArgumentNullException.ThrowIfNull(stream);

        // Query last sequence to include in cache key
        var currentHead = await _eventStore.GetLastSequenceAsync(stream, cancellationToken).ConfigureAwait(false);
        var lastSeq = currentHead ?? 0;
        var key = new PlateTopologyMaterializationKey(stream, targetSequence, lastSeq);

        var snapshot = await _snapshotStore.GetSnapshotAsync(key, cancellationToken).ConfigureAwait(false);
        if (snapshot.HasValue)
        {
            var stateFromSnapshot = FromSnapshot(snapshot.Value);
            return new MaterializationResult(key, stateFromSnapshot, true);
        }

        var state = await _inner.MaterializeAtSequenceAsync(stream, targetSequence, cancellationToken).ConfigureAwait(false);

        // Save snapshot for "latest" queries
        var head = await _eventStore.GetLastSequenceAsync(stream, cancellationToken).ConfigureAwait(false);
        if (head.HasValue && targetSequence >= head.Value)
        {
            var toSave = ToSnapshot(new PlateTopologyMaterializationKey(stream, head.Value, head.Value), state);
            await _snapshotStore.SaveSnapshotAsync(toSave, cancellationToken).ConfigureAwait(false);
        }

        return new MaterializationResult(key, state, false);
    }

    /// <summary>
    /// [OBSOLETE] Use MaterializeAtTickAsync(stream, CanonicalTick) or MaterializeAtSequenceAsync instead.
    /// </summary>
    [Obsolete("Use MaterializeAtTickAsync(stream, CanonicalTick) or MaterializeAtSequenceAsync instead.")]
    public Task<MaterializationResult> MaterializeAtTickAsync(
        TruthStreamIdentity stream,
        long tick,
        CancellationToken cancellationToken = default)
    {
        // Old behavior was sequence-based
        return MaterializeAtSequenceAsync(stream, tick, cancellationToken);
    }

    private static PlateTopologyState FromSnapshot(PlateTopologySnapshot snapshot)
    {
        var state = new PlateTopologyState(snapshot.Key.Stream);

        foreach (var plate in snapshot.Plates)
        {
            state.Plates[plate.PlateId] = plate;
        }

        foreach (var boundary in snapshot.Boundaries)
        {
            state.Boundaries[boundary.BoundaryId] = boundary;
        }

        foreach (var junction in snapshot.Junctions)
        {
            state.Junctions[junction.JunctionId] = junction;
        }

        state.SetLastEventSequence(snapshot.LastEventSequence);

        state.RebuildIndices();
        return state;
    }

    private static PlateTopologySnapshot ToSnapshot(PlateTopologyMaterializationKey key, PlateTopologyState state)
    {
        var plates = state.Plates.Values.OrderBy(p => p.PlateId.Value, GuidOrdering.Rfc4122Comparer).ToArray();
        var boundaries = state.Boundaries.Values.OrderBy(b => b.BoundaryId.Value, GuidOrdering.Rfc4122Comparer).ToArray();
        var junctions = state.Junctions.Values.OrderBy(j => j.JunctionId.Value, GuidOrdering.Rfc4122Comparer).ToArray();

        return new PlateTopologySnapshot(
            key,
            state.LastEventSequence,
            plates,
            boundaries,
            junctions);
    }

    public readonly record struct MaterializationResult(
        PlateTopologyMaterializationKey Key,
        PlateTopologyState State,
        bool FromSnapshot);
}


// --- PATH: plugins/Geosphere.Plate.Topology.Materializer/TopologyMaterializerPlugin.cs ---
﻿using System;
using System.Threading;
using System.Threading.Tasks;
using FantaSim.Geosphere.Plate.Topology.Contracts.Derived;
using FantaSim.Geosphere.Plate.Topology.Contracts.Events;
using Microsoft.Extensions.DependencyInjection;
using PluginArchi.Extensibility.Abstractions;
using ServiceArchi.Contracts;
using UnifyStorage.Abstractions;

namespace FantaSim.Geosphere.Plate.Topology.Materializer;

/// <summary>
/// Plugin entry point for the Topology Materializer.
///
/// Registers:
/// - ITopologyEventStore: Event persistence and replay
/// - IPlateTopologySnapshotStore: Snapshot persistence
/// - IPlateTopologyStateView: Read-only state views
/// - PlateTopologyTimeline: Timeline management
/// </summary>
[Plugin("fantasim.geosphere.plate.topology.materializer", Name = "Plate Topology Materializer", Tags = "geosphere,topology,materializer,persistence")]
public sealed class TopologyMaterializerPlugin : ILifecyclePlugin
{
    private IRegistry? _registry;
    private PlateTopologyEventStore? _eventStore;
    private PlateTopologyTimeline? _timeline;

    public IPluginDescriptor Descriptor { get; } = new PluginDescriptor
    {
        Id = "fantasim.geosphere.plate.topology.materializer",
        Name = "Plate Topology Materializer",
        Description = "Persistence and materialization layer for Plate Topology truth events.",
        Tags = new[] { "geosphere", "topology", "materializer", "persistence" },
        Version = new Version(1, 0, 0)
    };

    public ValueTask InitializeAsync(IPluginContext context, CancellationToken ct = default)
    {
        // 1. Resolve the ServiceArchi Registry from the host context
        var registry = context.Services.GetService<IRegistry>();
        if (registry == null)
        {
            return ValueTask.CompletedTask;
        }

        _registry = registry;

        // 2. Resolve the key-value store dependency
        var kvStore = context.Services.GetService<IKeyValueStore>();
        if (kvStore == null)
        {
            // KV store not available yet - this plugin may need to be initialized later
            return ValueTask.CompletedTask;
        }

        // 3. Create and register the event store
        _eventStore = new PlateTopologyEventStore(kvStore);
        registry.Register<ITopologyEventStore>(_eventStore);
        registry.Register<IPlateTopologySnapshotStore>(_eventStore);

        // 4. Create and register the timeline (event store implements both required interfaces)
        _timeline = new PlateTopologyTimeline(_eventStore, _eventStore);
        registry.Register<PlateTopologyTimeline>(_timeline);

        return ValueTask.CompletedTask;
    }

    public ValueTask ShutdownAsync(CancellationToken ct = default)
    {
        _registry?.UnregisterAll<PlateTopologyTimeline>();
        _registry?.UnregisterAll<IPlateTopologySnapshotStore>();
        _registry?.UnregisterAll<ITopologyEventStore>();

        _timeline = null;
        _eventStore?.Dispose();
        _eventStore = null;
        _registry = null;

        return ValueTask.CompletedTask;
    }
}


// --- PATH: plugins/Geosphere.Plate.Topology.Serializers/EventHasher.cs ---
﻿using System;
using System.Buffers;
using System.Security.Cryptography;
using MessagePack;
using Plate.TimeDete.Time.Primitives;
using FantaSim.Geosphere.Plate.Topology.Contracts.Events;
using FantaSim.Geosphere.Plate.Topology.Contracts.Identity;

namespace FantaSim.Geosphere.Plate.Topology.Serializers;

/// <summary>
/// Interface for computing cryptographic hashes of events.
/// Used to establish a hash-chain across events in a stream.
/// </summary>
public interface IEventHasher
{
    /// <summary>
    /// Computes the hash of a canonical preimage byte array.
    /// </summary>
    /// <param name="preimageBytes">The canonical bytes to hash.</param>
    /// <returns>The hash as a byte array (32 bytes for SHA-256).</returns>
    byte[] Hash(ReadOnlySpan<byte> preimageBytes);

    /// <summary>
    /// Computes the hash of an event given its components.
    /// The hash preimage includes: Tick, StreamIdentity, PreviousHash, and payload bytes.
    /// The Hash field itself is NOT included (would be circular).
    /// </summary>
    /// <param name="tick">The canonical simulation tick.</param>
    /// <param name="streamIdentity">The truth stream identity.</param>
    /// <param name="previousHash">The hash of the previous event (empty for genesis).</param>
    /// <param name="payloadBytes">The MessagePack-encoded payload bytes.</param>
    /// <returns>The computed hash (32 bytes).</returns>
    byte[] ComputeEventHash(
        CanonicalTick tick,
        TruthStreamIdentity streamIdentity,
        ReadOnlyMemory<byte> previousHash,
        ReadOnlySpan<byte> payloadBytes);
}

/// <summary>
/// Interface for serializing events to canonical bytes.
/// Separates concerns: ICanonicalEventSerializer handles encoding, IEventHasher handles hashing.
/// </summary>
public interface ICanonicalEventSerializer
{
    /// <summary>
    /// Serializes an event to canonical bytes for persistence.
    /// Includes ALL fields: Tick, Sequence, StreamIdentity, PreviousHash, Hash, and payload.
    /// </summary>
    /// <param name="event">The event to serialize.</param>
    /// <returns>Canonical MessagePack bytes.</returns>
    byte[] SerializeCanonical(IPlateTopologyEvent @event);

    /// <summary>
    /// Serializes an event to canonical bytes for hashing.
    /// EXCLUDES the Hash field (to avoid circular dependency).
    /// Includes: Tick, StreamIdentity, PreviousHash, and event-specific payload.
    ///
    /// Hash preimage structure (MessagePack array):
    /// [0] Tick (Int64)
    /// [1] StreamIdentity (array of 5 elements)
    /// [2] PreviousHash (binary, empty for genesis)
    /// [3] PayloadBytes (binary, event-specific fields)
    /// </summary>
    /// <param name="event">The event to serialize for hashing.</param>
    /// <returns>Canonical preimage bytes (Hash field NOT included).</returns>
    byte[] SerializeCanonicalForHash(IPlateTopologyEvent @event);
}

/// <summary>
/// Default implementation of ICanonicalEventSerializer.
/// Uses MessagePack for canonical encoding.
/// </summary>
public sealed class CanonicalEventSerializer : ICanonicalEventSerializer
{
    /// <summary>
    /// Shared instance for convenience.
    /// </summary>
    public static readonly CanonicalEventSerializer Instance = new();

    /// <inheritdoc/>
    public byte[] SerializeCanonical(IPlateTopologyEvent @event)
    {
        // Use MessagePack to serialize the full event
        // This delegates to the event's own formatter which includes all fields
        return MessagePackSerializer.Serialize(@event);
    }

    /// <inheritdoc/>
    public byte[] SerializeCanonicalForHash(IPlateTopologyEvent @event)
    {
        // Build the preimage: [Tick, StreamIdentity, PreviousHash, PayloadBytes]
        // NOTE: Hash field is intentionally EXCLUDED to avoid circular dependency
        var buffer = new ArrayBufferWriter<byte>();
        var writer = new MessagePackWriter(buffer);

        // Write array header for 4 elements
        writer.WriteArrayHeader(4);

        // 1. Tick (as raw Int64)
        writer.Write(@event.Tick.Value);

        // 2. StreamIdentity (as array of 5 elements)
        writer.WriteArrayHeader(5);
        writer.Write(@event.StreamIdentity.VariantId);
        writer.Write(@event.StreamIdentity.BranchId);
        writer.Write(@event.StreamIdentity.LLevel);
        writer.Write(@event.StreamIdentity.Domain.Value);
        writer.Write(@event.StreamIdentity.Model);

        // 3. PreviousHash (as binary)
        if (@event.PreviousHash.IsEmpty)
        {
            writer.Write(ReadOnlySpan<byte>.Empty);
        }
        else
        {
            writer.Write(@event.PreviousHash.Span);
        }

        // 4. PayloadBytes (as binary - the event-specific data)
        var payloadBytes = EventPayloadSerializer.GetPayloadBytes(@event);
        writer.Write(payloadBytes);

        writer.Flush();

        return buffer.WrittenMemory.ToArray();
    }
}

/// <summary>
/// Serializes event-specific payload bytes for hash computation.
/// This is shared between CanonicalEventSerializer and EventChainBuilder.
/// </summary>
public static class EventPayloadSerializer
{
    /// <summary>
    /// Gets the payload bytes for an event (event-specific fields only, not envelope fields).
    /// </summary>
    public static byte[] GetPayloadBytes(IPlateTopologyEvent @event)
    {
        return @event switch
        {
            PlateCreatedEvent e => GetPayloadBytes(e),
            PlateRetiredEvent e => GetPayloadBytes(e),
            BoundaryCreatedEvent e => GetPayloadBytes(e),
            BoundaryTypeChangedEvent e => GetPayloadBytes(e),
            BoundaryGeometryUpdatedEvent e => GetPayloadBytes(e),
            BoundaryRetiredEvent e => GetPayloadBytes(e),
            JunctionCreatedEvent e => GetPayloadBytes(e),
            JunctionUpdatedEvent e => GetPayloadBytes(e),
            JunctionRetiredEvent e => GetPayloadBytes(e),
            _ => throw new ArgumentException($"Unknown event type: {@event.GetType().Name}", nameof(@event))
        };
    }

    /// <summary>
    /// Gets the payload bytes for a PlateCreatedEvent.
    /// </summary>
    public static byte[] GetPayloadBytes(PlateCreatedEvent @event)
    {
        var buffer = new ArrayBufferWriter<byte>();
        var writer = new MessagePackWriter(buffer);
        writer.WriteArrayHeader(2);
        writer.Write(@event.EventId.ToString());
        writer.Write(@event.PlateId.Value.ToString());
        writer.Flush();
        return buffer.WrittenMemory.ToArray();
    }

    /// <summary>
    /// Gets the payload bytes for a PlateRetiredEvent.
    /// </summary>
    public static byte[] GetPayloadBytes(PlateRetiredEvent @event)
    {
        var buffer = new ArrayBufferWriter<byte>();
        var writer = new MessagePackWriter(buffer);
        writer.WriteArrayHeader(3);
        writer.Write(@event.EventId.ToString());
        writer.Write(@event.PlateId.Value.ToString());
        writer.Write(@event.Reason);
        writer.Flush();
        return buffer.WrittenMemory.ToArray();
    }

    /// <summary>
    /// Gets the payload bytes for a BoundaryCreatedEvent.
    /// </summary>
    public static byte[] GetPayloadBytes(BoundaryCreatedEvent @event)
    {
        var buffer = new ArrayBufferWriter<byte>();
        var writer = new MessagePackWriter(buffer);
        writer.WriteArrayHeader(5);
        writer.Write(@event.EventId.ToString());
        writer.Write(@event.BoundaryId.Value.ToString());
        writer.Write(@event.PlateIdLeft.Value.ToString());
        writer.Write(@event.PlateIdRight.Value.ToString());
        writer.Write((byte)@event.BoundaryType);
        // Note: Geometry is not included in payload hash to keep it simple for now
        // In a full implementation, you'd serialize the geometry deterministically
        writer.Flush();
        return buffer.WrittenMemory.ToArray();
    }

    /// <summary>
    /// Gets the payload bytes for a BoundaryTypeChangedEvent.
    /// </summary>
    public static byte[] GetPayloadBytes(BoundaryTypeChangedEvent @event)
    {
        var buffer = new ArrayBufferWriter<byte>();
        var writer = new MessagePackWriter(buffer);
        writer.WriteArrayHeader(4);
        writer.Write(@event.EventId.ToString());
        writer.Write(@event.BoundaryId.Value.ToString());
        writer.Write((byte)@event.OldType);
        writer.Write((byte)@event.NewType);
        writer.Flush();
        return buffer.WrittenMemory.ToArray();
    }

    /// <summary>
    /// Gets the payload bytes for a BoundaryGeometryUpdatedEvent.
    /// </summary>
    public static byte[] GetPayloadBytes(BoundaryGeometryUpdatedEvent @event)
    {
        var buffer = new ArrayBufferWriter<byte>();
        var writer = new MessagePackWriter(buffer);
        writer.WriteArrayHeader(2);
        writer.Write(@event.EventId.ToString());
        writer.Write(@event.BoundaryId.Value.ToString());
        // Note: Geometry is not included in payload hash to keep it simple for now
        writer.Flush();
        return buffer.WrittenMemory.ToArray();
    }

    /// <summary>
    /// Gets the payload bytes for a BoundaryRetiredEvent.
    /// </summary>
    public static byte[] GetPayloadBytes(BoundaryRetiredEvent @event)
    {
        var buffer = new ArrayBufferWriter<byte>();
        var writer = new MessagePackWriter(buffer);
        writer.WriteArrayHeader(3);
        writer.Write(@event.EventId.ToString());
        writer.Write(@event.BoundaryId.Value.ToString());
        writer.Write(@event.Reason);
        writer.Flush();
        return buffer.WrittenMemory.ToArray();
    }

    /// <summary>
    /// Gets the payload bytes for a JunctionCreatedEvent.
    /// </summary>
    public static byte[] GetPayloadBytes(JunctionCreatedEvent @event)
    {
        var buffer = new ArrayBufferWriter<byte>();
        var writer = new MessagePackWriter(buffer);
        writer.WriteArrayHeader(6); // EventId, JunctionId, BoundaryIds, Normal(X,Y,Z), Radius
        writer.Write(@event.EventId.ToString());
        writer.Write(@event.JunctionId.Value.ToString());
        writer.WriteArrayHeader(@event.BoundaryIds.Length);
        foreach (var boundaryId in @event.BoundaryIds)
        {
            writer.Write(boundaryId.Value.ToString());
        }
        // SurfacePoint: Normal (UnitVector3d) + Radius
        writer.Write(@event.Location.Normal.X);
        writer.Write(@event.Location.Normal.Y);
        writer.Write(@event.Location.Normal.Z);
        writer.Write(@event.Location.Radius);
        writer.Flush();
        return buffer.WrittenMemory.ToArray();
    }

    /// <summary>
    /// Gets the payload bytes for a JunctionUpdatedEvent.
    /// </summary>
    public static byte[] GetPayloadBytes(JunctionUpdatedEvent @event)
    {
        var buffer = new ArrayBufferWriter<byte>();
        var writer = new MessagePackWriter(buffer);
        writer.WriteArrayHeader(6); // EventId, JunctionId, BoundaryIds, Normal(X,Y,Z) or NaN, Radius or NaN
        writer.Write(@event.EventId.ToString());
        writer.Write(@event.JunctionId.Value.ToString());
        writer.WriteArrayHeader(@event.NewBoundaryIds.Length);
        foreach (var boundaryId in @event.NewBoundaryIds)
        {
            writer.Write(boundaryId.Value.ToString());
        }
        // SurfacePoint: Normal (UnitVector3d) + Radius (or NaN if null)
        if (@event.NewLocation.HasValue)
        {
            writer.Write(@event.NewLocation.Value.Normal.X);
            writer.Write(@event.NewLocation.Value.Normal.Y);
            writer.Write(@event.NewLocation.Value.Normal.Z);
            writer.Write(@event.NewLocation.Value.Radius);
        }
        else
        {
            writer.Write(double.NaN);
            writer.Write(double.NaN);
            writer.Write(double.NaN);
            writer.Write(double.NaN);
        }
        writer.Flush();
        return buffer.WrittenMemory.ToArray();
    }

    /// <summary>
    /// Gets the payload bytes for a JunctionRetiredEvent.
    /// </summary>
    public static byte[] GetPayloadBytes(JunctionRetiredEvent @event)
    {
        var buffer = new ArrayBufferWriter<byte>();
        var writer = new MessagePackWriter(buffer);
        writer.WriteArrayHeader(3);
        writer.Write(@event.EventId.ToString());
        writer.Write(@event.JunctionId.Value.ToString());
        writer.Write(@event.Reason);
        writer.Flush();
        return buffer.WrittenMemory.ToArray();
    }
}

/// <summary>
/// SHA-256 implementation of IEventHasher.
/// Computes hashes using the SHA-256 algorithm (32 bytes output).
/// </summary>
public sealed class Sha256EventHasher : IEventHasher
{
    /// <summary>
    /// Shared instance for convenience.
    /// </summary>
    public static readonly Sha256EventHasher Instance = new();

    /// <inheritdoc/>
    public byte[] Hash(ReadOnlySpan<byte> preimageBytes)
    {
        return SHA256.HashData(preimageBytes);
    }

    /// <inheritdoc/>
    public byte[] ComputeEventHash(
        CanonicalTick tick,
        TruthStreamIdentity streamIdentity,
        ReadOnlyMemory<byte> previousHash,
        ReadOnlySpan<byte> payloadBytes)
    {
        // Build the preimage: [Tick, StreamIdentity, PreviousHash, PayloadBytes]
        // We use MessagePack to ensure deterministic encoding
        var buffer = new ArrayBufferWriter<byte>();
        var writer = new MessagePackWriter(buffer);

        // Write array header for 4 elements
        writer.WriteArrayHeader(4);

        // 1. Tick (as raw Int64)
        writer.Write(tick.Value);

        // 2. StreamIdentity (as array of 5 elements)
        writer.WriteArrayHeader(5);
        writer.Write(streamIdentity.VariantId);
        writer.Write(streamIdentity.BranchId);
        writer.Write(streamIdentity.LLevel);
        writer.Write(streamIdentity.Domain.Value);
        writer.Write(streamIdentity.Model);

        // 3. PreviousHash (as binary)
        if (previousHash.IsEmpty)
        {
            writer.Write(ReadOnlySpan<byte>.Empty);
        }
        else
        {
            writer.Write(previousHash.Span);
        }

        // 4. PayloadBytes (as binary - the actual event-specific data)
        writer.Write(payloadBytes);

        writer.Flush();

        // Hash the preimage
        return SHA256.HashData(buffer.WrittenSpan);
    }
}

/// <summary>
/// Utility class for building event chains with proper hash computation.
/// </summary>
public static class EventChainBuilder
{
    private static readonly IEventHasher DefaultHasher = Sha256EventHasher.Instance;

    /// <summary>
    /// Computes the hash for an event and returns a new event with the hash set.
    /// </summary>
    /// <typeparam name="T">The event type.</typeparam>
    /// <param name="event">The event to hash (PreviousHash should already be set).</param>
    /// <param name="hasher">Optional hasher (defaults to SHA-256).</param>
    /// <returns>A new event with the computed Hash.</returns>
    public static PlateCreatedEvent WithComputedHash(
        this PlateCreatedEvent @event,
        IEventHasher? hasher = null)
    {
        hasher ??= DefaultHasher;
        var payloadBytes = EventPayloadSerializer.GetPayloadBytes(@event);
        var hash = hasher.ComputeEventHash(@event.Tick, @event.StreamIdentity, @event.PreviousHash, payloadBytes);
        return @event with { Hash = hash };
    }

    /// <summary>
    /// Computes the hash for an event and returns a new event with the hash set.
    /// </summary>
    public static PlateRetiredEvent WithComputedHash(
        this PlateRetiredEvent @event,
        IEventHasher? hasher = null)
    {
        hasher ??= DefaultHasher;
        var payloadBytes = EventPayloadSerializer.GetPayloadBytes(@event);
        var hash = hasher.ComputeEventHash(@event.Tick, @event.StreamIdentity, @event.PreviousHash, payloadBytes);
        return @event with { Hash = hash };
    }

    /// <summary>
    /// Computes the hash for an event and returns a new event with the hash set.
    /// </summary>
    public static BoundaryCreatedEvent WithComputedHash(
        this BoundaryCreatedEvent @event,
        IEventHasher? hasher = null)
    {
        hasher ??= DefaultHasher;
        var payloadBytes = EventPayloadSerializer.GetPayloadBytes(@event);
        var hash = hasher.ComputeEventHash(@event.Tick, @event.StreamIdentity, @event.PreviousHash, payloadBytes);
        return @event with { Hash = hash };
    }

    /// <summary>
    /// Computes the hash for an event and returns a new event with the hash set.
    /// </summary>
    public static BoundaryTypeChangedEvent WithComputedHash(
        this BoundaryTypeChangedEvent @event,
        IEventHasher? hasher = null)
    {
        hasher ??= DefaultHasher;
        var payloadBytes = EventPayloadSerializer.GetPayloadBytes(@event);
        var hash = hasher.ComputeEventHash(@event.Tick, @event.StreamIdentity, @event.PreviousHash, payloadBytes);
        return @event with { Hash = hash };
    }

    /// <summary>
    /// Computes the hash for an event and returns a new event with the hash set.
    /// </summary>
    public static BoundaryGeometryUpdatedEvent WithComputedHash(
        this BoundaryGeometryUpdatedEvent @event,
        IEventHasher? hasher = null)
    {
        hasher ??= DefaultHasher;
        var payloadBytes = EventPayloadSerializer.GetPayloadBytes(@event);
        var hash = hasher.ComputeEventHash(@event.Tick, @event.StreamIdentity, @event.PreviousHash, payloadBytes);
        return @event with { Hash = hash };
    }

    /// <summary>
    /// Computes the hash for an event and returns a new event with the hash set.
    /// </summary>
    public static BoundaryRetiredEvent WithComputedHash(
        this BoundaryRetiredEvent @event,
        IEventHasher? hasher = null)
    {
        hasher ??= DefaultHasher;
        var payloadBytes = EventPayloadSerializer.GetPayloadBytes(@event);
        var hash = hasher.ComputeEventHash(@event.Tick, @event.StreamIdentity, @event.PreviousHash, payloadBytes);
        return @event with { Hash = hash };
    }

    /// <summary>
    /// Computes the hash for an event and returns a new event with the hash set.
    /// </summary>
    public static JunctionCreatedEvent WithComputedHash(
        this JunctionCreatedEvent @event,
        IEventHasher? hasher = null)
    {
        hasher ??= DefaultHasher;
        var payloadBytes = EventPayloadSerializer.GetPayloadBytes(@event);
        var hash = hasher.ComputeEventHash(@event.Tick, @event.StreamIdentity, @event.PreviousHash, payloadBytes);
        return @event with { Hash = hash };
    }

    /// <summary>
    /// Computes the hash for an event and returns a new event with the hash set.
    /// </summary>
    public static JunctionUpdatedEvent WithComputedHash(
        this JunctionUpdatedEvent @event,
        IEventHasher? hasher = null)
    {
        hasher ??= DefaultHasher;
        var payloadBytes = EventPayloadSerializer.GetPayloadBytes(@event);
        var hash = hasher.ComputeEventHash(@event.Tick, @event.StreamIdentity, @event.PreviousHash, payloadBytes);
        return @event with { Hash = hash };
    }

    /// <summary>
    /// Computes the hash for an event and returns a new event with the hash set.
    /// </summary>
    public static JunctionRetiredEvent WithComputedHash(
        this JunctionRetiredEvent @event,
        IEventHasher? hasher = null)
    {
        hasher ??= DefaultHasher;
        var payloadBytes = EventPayloadSerializer.GetPayloadBytes(@event);
        var hash = hasher.ComputeEventHash(@event.Tick, @event.StreamIdentity, @event.PreviousHash, payloadBytes);
        return @event with { Hash = hash };
    }
}

/// <summary>
/// Validates hash chains in event streams.
/// </summary>
public static class EventChainValidator
{
    /// <summary>
    /// Validates that a sequence of events forms a valid hash chain.
    /// </summary>
    /// <param name="events">The events to validate.</param>
    /// <returns>True if the chain is valid; false otherwise.</returns>
    public static bool ValidateChain(ReadOnlySpan<IPlateTopologyEvent> events)
    {
        if (events.Length == 0)
            return true;

        // Genesis event: PreviousHash should be empty
        if (!events[0].PreviousHash.IsEmpty)
            return false;

        // Each subsequent event's PreviousHash must match the previous event's Hash
        for (int i = 1; i < events.Length; i++)
        {
            var prevHash = events[i - 1].Hash;
            var currPrevHash = events[i].PreviousHash;

            if (!prevHash.Span.SequenceEqual(currPrevHash.Span))
                return false;
        }

        return true;
    }

    /// <summary>
    /// Validates that a sequence of events forms a valid hash chain.
    /// </summary>
    /// <param name="events">The events to validate.</param>
    /// <returns>True if the chain is valid; false otherwise.</returns>
    public static bool ValidateChain(IReadOnlyList<IPlateTopologyEvent> events)
    {
        if (events.Count == 0)
            return true;

        // Genesis event: PreviousHash should be empty
        if (!events[0].PreviousHash.IsEmpty)
            return false;

        // Each subsequent event's PreviousHash must match the previous event's Hash
        for (int i = 1; i < events.Count; i++)
        {
            var prevHash = events[i - 1].Hash;
            var currPrevHash = events[i].PreviousHash;

            if (!prevHash.Span.SequenceEqual(currPrevHash.Span))
                return false;
        }

        return true;
    }

    /// <summary>
    /// Gets the hash of the last event in the chain (for use as PreviousHash of next event).
    /// </summary>
    /// <param name="events">The events.</param>
    /// <returns>The hash of the last event, or empty if no events.</returns>
    public static ReadOnlyMemory<byte> GetLastHash(IReadOnlyList<IPlateTopologyEvent> events)
    {
        if (events.Count == 0)
            return ReadOnlyMemory<byte>.Empty;

        return events[^1].Hash;
    }
}


// --- PATH: plugins/Geosphere.Plate.Topology.Serializers/Formatters/BoundaryIdFormatter.cs ---
using System;
using MessagePack;
using MessagePack.Formatters;
using FantaSim.Geosphere.Plate.Topology.Contracts.Entities;

namespace FantaSim.Geosphere.Plate.Topology.Serializers.Formatters;

/// <summary>
/// Custom MessagePack formatter for BoundaryId.
/// Encoded as raw Guid (binary).
/// </summary>
internal class BoundaryIdFormatter : IMessagePackFormatter<BoundaryId>
{
    public void Serialize(ref MessagePackWriter writer, BoundaryId value, MessagePackSerializerOptions options)
    {
        options.Resolver.GetFormatterWithVerify<Guid>().Serialize(ref writer, value.Value, options);
    }

    public BoundaryId Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
    {
        var guid = options.Resolver.GetFormatterWithVerify<Guid>().Deserialize(ref reader, options);
        return new BoundaryId(guid);
    }
}


// --- PATH: plugins/Geosphere.Plate.Topology.Serializers/Formatters/CanonicalTickFormatter.cs ---
using System;
using MessagePack;
using MessagePack.Formatters;
using Plate.TimeDete.Time.Primitives;

namespace FantaSim.Geosphere.Plate.Topology.Serializers.Formatters;

/// <summary>
/// Custom MessagePack formatter for CanonicalTick.
/// Per RFC-V2-0010 and RFC-V2-0005, CanonicalTick is encoded as raw Int64.
/// </summary>
internal class CanonicalTickFormatter : IMessagePackFormatter<CanonicalTick>
{
    public void Serialize(ref MessagePackWriter writer, CanonicalTick value, MessagePackSerializerOptions options)
    {
        writer.Write(value.Value);
    }

    public CanonicalTick Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
    {
        var tickValue = reader.ReadInt64();
        return new CanonicalTick(tickValue);
    }
}


// --- PATH: plugins/Geosphere.Plate.Topology.Serializers/Formatters/DomainFormatter.cs ---
using System;
using MessagePack;
using MessagePack.Formatters;
using FantaSim.Geosphere.Plate.Topology.Contracts.Identity;

namespace FantaSim.Geosphere.Plate.Topology.Serializers.Formatters;

/// <summary>
/// Custom MessagePack formatter for Domain type.
/// Domain has a private constructor which requires custom serialization.
/// </summary>
internal class DomainFormatter : IMessagePackFormatter<Domain>
{
    public void Serialize(ref MessagePackWriter writer, Domain value, MessagePackSerializerOptions options)
    {
        writer.Write(value.Value);
    }

    public Domain Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
    {
        var strValue = reader.ReadString();
        if (strValue == null)
            throw new InvalidOperationException("Domain value cannot be null");
        return Domain.Parse(strValue);
    }
}


// --- PATH: plugins/Geosphere.Plate.Topology.Serializers/Formatters/EventIdFormatter.cs ---
using System;
using MessagePack;
using MessagePack.Formatters;
using FantaSim.Geosphere.Plate.Topology.Contracts.Events;

namespace FantaSim.Geosphere.Plate.Topology.Serializers.Formatters;

/// <summary>
/// Custom MessagePack formatter for EventId.
/// Encoded as raw Guid (binary).
/// </summary>
internal class EventIdFormatter : IMessagePackFormatter<EventId>
{
    public void Serialize(ref MessagePackWriter writer, EventId value, MessagePackSerializerOptions options)
    {
        options.Resolver.GetFormatterWithVerify<Guid>().Serialize(ref writer, value.Value, options);
    }

    public EventId Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
    {
        var guid = options.Resolver.GetFormatterWithVerify<Guid>().Deserialize(ref reader, options);
        return new EventId(guid);
    }
}


// --- PATH: plugins/Geosphere.Plate.Topology.Serializers/Formatters/GeometryFormatter.cs ---
using System;
using MessagePack;
using MessagePack.Formatters;
using UnifyGeometry;

namespace FantaSim.Geosphere.Plate.Topology.Serializers.Formatters;

/// <summary>
/// Custom MessagePack formatter for IGeometry using numeric discriminators.
/// Format: [GeometryType, ...type-specific data]
/// Point: [0, x, y]
/// LineSegment: [1, startX, startY, endX, endY]
/// Polyline: [2, x1, y1, x2, y2, ...]
/// </summary>
internal class GeometryFormatter : IMessagePackFormatter<IGeometry?>
{
    public void Serialize(ref MessagePackWriter writer, IGeometry? value, MessagePackSerializerOptions options)
    {
        if (value == null)
        {
            writer.WriteNil();
            return;
        }

        switch (value)
        {
            case Point2 point:
                writer.WriteArrayHeader(3);
                writer.Write((byte)GeometryType.Point);
                writer.Write(point.X);
                writer.Write(point.Y);
                break;

            case Segment2 segment:
                writer.WriteArrayHeader(5);
                writer.Write((byte)GeometryType.LineSegment);
                writer.Write(segment.Start.X);
                writer.Write(segment.Start.Y);
                writer.Write(segment.End.X);
                writer.Write(segment.End.Y);
                break;

            case Polyline2 polyline:
                writer.WriteArrayHeader(1 + polyline.Count * 2);
                writer.Write((byte)GeometryType.Polyline);
                foreach (var point in polyline.Points)
                {
                    writer.Write(point.X);
                    writer.Write(point.Y);
                }
                break;

            case Point3 point:
                writer.WriteArrayHeader(4);
                writer.Write((byte)GeometryType.Point3);
                writer.Write(point.X);
                writer.Write(point.Y);
                writer.Write(point.Z);
                break;

            case Segment3 segment:
                writer.WriteArrayHeader(7);
                writer.Write((byte)GeometryType.LineSegment3);
                writer.Write(segment.Start.X);
                writer.Write(segment.Start.Y);
                writer.Write(segment.Start.Z);
                writer.Write(segment.End.X);
                writer.Write(segment.End.Y);
                writer.Write(segment.End.Z);
                break;

            case Polyline3 polyline:
                writer.WriteArrayHeader(1 + polyline.Count * 3);
                writer.Write((byte)GeometryType.Polyline3);
                for (var i = 0; i < polyline.PointCount; i++)
                {
                    var point3 = polyline[i];
                    writer.Write(point3.X);
                    writer.Write(point3.Y);
                    writer.Write(point3.Z);
                }
                break;

            default:
                throw new InvalidOperationException($"Unknown geometry type: {value.GetType()}");
        }
    }

    public IGeometry? Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
    {
        if (reader.TryReadNil())
        {
            return null;
        }

        var length = reader.ReadArrayHeader();
        if (length < 1)
            throw new InvalidOperationException("Invalid geometry data: empty array");

        var geometryType = (GeometryType)reader.ReadByte();

        return geometryType switch
        {
            GeometryType.Point => DeserializePoint(ref reader, length),
            GeometryType.LineSegment => DeserializeLineSegment(ref reader, length),
            GeometryType.Polyline => DeserializePolyline(ref reader, length),
            GeometryType.Point3 => DeserializePoint3(ref reader, length),
            GeometryType.LineSegment3 => DeserializeLineSegment3(ref reader, length),
            GeometryType.Polyline3 => DeserializePolyline3(ref reader, length),
            _ => throw new InvalidOperationException($"Unknown geometry type: {geometryType}")
        };
    }

    private Point2 DeserializePoint(ref MessagePackReader reader, int expectedLength)
    {
        if (expectedLength != 3)
            throw new InvalidOperationException($"Point geometry must have 3 elements, got {expectedLength}");

        var x = reader.ReadDouble();
        var y = reader.ReadDouble();
        return new Point2(x, y);
    }

    private Segment2 DeserializeLineSegment(ref MessagePackReader reader, int expectedLength)
    {
        if (expectedLength != 5)
            throw new InvalidOperationException($"LineSegment geometry must have 5 elements, got {expectedLength}");

        var startX = reader.ReadDouble();
        var startY = reader.ReadDouble();
        var endX = reader.ReadDouble();
        var endY = reader.ReadDouble();
        return new Segment2(new Point2(startX, startY), new Point2(endX, endY));
    }

    private Polyline2 DeserializePolyline(ref MessagePackReader reader, int expectedLength)
    {
        if (expectedLength < 1)
            throw new InvalidOperationException($"Polyline geometry must have at least 1 element, got {expectedLength}");

        if ((expectedLength - 1) % 2 != 0)
            throw new InvalidOperationException($"Polyline geometry must have an even number of coordinate values, got {expectedLength}");

        var pointCount = (expectedLength - 1) / 2;
        var points = new Point2[pointCount];

        for (int i = 0; i < pointCount; i++)
        {
            var x = reader.ReadDouble();
            var y = reader.ReadDouble();
            points[i] = new Point2(x, y);
        }

        return new Polyline2(points);
    }

    private Point3 DeserializePoint3(ref MessagePackReader reader, int expectedLength)
    {
        if (expectedLength != 4)
            throw new InvalidOperationException($"Point3 geometry must have 4 elements, got {expectedLength}");

        var x = reader.ReadDouble();
        var y = reader.ReadDouble();
        var z = reader.ReadDouble();
        return new Point3(x, y, z);
    }

    private Segment3 DeserializeLineSegment3(ref MessagePackReader reader, int expectedLength)
    {
        if (expectedLength != 7)
            throw new InvalidOperationException($"LineSegment3 geometry must have 7 elements, got {expectedLength}");

        var startX = reader.ReadDouble();
        var startY = reader.ReadDouble();
        var startZ = reader.ReadDouble();
        var endX = reader.ReadDouble();
        var endY = reader.ReadDouble();
        var endZ = reader.ReadDouble();
        return new Segment3(new Point3(startX, startY, startZ), new Point3(endX, endY, endZ));
    }

    private Polyline3 DeserializePolyline3(ref MessagePackReader reader, int expectedLength)
    {
        if (expectedLength < 1)
            throw new InvalidOperationException($"Polyline3 geometry must have at least 1 element, got {expectedLength}");

        if ((expectedLength - 1) % 3 != 0)
            throw new InvalidOperationException($"Polyline3 geometry must have a multiple of 3 coordinate values, got {expectedLength}");

        var pointCount = (expectedLength - 1) / 3;
        var points = new Point3[pointCount];

        for (int i = 0; i < pointCount; i++)
        {
            var x = reader.ReadDouble();
            var y = reader.ReadDouble();
            var z = reader.ReadDouble();
            points[i] = new Point3(x, y, z);
        }

        return new Polyline3(points);
    }
}


// --- PATH: plugins/Geosphere.Plate.Topology.Serializers/Formatters/JunctionIdFormatter.cs ---
using System;
using MessagePack;
using MessagePack.Formatters;
using FantaSim.Geosphere.Plate.Topology.Contracts.Entities;

namespace FantaSim.Geosphere.Plate.Topology.Serializers.Formatters;

/// <summary>
/// Custom MessagePack formatter for JunctionId.
/// Encoded as raw Guid (binary).
/// </summary>
internal class JunctionIdFormatter : IMessagePackFormatter<JunctionId>
{
    public void Serialize(ref MessagePackWriter writer, JunctionId value, MessagePackSerializerOptions options)
    {
        options.Resolver.GetFormatterWithVerify<Guid>().Serialize(ref writer, value.Value, options);
    }

    public JunctionId Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
    {
        var guid = options.Resolver.GetFormatterWithVerify<Guid>().Deserialize(ref reader, options);
        return new JunctionId(guid);
    }
}


// --- PATH: plugins/Geosphere.Plate.Topology.Serializers/Formatters/PlateIdFormatter.cs ---
using System;
using MessagePack;
using MessagePack.Formatters;
using FantaSim.Geosphere.Plate.Topology.Contracts.Entities;

namespace FantaSim.Geosphere.Plate.Topology.Serializers.Formatters;

/// <summary>
/// Custom MessagePack formatter for PlateId.
/// Encoded as raw Guid (binary).
/// </summary>
internal class PlateIdFormatter : IMessagePackFormatter<PlateId>
{
    public void Serialize(ref MessagePackWriter writer, PlateId value, MessagePackSerializerOptions options)
    {
        options.Resolver.GetFormatterWithVerify<Guid>().Serialize(ref writer, value.Value, options);
    }

    public PlateId Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
    {
        var guid = options.Resolver.GetFormatterWithVerify<Guid>().Deserialize(ref reader, options);
        return new PlateId(guid);
    }
}


// --- PATH: plugins/Geosphere.Plate.Topology.Serializers/Formatters/Point2Formatter.cs ---
using System;
using MessagePack;
using MessagePack.Formatters;
using UnifyGeometry;

namespace FantaSim.Geosphere.Plate.Topology.Serializers.Formatters;

/// <summary>
/// Custom MessagePack formatter for Point2.
/// Format: [x, y]
/// </summary>
internal class Point2Formatter : IMessagePackFormatter<Point2>
{
    public void Serialize(ref MessagePackWriter writer, Point2 value, MessagePackSerializerOptions options)
    {
        writer.WriteArrayHeader(2);
        writer.Write(value.X);
        writer.Write(value.Y);
    }

    public Point2 Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
    {
        if (reader.TryReadNil())
        {
            throw new InvalidOperationException("Point2 cannot be nil");
        }

        var count = reader.ReadArrayHeader();
        if (count != 2)
        {
            throw new InvalidOperationException($"Point2 expected 2 elements, got {count}");
        }

        var x = reader.ReadDouble();
        var y = reader.ReadDouble();
        return new Point2(x, y);
    }
}


// --- PATH: plugins/Geosphere.Plate.Topology.Serializers/Formatters/Polyline2Formatter.cs ---
using System;
using MessagePack;
using MessagePack.Formatters;
using UnifyGeometry;

namespace FantaSim.Geosphere.Plate.Topology.Serializers.Formatters;

/// <summary>
/// Custom MessagePack formatter for Polyline2.
/// Format: [x1, y1, x2, y2, ...]
/// </summary>
internal class Polyline2Formatter : IMessagePackFormatter<Polyline2?>
{
    public void Serialize(ref MessagePackWriter writer, Polyline2? value, MessagePackSerializerOptions options)
    {
        if (value == null)
        {
            writer.WriteNil();
            return;
        }

        var points = value.Points;
        writer.WriteArrayHeader(value.PointCount * 2);
        foreach (var p in points)
        {
            writer.Write(p.X);
            writer.Write(p.Y);
        }
    }

    public Polyline2? Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
    {
        if (reader.TryReadNil())
        {
            return null;
        }

        var count = reader.ReadArrayHeader();
        if (count % 2 != 0)
        {
            throw new InvalidOperationException($"Polyline2 expected even number of elements, got {count}");
        }

        var pointCount = count / 2;
        var points = new Point2[pointCount];
        for (int i = 0; i < pointCount; i++)
        {
            var x = reader.ReadDouble();
            var y = reader.ReadDouble();
            points[i] = new Point2(x, y);
        }

        return new Polyline2(points);
    }
}


// --- PATH: plugins/Geosphere.Plate.Topology.Serializers/Formatters/Segment2Formatter.cs ---
using System;
using MessagePack;
using MessagePack.Formatters;
using UnifyGeometry;

namespace FantaSim.Geosphere.Plate.Topology.Serializers.Formatters;

/// <summary>
/// Custom MessagePack formatter for Segment2.
/// Format: [start_x, start_y, end_x, end_y]
/// </summary>
internal class Segment2Formatter : IMessagePackFormatter<Segment2>
{
    public void Serialize(ref MessagePackWriter writer, Segment2 value, MessagePackSerializerOptions options)
    {
        writer.WriteArrayHeader(4);
        writer.Write(value.Start.X);
        writer.Write(value.Start.Y);
        writer.Write(value.End.X);
        writer.Write(value.End.Y);
    }

    public Segment2 Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
    {
        if (reader.TryReadNil())
        {
            throw new InvalidOperationException("Segment2 cannot be nil");
        }

        var count = reader.ReadArrayHeader();
        if (count != 4)
        {
            throw new InvalidOperationException($"Segment2 expected 4 elements, got {count}");
        }

        var sx = reader.ReadDouble();
        var sy = reader.ReadDouble();
        var ex = reader.ReadDouble();
        var ey = reader.ReadDouble();
        return new Segment2(new Point2(sx, sy), new Point2(ex, ey));
    }
}


// --- PATH: plugins/Geosphere.Plate.Topology.Serializers/HeadRecordSerializer.cs ---
﻿using System.Buffers;
using System.Buffers.Binary;
using MessagePack;

namespace FantaSim.Geosphere.Plate.Topology.Serializers;

/// <summary>
/// Serializes/deserializes stream head metadata per RFC-V2-0004.
///
/// Head record format (MessagePack array):
/// [lastSeq (int64), lastHash (bin32), lastTick (int64)]
///
/// This replaces the previous MVP format that only stored lastSeq (8 bytes).
/// The new format enables fast head reads without touching event records,
/// and supports full optimistic concurrency checks.
/// </summary>
public static class HeadRecordSerializer
{
    public const int HashSizeBytes = 32;

    /// <summary>
    /// Serializes a head record to MessagePack bytes.
    /// </summary>
    /// <param name="lastSeq">The last sequence number in the stream.</param>
    /// <param name="lastHash">The hash of the last event record (32 bytes).</param>
    /// <param name="lastTick">The tick of the last event.</param>
    /// <returns>MessagePack-encoded head record.</returns>
    public static byte[] Serialize(long lastSeq, byte[] lastHash, long lastTick)
    {
        ArgumentNullException.ThrowIfNull(lastHash);
        if (lastHash.Length != HashSizeBytes)
            throw new ArgumentException($"Hash must be {HashSizeBytes} bytes", nameof(lastHash));

        var buffer = new ArrayBufferWriter<byte>();
        var writer = new MessagePackWriter(buffer);

        writer.WriteArrayHeader(3);
        writer.Write(lastSeq);
        writer.Write(lastHash);
        writer.Write(lastTick);
        writer.Flush();

        return buffer.WrittenMemory.ToArray();
    }

    /// <summary>
    /// Deserializes a head record from MessagePack bytes.
    /// </summary>
    /// <param name="data">The MessagePack-encoded head record.</param>
    /// <param name="lastSeq">The last sequence number.</param>
    /// <param name="lastHash">The hash of the last event record.</param>
    /// <param name="lastTick">The tick of the last event.</param>
    /// <returns>True if deserialization succeeded; false otherwise.</returns>
    public static bool TryDeserialize(ReadOnlySpan<byte> data, out long lastSeq, out byte[] lastHash, out long lastTick)
    {
        lastSeq = -1;
        lastHash = Array.Empty<byte>();
        lastTick = -1;

        try
        {
            var reader = new MessagePackReader(data.ToArray());
            var arrayLength = reader.ReadArrayHeader();

            if (arrayLength != 3)
                return false;

            lastSeq = reader.ReadInt64();
            var hashBytes = reader.ReadBytes();
            if (!hashBytes.HasValue || hashBytes.Value.Length != HashSizeBytes)
                return false;

            lastHash = hashBytes.Value.ToArray();
            lastTick = reader.ReadInt64();

            return true;
        }
        catch
        {
            return false;
        }
    }

    /// <summary>
    /// Checks if the data looks like an old-format head (8-byte sequence only).
    /// Used for migration/compatibility detection.
    /// </summary>
    public static bool IsLegacyFormat(ReadOnlySpan<byte> data)
    {
        return data.Length == 8;
    }

    /// <summary>
    /// Reads a legacy 8-byte head value (sequence only).
    /// </summary>
    public static long ReadLegacySequence(ReadOnlySpan<byte> data)
    {
        if (data.Length != 8)
            throw new ArgumentException("Legacy head must be exactly 8 bytes", nameof(data));
        return BinaryPrimitives.ReadInt64BigEndian(data);
    }
}


// --- PATH: plugins/Geosphere.Plate.Topology.Serializers/MessagePackEventRecordSerializer.cs ---
using System;
using System.Buffers;
using System.Security.Cryptography;
using MessagePack;

namespace FantaSim.Geosphere.Plate.Topology.Serializers;

public static class MessagePackEventRecordSerializer
{
    public const int SchemaVersionV1 = 1;
    public const int HashSizeBytes = 32;

    private static readonly byte[] ZeroHash = new byte[HashSizeBytes];

    public static byte[] SerializeRecord(
        int schemaVersion,
        long tick,
        byte[] previousHash,
        byte[] hash,
        byte[] eventBytes)
    {
        ArgumentNullException.ThrowIfNull(previousHash);
        ArgumentNullException.ThrowIfNull(hash);
        ArgumentNullException.ThrowIfNull(eventBytes);

        if (previousHash.Length != HashSizeBytes)
            throw new ArgumentOutOfRangeException(nameof(previousHash), $"previousHash must be {HashSizeBytes} bytes");
        if (hash.Length != HashSizeBytes)
            throw new ArgumentOutOfRangeException(nameof(hash), $"hash must be {HashSizeBytes} bytes");

        var buffer = new ArrayBufferWriter<byte>();
        var writer = new MessagePackWriter(buffer);

        writer.WriteArrayHeader(5);
        writer.Write(schemaVersion);
        writer.Write(tick);
        writer.Write(previousHash);
        writer.Write(hash);
        writer.Write(eventBytes);
        writer.Flush();

        return buffer.WrittenMemory.ToArray();
    }

    public static byte[] ComputeHashV1(
        int schemaVersion,
        long tick,
        byte[] previousHash,
        byte[] eventBytes)
    {
        ArgumentNullException.ThrowIfNull(previousHash);
        ArgumentNullException.ThrowIfNull(eventBytes);

        if (previousHash.Length != HashSizeBytes)
            throw new ArgumentOutOfRangeException(nameof(previousHash), $"previousHash must be {HashSizeBytes} bytes");

        // Canonical preimage for v1 hashing: [schemaVersion, tick, previousHash, eventBytes]
        var buffer = new ArrayBufferWriter<byte>();
        var writer = new MessagePackWriter(buffer);
        writer.WriteArrayHeader(4);
        writer.Write(schemaVersion);
        writer.Write(tick);
        writer.Write(previousHash);
        writer.Write(eventBytes);
        writer.Flush();

        return SHA256.HashData(buffer.WrittenSpan);
    }

    public static EventRecordV1 DeserializeRecord(byte[] recordBytes)
    {
        ArgumentNullException.ThrowIfNull(recordBytes);

        var reader = new MessagePackReader(recordBytes);
        var length = reader.ReadArrayHeader();
        if (length != 5)
            throw new InvalidOperationException($"EventRecord must have 5 elements, got {length}");

        var schemaVersion = reader.ReadInt32();
        var tick = reader.ReadInt64();

        var previousHash = ReadFixedHash(ref reader, "previousHash");
        var hash = ReadFixedHash(ref reader, "hash");

        var eventBytes = reader.ReadBytes();
        if (!eventBytes.HasValue)
            throw new InvalidOperationException("EventRecord eventBytes cannot be null");

        return new EventRecordV1(schemaVersion, tick, previousHash, hash, eventBytes.Value.ToArray());
    }

    public static bool TryDeserializeRecord(byte[] recordBytes, out EventRecordV1 record)
    {
        ArgumentNullException.ThrowIfNull(recordBytes);

        try
        {
            var reader = new MessagePackReader(recordBytes);
            var length = reader.ReadArrayHeader();
            if (length != 5)
            {
                record = default;
                return false;
            }

            record = DeserializeRecord(recordBytes);
            return true;
        }
        catch
        {
            record = default;
            return false;
        }
    }

    public static byte[] GetZeroHash() => (byte[])ZeroHash.Clone();

    private static byte[] ReadFixedHash(ref MessagePackReader reader, string name)
    {
        var bytes = reader.ReadBytes();
        if (!bytes.HasValue)
            throw new InvalidOperationException($"EventRecord {name} cannot be null");

        var arr = bytes.Value.ToArray();
        if (arr.Length != HashSizeBytes)
            throw new InvalidOperationException($"EventRecord {name} must be {HashSizeBytes} bytes, got {arr.Length}");

        return arr;
    }

    public readonly record struct EventRecordV1(
        int SchemaVersion,
        long Tick,
        byte[] PreviousHash,
        byte[] Hash,
        byte[] EventBytes);
}


// --- PATH: plugins/Geosphere.Plate.Topology.Serializers/MessagePackEventSerializer.cs ---
using System;
using System.Buffers;
using System.Collections.Generic;
using MessagePack;
using MessagePack.Formatters;
using MessagePack.Resolvers;
using Plate.TimeDete.Time.Primitives;
using FantaSim.Geosphere.Plate.Topology.Contracts.Entities;
using FantaSim.Geosphere.Plate.Topology.Contracts.Events;
using FantaSim.Geosphere.Plate.Topology.Contracts.Identity;
using FantaSim.Geosphere.Plate.Topology.Serializers.Formatters;
using UnifyGeometry;

namespace FantaSim.Geosphere.Plate.Topology.Serializers;

// Helper extension method for ReadOnlySequence<T>
internal static class ReadOnlySequenceExtensions
{
    public static byte[] ToByteArray(this System.Buffers.ReadOnlySequence<byte> sequence)
    {
        if (sequence.Length == 0)
            return Array.Empty<byte>();

        if (sequence.IsSingleSegment)
        {
            return sequence.FirstSpan.ToArray();
        }

        var bytes = new byte[sequence.Length];
        sequence.CopyTo(bytes);
        return bytes;
    }
}

/// <summary>
/// MessagePack serializer for plate topology events with envelope-based polymorphic API.
///
/// Envelope format: [eventType:string, payload:binary]
/// - eventType: string name of event type (e.g., "PlateCreatedEvent")
/// - payload: binary encoded event data using event-specific numeric arrays
///
/// Payload format: numeric arrays only (no string keys/maps)
/// - Domain is serialized as plain string
/// - Geometry uses numeric discriminators
/// - CanonicalTick is encoded as raw Int64
///
/// API:
/// - Serialize<T>(T event): Writes [eventType, payload<T>]
/// - Deserialize(byte[] data): Reads envelope, dispatches to appropriate formatter
/// - Deserialize<T>(byte[] data): Reads envelope, asserts eventType matches, decodes payload
/// </summary>
public static class MessagePackEventSerializer
{
    public static readonly MessagePackSerializerOptions Options = MessagePackSerializerOptions.Standard
        .WithResolver(CompositeResolver.Create(
            new IMessagePackFormatter[]
            {
                new GeometryFormatter(),
                new Point2Formatter(),
                new Segment2Formatter(),
                new Polyline2Formatter(),
                new DomainFormatter(),
                new CanonicalTickFormatter(),
                new PlateIdFormatter(),
                new BoundaryIdFormatter(),
                new JunctionIdFormatter(),
                new EventIdFormatter(),

                // Generated Formatters
                new FantaSim.Geosphere.Plate.Topology.Contracts.Identity.TruthStreamIdentityMessagePackFormatter(),
                new FantaSim.Geosphere.Plate.Topology.Contracts.Events.PlateCreatedEventMessagePackFormatter(),
                new FantaSim.Geosphere.Plate.Topology.Contracts.Events.PlateRetiredEventMessagePackFormatter(),
                new FantaSim.Geosphere.Plate.Topology.Contracts.Events.BoundaryCreatedEventMessagePackFormatter(),
                new FantaSim.Geosphere.Plate.Topology.Contracts.Events.BoundaryTypeChangedEventMessagePackFormatter(),
                new FantaSim.Geosphere.Plate.Topology.Contracts.Events.BoundaryGeometryUpdatedEventMessagePackFormatter(),
                new FantaSim.Geosphere.Plate.Topology.Contracts.Events.BoundaryRetiredEventMessagePackFormatter(),
                new FantaSim.Geosphere.Plate.Topology.Contracts.Events.JunctionCreatedEventMessagePackFormatter(),
                new FantaSim.Geosphere.Plate.Topology.Contracts.Events.JunctionUpdatedEventMessagePackFormatter(),
                new FantaSim.Geosphere.Plate.Topology.Contracts.Events.JunctionRetiredEventMessagePackFormatter()
            },
            new IFormatterResolver[]
            {
                NativeGuidResolver.Instance,
                BuiltinResolver.Instance,
                StandardResolver.Instance
            }
        ));

    // Event type name to formatter mapping for polymorphic deserialization
    private static readonly Dictionary<string, Type> EventTypeMap = new()
    {
        { nameof(PlateCreatedEvent), typeof(PlateCreatedEvent) },
        { nameof(PlateRetiredEvent), typeof(PlateRetiredEvent) },
        { nameof(BoundaryCreatedEvent), typeof(BoundaryCreatedEvent) },
        { nameof(BoundaryTypeChangedEvent), typeof(BoundaryTypeChangedEvent) },
        { nameof(BoundaryGeometryUpdatedEvent), typeof(BoundaryGeometryUpdatedEvent) },
        { nameof(BoundaryRetiredEvent), typeof(BoundaryRetiredEvent) },
        { nameof(JunctionCreatedEvent), typeof(JunctionCreatedEvent) },
        { nameof(JunctionUpdatedEvent), typeof(JunctionUpdatedEvent) },
        { nameof(JunctionRetiredEvent), typeof(JunctionRetiredEvent) }
    };

    /// <summary>
    /// Serializes an event to a MessagePack byte array with envelope.
    /// Format: [eventType:string, payload:binary]
    /// </summary>
    /// <typeparam name="T">The event type to serialize.</typeparam>
    /// <param name="value">The event to serialize.</param>
    /// <returns>A byte array containing [eventType, payload].</returns>
    public static byte[] Serialize<T>(T value) where T : IPlateTopologyEvent
    {
        var payloadBytes = MessagePackSerializer.Serialize(value, Options);

        // Serialize envelope directly using MessagePack
        // Envelope is: [eventType:string, payload:binary]
        var eventType = ((IPlateTopologyEvent)value).EventType;

        // Create envelope bytes manually
        var buffer = new System.Buffers.ArrayBufferWriter<byte>();
        var writer = new MessagePackWriter(buffer);
        writer.WriteArrayHeader(2);
        writer.Write(eventType);
        writer.Write(payloadBytes);
        writer.Flush();

        return buffer.WrittenMemory.ToArray();
    }

    public static byte[] Serialize(IPlateTopologyEvent value)
    {
        ArgumentNullException.ThrowIfNull(value);

        var payloadBytes = MessagePackSerializer.Serialize(value.GetType(), value, Options);
        var eventType = value.EventType;

        var buffer = new System.Buffers.ArrayBufferWriter<byte>();
        var writer = new MessagePackWriter(buffer);
        writer.WriteArrayHeader(2);
        writer.Write(eventType);
        writer.Write(payloadBytes);
        writer.Flush();

        return buffer.WrittenMemory.ToArray();
    }

    /// <summary>
    /// Deserializes an event from a MessagePack byte array.
    /// Reads envelope [eventType, payload] and dispatches to appropriate formatter.
    /// </summary>
    /// <param name="data">The byte array containing [eventType, payload].</param>
    /// <returns>The deserialized event as IPlateTopologyEvent.</returns>
    public static IPlateTopologyEvent Deserialize(byte[] data)
    {
        var reader = new MessagePackReader(data);

        var length = reader.ReadArrayHeader();
        if (length != 2)
            throw new InvalidOperationException($"Envelope must have 2 elements, got {length}");

        var eventType = reader.ReadString();
        if (eventType == null)
            throw new InvalidOperationException("Envelope eventType cannot be null");

        var payloadBytes = reader.ReadBytes();
        if (!payloadBytes.HasValue)
            throw new InvalidOperationException("Envelope payload cannot be null");

        var payloadArray = payloadBytes.Value.ToByteArray();

        // Use ReadOnlySequence directly for deserialization
        if (!EventTypeMap.TryGetValue(eventType, out var eventTypeType))
            throw new InvalidOperationException($"Unknown event type: {eventType}");

        var eventObj = MessagePackSerializer.Deserialize(eventTypeType, payloadArray, Options);
        return (IPlateTopologyEvent)eventObj!;
    }

    /// <summary>
    /// Deserializes a specific event type, validating the envelope matches.
    /// </summary>
    public static T Deserialize<T>(byte[] data) where T : IPlateTopologyEvent
    {
        var reader = new MessagePackReader(data);
        var length = reader.ReadArrayHeader();
        if (length != 2)
            throw new InvalidOperationException($"Invalid event envelope. Expected 2 elements, got {length}");

        var eventType = reader.ReadString();
        // We verify event type matches T (assuming T.EventType matches class name)
        // Actually T is the type, we should check if eventType maps to T.

        // This check is a bit loose but sufficient for now.
        // Ideally we check ((IPlateTopologyEvent)default(T)).EventType but T might not have default.
        // For strictness we could rely on EventTypeMap.
        if (!EventTypeMap.TryGetValue(eventType!, out var type) || !typeof(T).IsAssignableFrom(type))
        {
             // It's okay if T is IPlateTopologyEvent (handled above)
             // But if T is PlateCreatedEvent and eventType is "PlateRetiredEvent", this should fail.
             // Warning: strict check might fail if T is interface.
             // If T is concrete:
             if (typeof(T).Name != eventType)
             {
                 throw new InvalidOperationException($"Event type mismatch. Expected {typeof(T).Name}, got {eventType}");
             }
        }

        var payloadBytes = reader.ReadBytes();
        if (!payloadBytes.HasValue)
            throw new InvalidOperationException("Event payload cannot be null");

        var payload = payloadBytes.Value.ToByteArray();
        return MessagePackSerializer.Deserialize<T>(payload, Options);
    }
}


// --- PATH: plugins/Geosphere.Plate.Topology.Serializers/MessagePackPlateTopologySnapshotSerializer.cs ---
﻿using System;
using System.Buffers;
using System.Collections.Immutable;
using MessagePack;
using FantaSim.Geosphere.Plate.Topology.Contracts.Derived;
using FantaSim.Geosphere.Plate.Topology.Contracts.Entities;
using FantaSim.Geosphere.Plate.Topology.Serializers.Formatters;
using UnifyGeometry;
using Numerics = FantaSim.Geosphere.Plate.Topology.Contracts.Numerics;
using PlateEntity = FantaSim.Geosphere.Plate.Topology.Contracts.Entities.Plate;

namespace FantaSim.Geosphere.Plate.Topology.Serializers;

public static class MessagePackPlateTopologySnapshotSerializer
{
    public const int SchemaVersionV1 = 1;

    public static byte[] Serialize(PlateTopologySnapshot snapshot)
    {
        var buffer = new ArrayBufferWriter<byte>();
        var writer = new MessagePackWriter(buffer);

        writer.WriteArrayHeader(7);
        writer.Write(SchemaVersionV1);

        // Use shared Options to serialize TruthStreamIdentity
        MessagePackSerializer.Serialize(ref writer, snapshot.Key.Stream, MessagePackEventSerializer.Options);

        writer.Write(snapshot.Key.Tick);
        writer.Write(snapshot.LastEventSequence);

        SerializePlates(ref writer, snapshot.Plates);
        SerializeBoundaries(ref writer, snapshot.Boundaries);
        SerializeJunctions(ref writer, snapshot.Junctions);

        writer.Flush();
        return buffer.WrittenMemory.ToArray();
    }

    public static PlateTopologySnapshot Deserialize(byte[] bytes)
    {
        var reader = new MessagePackReader(bytes);
        var length = reader.ReadArrayHeader();
        if (length != 7)
            throw new InvalidOperationException($"PlateTopologySnapshot must have 7 elements, got {length}");

        var schemaVersion = reader.ReadInt32();
        if (schemaVersion != SchemaVersionV1)
            throw new InvalidOperationException($"Unsupported snapshot schemaVersion: {schemaVersion}");

        // Use shared Options to deserialize TruthStreamIdentity
        var stream = MessagePackSerializer.Deserialize<FantaSim.Geosphere.Plate.Topology.Contracts.Identity.TruthStreamIdentity>(ref reader, MessagePackEventSerializer.Options);

        var tick = reader.ReadInt64();
        var lastEventSequence = reader.ReadInt64();

        var plates = DeserializePlates(ref reader);
        var boundaries = DeserializeBoundaries(ref reader);
        var junctions = DeserializeJunctions(ref reader);

        return new PlateTopologySnapshot(
            new PlateTopologyMaterializationKey(stream, tick, lastEventSequence),
            lastEventSequence,
            plates,
            boundaries,
            junctions);
    }

    private static void SerializePlates(ref MessagePackWriter writer, PlateEntity[] plates)
    {
        writer.WriteArrayHeader(plates.Length);
        foreach (var p in plates)
        {
            writer.WriteArrayHeader(3);
            writer.Write(p.PlateId.Value.ToString());
            writer.Write(p.IsRetired);
            if (p.RetirementReason is null)
                writer.WriteNil();
            else
                writer.Write(p.RetirementReason);
        }
    }

    private static PlateEntity[] DeserializePlates(ref MessagePackReader reader)
    {
        var count = reader.ReadArrayHeader();
        var plates = new PlateEntity[count];
        for (var i = 0; i < count; i++)
        {
            var len = reader.ReadArrayHeader();
            if (len != 3)
                throw new InvalidOperationException($"Plate must have 3 elements, got {len}");

            var id = Guid.Parse(reader.ReadString()!);
            var isRetired = reader.ReadBoolean();
            string? reason;
            if (reader.TryReadNil())
                reason = null;
            else
                reason = reader.ReadString();

            plates[i] = new PlateEntity(new PlateId(id), isRetired, reason);
        }

        return plates;
    }

    private static void SerializeBoundaries(ref MessagePackWriter writer, Boundary[] boundaries)
    {
        writer.WriteArrayHeader(boundaries.Length);
        foreach (var b in boundaries)
        {
            writer.WriteArrayHeader(7);
            writer.Write(b.BoundaryId.Value.ToString());
            writer.Write(b.PlateIdLeft.Value.ToString());
            writer.Write(b.PlateIdRight.Value.ToString());
            writer.Write((byte)b.BoundaryType);

            // Use shared Options for Geometry
            MessagePackSerializer.Serialize(ref writer, b.Geometry, MessagePackEventSerializer.Options);

            writer.Write(b.IsRetired);
            if (b.RetirementReason is null)
                writer.WriteNil();
            else
                writer.Write(b.RetirementReason);
        }
    }

    private static Boundary[] DeserializeBoundaries(ref MessagePackReader reader)
    {
        var count = reader.ReadArrayHeader();
        var boundaries = new Boundary[count];

        for (var i = 0; i < count; i++)
        {
            var len = reader.ReadArrayHeader();
            if (len != 7)
                throw new InvalidOperationException($"Boundary must have 7 elements, got {len}");

            var boundaryId = new BoundaryId(Guid.Parse(reader.ReadString()!));
            var plateLeft = new PlateId(Guid.Parse(reader.ReadString()!));
            var plateRight = new PlateId(Guid.Parse(reader.ReadString()!));
            var type = (BoundaryType)reader.ReadByte();

            // Use shared Options for Geometry
            var geometry = MessagePackSerializer.Deserialize<IGeometry?>(ref reader, MessagePackEventSerializer.Options);
            if (geometry == null) throw new InvalidOperationException("Boundary geometry cannot be null");

            var isRetired = reader.ReadBoolean();

            string? reason;
            if (reader.TryReadNil())
                reason = null;
            else
                reason = reader.ReadString();

            boundaries[i] = new Boundary(boundaryId, plateLeft, plateRight, type, geometry, isRetired, reason);
        }

        return boundaries;
    }

    private static void SerializeJunctions(ref MessagePackWriter writer, Junction[] junctions)
    {
        writer.WriteArrayHeader(junctions.Length);
        foreach (var j in junctions)
        {
            writer.WriteArrayHeader(8); // JunctionId, BoundaryIds, Normal(X,Y,Z), Radius, IsRetired, RetirementReason
            writer.Write(j.JunctionId.Value.ToString());

            writer.WriteArrayHeader(j.BoundaryIds.Length);
            foreach (var b in j.BoundaryIds)
            {
                writer.Write(b.Value.ToString());
            }

            // SurfacePoint: Normal (UnitVector3d) + Radius
            writer.Write(j.Location.Normal.X);
            writer.Write(j.Location.Normal.Y);
            writer.Write(j.Location.Normal.Z);
            writer.Write(j.Location.Radius);
            writer.Write(j.IsRetired);

            if (j.RetirementReason is null)
                writer.WriteNil();
            else
                writer.Write(j.RetirementReason);
        }
    }

    private static Junction[] DeserializeJunctions(ref MessagePackReader reader)
    {
        var count = reader.ReadArrayHeader();
        var junctions = new Junction[count];

        for (var i = 0; i < count; i++)
        {
            var len = reader.ReadArrayHeader();
            if (len != 8)
                throw new InvalidOperationException($"Junction must have 8 elements, got {len}");

            var junctionId = new JunctionId(Guid.Parse(reader.ReadString()!));

            var bCount = reader.ReadArrayHeader();
            var boundaryIds = new BoundaryId[bCount];
            for (var b = 0; b < bCount; b++)
            {
                boundaryIds[b] = new BoundaryId(Guid.Parse(reader.ReadString()!));
            }

            // SurfacePoint: Normal (UnitVector3d) + Radius
            var nx = reader.ReadDouble();
            var ny = reader.ReadDouble();
            var nz = reader.ReadDouble();
            var radius = reader.ReadDouble();
            var normal = Numerics.UnitVector3d.Create(nx, ny, nz);
            var location = new Numerics.SurfacePoint(normal, radius);

            var isRetired = reader.ReadBoolean();

            string? reason;
            if (reader.TryReadNil())
                reason = null;
            else
                reason = reader.ReadString();

            junctions[i] = new Junction(junctionId, boundaryIds.ToImmutableArray(), location, isRetired, reason);
        }

        return junctions;
    }
}


// --- PATH: plugins/Geosphere.Plate.Velocity.Solver/FiniteRotationPlateVelocitySolver.cs ---
using Plate.TimeDete.Time.Primitives;
using FantaSim.Geosphere.Plate.Kinematics.Contracts.Derived;
using FantaSim.Geosphere.Plate.Topology.Contracts.Entities;
using FantaSim.Geosphere.Plate.Topology.Contracts.Numerics;
using FantaSim.Geosphere.Plate.Velocity.Contracts;

namespace FantaSim.Geosphere.Plate.Velocity.Solver;

/// <summary>
/// Computes plate velocities from finite rotation kinematics.
/// </summary>
/// <remarks>
/// <para>
/// <b>Algorithm:</b>
/// <list type="number">
/// <item>Get rotation R(t) at tick t</item>
/// <item>Get rotation R(t + dt) at tick t + dt (dt = 1 tick for determinism)</item>
/// <item>Compute ΔR = R(t+dt) × R(t)⁻¹</item>
/// <item>Extract angular velocity ω from ΔR using axis-angle conversion</item>
/// <item>Linear velocity at point p is v = ω × p</item>
/// </list>
/// </para>
/// <para>
/// <b>Determinism:</b> Uses dt = 1 tick (constant) to ensure deterministic results
/// across platforms and corpora. Same inputs always produce identical outputs.
/// </para>
/// <para>
/// <b>Fallback:</b> Returns zero velocity when kinematics data is missing,
/// matching the reconstruction solver policy (RFC-V2-0024).
/// </para>
/// </remarks>
public sealed class FiniteRotationPlateVelocitySolver : IPlateVelocitySolver
{
    /// <summary>
    /// Delta ticks used for finite difference velocity computation.
    /// Fixed at 1 tick for determinism.
    /// </summary>
    public const int DeltaTicks = 1;

    public Velocity3d GetAbsoluteVelocity(
        IPlateKinematicsStateView kinematics,
        PlateId plateId,
        Vector3d point,
        CanonicalTick tick)
    {
        ArgumentNullException.ThrowIfNull(kinematics);

        var omega = GetAngularVelocity(kinematics, plateId, tick);
        return omega.GetLinearVelocityAt(point.X, point.Y, point.Z);
    }

    public Velocity3d GetRelativeVelocity(
        IPlateKinematicsStateView kinematics,
        PlateId plateIdA,
        PlateId plateIdB,
        Vector3d point,
        CanonicalTick tick)
    {
        ArgumentNullException.ThrowIfNull(kinematics);

        var velocityA = GetAbsoluteVelocity(kinematics, plateIdA, point, tick);
        var velocityB = GetAbsoluteVelocity(kinematics, plateIdB, point, tick);
        return velocityA - velocityB;
    }

    public AngularVelocity3d GetAngularVelocity(
        IPlateKinematicsStateView kinematics,
        PlateId plateId,
        CanonicalTick tick)
    {
        ArgumentNullException.ThrowIfNull(kinematics);

        // Get rotations at t and t + dt
        if (!kinematics.TryGetRotation(plateId, tick, out var r0))
            return AngularVelocity3d.Zero;

        var tickPlusDt = new CanonicalTick(tick.Value + DeltaTicks);
        if (!kinematics.TryGetRotation(plateId, tickPlusDt, out var r1))
            return AngularVelocity3d.Zero;

        // Compute delta rotation: ΔR = R(t+dt) × R(t)⁻¹
        var r0Inv = r0.Inverse();
        var deltaR = Quaterniond.Multiply(r1, r0Inv);

        // Extract axis-angle from delta rotation
        var (axis, angle) = ToAxisAngle(deltaR);

        // Angular velocity = axis × (angle / dt)
        var rate = angle / DeltaTicks;
        return new AngularVelocity3d(axis.X * rate, axis.Y * rate, axis.Z * rate);
    }

    /// <summary>
    /// Converts a quaternion to axis-angle representation.
    /// </summary>
    private static (Vector3d Axis, double Angle) ToAxisAngle(Quaterniond q)
    {
        // Normalize the quaternion
        var norm = Math.Sqrt(q.X * q.X + q.Y * q.Y + q.Z * q.Z + q.W * q.W);
        if (norm < double.Epsilon)
            return (Vector3d.Zero, 0);

        var qn = new Quaterniond(q.X / norm, q.Y / norm, q.Z / norm, q.W / norm);

        // Clamp W to avoid NaN from acos
        var w = Math.Clamp(qn.W, -1.0, 1.0);
        var angle = 2.0 * Math.Acos(w);

        // Handle zero rotation case
        if (angle < double.Epsilon)
            return (Vector3d.Zero, 0);

        // Compute axis
        var sinHalfAngle = Math.Sin(angle / 2.0);
        if (Math.Abs(sinHalfAngle) < double.Epsilon)
            return (Vector3d.Zero, 0);

        var axis = new Vector3d(
            qn.X / sinHalfAngle,
            qn.Y / sinHalfAngle,
            qn.Z / sinHalfAngle);

        return (axis, angle);
    }

}


// --- PATH: plugins/Geosphere.Plate.Velocity.Solver/RigidBoundaryVelocitySolver.cs ---
﻿using System.Collections.Immutable;
using System.Runtime.InteropServices;
using Plate.TimeDete.Time.Primitives;
using FantaSim.Geosphere.Plate.Kinematics.Contracts.Derived;
using FantaSim.Geosphere.Plate.Topology.Contracts.Derived;
using FantaSim.Geosphere.Plate.Topology.Contracts.Entities;
using FantaSim.Geosphere.Plate.Topology.Contracts.Numerics;
using FantaSim.Geosphere.Plate.Velocity.Contracts;
using UnifyGeometry;

namespace FantaSim.Geosphere.Plate.Velocity.Solver;

using Vector3d = FantaSim.Geosphere.Plate.Topology.Contracts.Numerics.Vector3d;

[StructLayout(LayoutKind.Auto)]
internal readonly record struct SampledPoint(Vector3d Position, int SegmentIndex, double SegmentT);

public sealed class RigidBoundaryVelocitySolver : IBoundaryVelocitySolver
{
    public static readonly BoundarySamplingSpec DefaultSampling = new(
        SampleCount: 64, Mode: SamplingMode.ArcLength, IncludeEndpoints: true);

    private readonly IPlateVelocitySolver _velocitySolver;

    public RigidBoundaryVelocitySolver(IPlateVelocitySolver velocitySolver)
    {
        _velocitySolver = velocitySolver ?? throw new ArgumentNullException(nameof(velocitySolver));
    }

    public BoundaryVelocityProfile AnalyzeBoundary(
        Boundary boundary, BoundarySamplingSpec sampling, CanonicalTick tick,
        IPlateTopologyStateView topology, IPlateKinematicsStateView kinematics)
    {
        ArgumentNullException.ThrowIfNull(boundary);
        ArgumentNullException.ThrowIfNull(sampling);
        ArgumentNullException.ThrowIfNull(tick);
        ArgumentNullException.ThrowIfNull(topology);
        ArgumentNullException.ThrowIfNull(kinematics);

        var vertices = ExtractVertices(boundary.Geometry);
        if (vertices.Length < 2)
            return CreateEmptyProfile(boundary.BoundaryId);

        var sampledPoints = SampleBoundary(vertices, sampling);
        var leftOmega = _velocitySolver.GetAngularVelocity(kinematics, boundary.PlateIdLeft, tick);
        var rightOmega = _velocitySolver.GetAngularVelocity(kinematics, boundary.PlateIdRight, tick);

        var velocitySamples = new BoundaryVelocitySample[sampledPoints.Length];
        for (var i = 0; i < sampledPoints.Length; i++)
        {
            velocitySamples[i] = ComputeSampleVelocity(
                sampledPoints[i], vertices, boundary.PlateIdLeft, boundary.PlateIdRight,
                leftOmega, rightOmega, tick, kinematics, i);
        }

        return ComputeAggregates(boundary.BoundaryId, velocitySamples);
    }

    /// <summary>
    /// Returns individual velocity samples for a boundary (internal, for testing).
    /// Used to verify RFC-V2-0034 invariants: tangent follows geometry, normal points left→right.
    /// </summary>
    internal BoundaryVelocitySample[] GetBoundarySamples(
        Boundary boundary, BoundarySamplingSpec sampling, CanonicalTick tick,
        IPlateTopologyStateView topology, IPlateKinematicsStateView kinematics)
    {
        ArgumentNullException.ThrowIfNull(boundary);
        ArgumentNullException.ThrowIfNull(sampling);
        ArgumentNullException.ThrowIfNull(tick);
        ArgumentNullException.ThrowIfNull(topology);
        ArgumentNullException.ThrowIfNull(kinematics);

        var vertices = ExtractVertices(boundary.Geometry);
        if (vertices.Length < 2)
            return Array.Empty<BoundaryVelocitySample>();

        var sampledPoints = SampleBoundary(vertices, sampling);
        var leftOmega = _velocitySolver.GetAngularVelocity(kinematics, boundary.PlateIdLeft, tick);
        var rightOmega = _velocitySolver.GetAngularVelocity(kinematics, boundary.PlateIdRight, tick);

        var velocitySamples = new BoundaryVelocitySample[sampledPoints.Length];
        for (var i = 0; i < sampledPoints.Length; i++)
        {
            velocitySamples[i] = ComputeSampleVelocity(
                sampledPoints[i], vertices, boundary.PlateIdLeft, boundary.PlateIdRight,
                leftOmega, rightOmega, tick, kinematics, i);
        }

        return velocitySamples;
    }

    public BoundaryVelocityCollection AnalyzeAllBoundaries(
        IEnumerable<Boundary> boundaries, BoundarySamplingSpec sampling, CanonicalTick tick,
        IPlateTopologyStateView topology, IPlateKinematicsStateView kinematics)
    {
        ArgumentNullException.ThrowIfNull(boundaries);
        ArgumentNullException.ThrowIfNull(sampling);
        ArgumentNullException.ThrowIfNull(tick);
        ArgumentNullException.ThrowIfNull(topology);
        ArgumentNullException.ThrowIfNull(kinematics);

        var profiles = boundaries.Where(b => !b.IsRetired)
            .Select(b => AnalyzeBoundary(b, sampling, tick, topology, kinematics))
            .OrderBy(p => p.BoundaryId.Value)
            .ToImmutableArray();

        return new BoundaryVelocityCollection(tick, profiles, nameof(RigidBoundaryVelocitySolver));
    }

    private static Vector3d[] ExtractVertices(IGeometry geometry)
    {
        if (geometry is not Polyline3 polyline || polyline.IsEmpty) return Array.Empty<Vector3d>();
        var vertices = new Vector3d[polyline.PointCount];
        for (var i = 0; i < polyline.PointCount; i++)
        {
            var point = polyline[i];
            vertices[i] = new Vector3d(point.X, point.Y, point.Z);
        }
        return vertices;
    }

    private SampledPoint[] SampleBoundary(Vector3d[] vertices, BoundarySamplingSpec sampling)
    {
        var sampleCount = sampling.SampleCount < 2 ? 2 : sampling.SampleCount;
        if (vertices.Length == 2)
        {
            return sampling.IncludeEndpoints
                ? new[] { new SampledPoint(vertices[0], 0, 0), new SampledPoint(vertices[1], 0, 1) }
                : new[] { new SampledPoint(ComputeMidpoint(vertices[0], vertices[1]), 0, 0.5) };
        }
        return sampling.Mode switch
        {
            SamplingMode.ArcLength => SampleByArcLength(vertices, sampleCount, sampling.IncludeEndpoints),
            SamplingMode.ChordLength => SampleByChordLength(vertices, sampleCount, sampling.IncludeEndpoints),
            _ => SampleByArcLength(vertices, sampleCount, sampling.IncludeEndpoints)
        };
    }

    private static SampledPoint[] SampleByArcLength(Vector3d[] vertices, int sampleCount, bool includeEndpoints)
    {
        var segmentLengths = new double[vertices.Length - 1];
        var totalLength = 0.0;
        for (var i = 0; i < vertices.Length - 1; i++)
        {
            segmentLengths[i] = GreatCircleDistance(vertices[i], vertices[i + 1]);
            totalLength += segmentLengths[i];
        }
        if (totalLength < double.Epsilon) return new[] { new SampledPoint(vertices[0], 0, 0) };

        var effectiveCount = includeEndpoints ? sampleCount : sampleCount - 2;
        var effectiveStart = includeEndpoints ? 0 : 1;
        var effectiveEnd = includeEndpoints ? sampleCount - 1 : sampleCount - 2;
        var samples = new SampledPoint[sampleCount];

        if (includeEndpoints)
        {
            samples[0] = new SampledPoint(vertices[0], 0, 0);
            samples[sampleCount - 1] = new SampledPoint(vertices[^1], vertices.Length - 2, 1);
        }

        var currentSegment = 0;
        var remainingInSegment = segmentLengths.Length > 0 ? segmentLengths[0] : 0;

        for (var i = effectiveStart; i <= effectiveEnd; i++)
        {
            var targetDistance = (i * totalLength) / (effectiveCount + 1);
            while (currentSegment < segmentLengths.Length - 1 && targetDistance > totalLength - remainingInSegment)
            {
                targetDistance -= remainingInSegment;
                currentSegment++;
                remainingInSegment = segmentLengths[currentSegment];
            }
            var segmentProgress = remainingInSegment > double.Epsilon ? targetDistance / remainingInSegment : 0.0;
            var start = vertices[currentSegment];
            var end = vertices[currentSegment + 1];
            var interpolated = segmentProgress <= 0 ? start : (segmentProgress >= 1 ? end : GreatCircleInterpolate(start, end, segmentProgress));
            samples[i] = new SampledPoint(interpolated, currentSegment, Math.Clamp(segmentProgress, 0, 1));
        }
        return samples;
    }

    private static SampledPoint[] SampleByChordLength(Vector3d[] vertices, int sampleCount, bool includeEndpoints)
    {
        var segmentLengths = new double[vertices.Length - 1];
        var totalLength = 0.0;
        for (var i = 0; i < vertices.Length - 1; i++)
        {
            segmentLengths[i] = (vertices[i + 1] - vertices[i]).Length();
            totalLength += segmentLengths[i];
        }
        if (totalLength < double.Epsilon) return new[] { new SampledPoint(vertices[0], 0, 0) };

        var effectiveCount = includeEndpoints ? sampleCount : sampleCount - 2;
        var effectiveStart = includeEndpoints ? 0 : 1;
        var effectiveEnd = includeEndpoints ? sampleCount - 1 : sampleCount - 2;
        var samples = new SampledPoint[sampleCount];

        if (includeEndpoints)
        {
            samples[0] = new SampledPoint(vertices[0], 0, 0);
            samples[sampleCount - 1] = new SampledPoint(vertices[^1], vertices.Length - 2, 1);
        }

        var currentSegment = 0;
        var remainingInSegment = segmentLengths.Length > 0 ? segmentLengths[0] : 0;

        for (var i = effectiveStart; i <= effectiveEnd; i++)
        {
            var targetDistance = (i * totalLength) / (effectiveCount + 1);
            while (currentSegment < segmentLengths.Length - 1 && targetDistance > totalLength - remainingInSegment)
            {
                targetDistance -= remainingInSegment;
                currentSegment++;
                remainingInSegment = segmentLengths[currentSegment];
            }
            var segmentProgress = remainingInSegment > double.Epsilon ? targetDistance / remainingInSegment : 0.0;
            var interpolated = vertices[currentSegment] + (vertices[currentSegment + 1] - vertices[currentSegment]) * segmentProgress;
            samples[i] = new SampledPoint(interpolated, currentSegment, Math.Clamp(segmentProgress, 0, 1));
        }
        return samples;
    }

    private static double GreatCircleDistance(Vector3d a, Vector3d b)
    {
        var dot = a.Dot(b);
        var cross = a.Cross(b).Length();
        return Math.Atan2(cross, dot);
    }

    private static Vector3d GreatCircleInterpolate(Vector3d a, Vector3d b, double t)
    {
        var aNorm = a.LengthSquared() > 0.9 && a.LengthSquared() < 1.1 ? a : a.Normalize();
        var bNorm = b.LengthSquared() > 0.9 && b.LengthSquared() < 1.1 ? b : b.Normalize();
        var dot = Math.Clamp(aNorm.Dot(bNorm), -1.0, 1.0);
        var angle = Math.Acos(dot);
        if (angle < double.Epsilon) return aNorm;
        var sinAngle = Math.Sin(angle);
        return aNorm * (Math.Sin((1 - t) * angle) / sinAngle) + bNorm * (Math.Sin(t * angle) / sinAngle);
    }

    private BoundaryVelocitySample ComputeSampleVelocity(
        SampledPoint sampledPoint, Vector3d[] vertices, PlateId leftPlateId, PlateId rightPlateId,
        AngularVelocity3d leftOmega, AngularVelocity3d rightOmega, CanonicalTick tick,
        IPlateKinematicsStateView kinematics, int sampleIndex)
    {
        var position = sampledPoint.Position;
        var vLeft = leftOmega.GetLinearVelocityAt(position.X, position.Y, position.Z);
        var vRight = rightOmega.GetLinearVelocityAt(position.X, position.Y, position.Z);
        var vRel = vRight - vLeft;
        var tangent = ComputeTangentFromSegment(sampledPoint, vertices);
        var normal = ComputeNormal(position, tangent, leftPlateId, rightPlateId);
        return new BoundaryVelocitySample(position, vRel, tangent, normal, vRel.Dot(tangent), vRel.Dot(normal), sampleIndex);
    }

    private static Vector3d ComputeTangentFromSegment(SampledPoint sampledPoint, Vector3d[] vertices)
    {
        var segmentIndex = sampledPoint.SegmentIndex;
        if (segmentIndex < 0 || segmentIndex >= vertices.Length - 1)
        {
            if (segmentIndex == vertices.Length - 1 && vertices.Length > 1) segmentIndex = vertices.Length - 2;
            else return Vector3d.UnitZ;
        }
        var start = vertices[segmentIndex];
        var end = vertices[segmentIndex + 1];
        var direction = end - start;
        var length = direction.Length();
        if (length < double.Epsilon)
        {
            if (segmentIndex > 0) { start = vertices[segmentIndex - 1]; end = vertices[segmentIndex]; direction = end - start; length = direction.Length(); }
            if (length < double.Epsilon) return Vector3d.UnitZ;
        }
        return direction / length;
    }

    /// <summary>
    /// Computes the boundary normal vector pointing from left plate toward right plate.
    ///
    /// The normal is computed as position × tangent (perpendicular to both the radial
    /// direction and the boundary tangent on the sphere surface). The sign is then
    /// chosen deterministically based on PlateId ordering:
    /// - If leftPlateId &lt; rightPlateId: normal points in cross product direction
    /// - If leftPlateId &gt; rightPlateId: normal points in negated cross product direction
    ///
    /// This ensures reproducible normal orientation across runs while maintaining
    /// the convention that positive normal rate indicates plates moving apart (divergent)
    /// and negative normal rate indicates plates moving together (convergent).
    /// </summary>
    private static Vector3d ComputeNormal(Vector3d position, Vector3d tangent, PlateId leftPlateId, PlateId rightPlateId)
    {
        // Compute the normal as position × tangent (perpendicular on sphere surface)
        var crossProduct = position.Cross(tangent);
        var crossLength = crossProduct.Length();

        if (crossLength < double.Epsilon)
        {
            // Degenerate case: use arbitrary perpendicular
            var arbitrary = Math.Abs(position.Dot(Vector3d.UnitX)) > 0.9 ? Vector3d.UnitY : Vector3d.UnitX;
            crossProduct = position.Cross(arbitrary).Normalize();
        }
        else
        {
            crossProduct = crossProduct / crossLength;
        }

        // Flip normal based on deterministic PlateId ordering rule:
        // Normal points from the plate with smaller ID toward the plate with larger ID.
        // This ensures consistent orientation regardless of which side is labeled "left".
        var shouldFlip = leftPlateId.Value > rightPlateId.Value;
        return shouldFlip ? -crossProduct : crossProduct;
    }

    private static BoundaryVelocityProfile ComputeAggregates(BoundaryId boundaryId, BoundaryVelocitySample[] samples)
    {
        if (samples.Length == 0)
            return new BoundaryVelocityProfile(boundaryId, 0, 0, 0, 0, 0, 0, 0);
        var minNormal = double.MaxValue; var maxNormal = double.MinValue;
        var sumNormal = 0.0; var sumSlip = 0.0; var minIndex = 0; var maxIndex = 0;
        for (var i = 0; i < samples.Length; i++)
        {
            var normalRate = samples[i].NormalRate;
            var slipRate = Math.Abs(samples[i].TangentialRate);
            if (normalRate < minNormal) { minNormal = normalRate; minIndex = i; }
            if (normalRate > maxNormal) { maxNormal = normalRate; maxIndex = i; }
            sumNormal += normalRate; sumSlip += slipRate;
        }
        return new BoundaryVelocityProfile(boundaryId, samples.Length, minNormal, maxNormal, sumNormal / samples.Length, sumSlip / samples.Length, minIndex, maxIndex);
    }

    private static BoundaryVelocityProfile CreateEmptyProfile(BoundaryId boundaryId)
        => new(boundaryId, 0, 0, 0, 0, 0, 0, 0);

    private static Vector3d ComputeMidpoint(Vector3d a, Vector3d b)
        => new((a.X + b.X) / 2, (a.Y + b.Y) / 2, (a.Z + b.Z) / 2);
}


// --- PATH: plugins/Raster.Core/ArrayRasterFrame.cs ---
﻿using Plate.TimeDete.Time.Primitives;
using FantaSim.Raster.Contracts;

namespace FantaSim.Raster.Core;

/// <summary>
/// A raster frame backed by an in-memory array of doubles.
/// This is the standard implementation for masked frames and intermediate results.
/// RFC-V2-0028 §2 compliant.
/// </summary>
/// <remarks>
/// <para>
/// This is a domain-agnostic implementation. It knows nothing about plates,
/// polygons, or topology. It simply stores a 2D grid of values with metadata.
/// </para>
/// <para>
/// For plate-specific masking, see <c>Geosphere.Plate.Raster.Masking.Plates</c>.
/// </para>
/// </remarks>
public sealed class ArrayRasterFrame : IRasterFrame
{
    private readonly double[] _data;
    private readonly double? _noDataValue;

    /// <summary>
    /// Creates a new ArrayRasterFrame.
    /// </summary>
    /// <param name="tick">The tick this frame represents.</param>
    /// <param name="width">Width in pixels (columns).</param>
    /// <param name="height">Height in pixels (rows).</param>
    /// <param name="bounds">Geographic bounds.</param>
    /// <param name="dataType">Data type of cell values.</param>
    /// <param name="data">Row-major array of values (length = width × height).</param>
    /// <param name="noDataValue">Value indicating no-data (null if not specified).</param>
    public ArrayRasterFrame(
        CanonicalTick tick,
        int width,
        int height,
        RasterBounds bounds,
        RasterDataType dataType,
        double[] data,
        double? noDataValue)
    {
        if (data == null)
            throw new ArgumentNullException(nameof(data));
        if (data.Length != width * height)
            throw new ArgumentException($"Data length ({data.Length}) must equal width × height ({width * height}).", nameof(data));

        Tick = tick;
        Width = width;
        Height = height;
        Bounds = bounds;
        DataType = dataType;
        _data = data;
        _noDataValue = noDataValue;
    }

    /// <inheritdoc />
    public CanonicalTick Tick { get; }

    /// <inheritdoc />
    public int Width { get; }

    /// <inheritdoc />
    public int Height { get; }

    /// <inheritdoc />
    public RasterBounds Bounds { get; }

    /// <inheritdoc />
    public RasterDataType DataType { get; }

    /// <inheritdoc />
    public double? NoDataValue => _noDataValue;

    /// <inheritdoc />
    public ReadOnlySpan<byte> GetRawData()
    {
        var bytes = new byte[_data.Length * sizeof(double)];
        Buffer.BlockCopy(_data, 0, bytes, 0, bytes.Length);
        return bytes;
    }

    /// <inheritdoc />
    public double? GetValue(int row, int col)
    {
        if (row < 0 || row >= Height)
            throw new ArgumentOutOfRangeException(nameof(row));
        if (col < 0 || col >= Width)
            throw new ArgumentOutOfRangeException(nameof(col));

        var index = row * Width + col;
        var value = _data[index];

        if (IsNoDataValue(value))
            return null;

        return value;
    }

    /// <inheritdoc />
    public double? GetValueAt(double longitude, double latitude)
    {
        if (!Bounds.Contains(longitude, latitude))
            return null;

        var cellWidth = Bounds.Width / Width;
        var cellHeight = Bounds.Height / Height;

        var col = (int)((longitude - Bounds.MinLongitude) / cellWidth);
        var row = (int)((Bounds.MaxLatitude - latitude) / cellHeight);

        col = Math.Clamp(col, 0, Width - 1);
        row = Math.Clamp(row, 0, Height - 1);

        return GetValue(row, col);
    }

    /// <summary>
    /// Gets all values as a flat array (copy).
    /// </summary>
    public double[] GetAllValues()
    {
        return _data.ToArray();
    }

    /// <summary>
    /// Gets the internal data array directly (no copy).
    /// Use with caution - modifications affect the frame.
    /// </summary>
    internal ReadOnlySpan<double> GetDataSpan() => _data;

    private bool IsNoDataValue(double value)
    {
        if (!_noDataValue.HasValue)
            return double.IsNaN(value);

        var noData = _noDataValue.Value;

        if (double.IsNaN(noData))
            return double.IsNaN(value);
        if (double.IsInfinity(noData))
            return double.IsInfinity(value) && Math.Sign(noData) == Math.Sign(value);

        const double tolerance = 1e-10;
        return Math.Abs(value - noData) < tolerance;
    }
}


// --- PATH: plugins/Raster.Core/BoundsRasterMask.cs ---
﻿using FantaSim.Raster.Contracts;
using FantaSim.Raster.Contracts.Masking;

namespace FantaSim.Raster.Core;

/// <summary>
/// A mask based on geographic bounds.
/// Pixels inside/outside the specified bounds are masked.
/// RFC-V2-0028 §3.3 compliant.
/// </summary>
/// <remarks>
/// This is a domain-agnostic mask. It knows nothing about plates or topology.
/// For plate-specific masks, see <c>Geosphere.Plate.Raster.Masking.Plates</c>.
/// </remarks>
public sealed class BoundsRasterMask : IRasterMask
{
    private readonly RasterBounds _bounds;
    private readonly bool _includeInterior;

    /// <summary>
    /// Creates a new BoundsRasterMask.
    /// </summary>
    /// <param name="bounds">The geographic bounds to use for masking.</param>
    /// <param name="includeInterior">True to include pixels inside bounds, false to exclude them.</param>
    public BoundsRasterMask(RasterBounds bounds, bool includeInterior)
    {
        _bounds = bounds;
        _includeInterior = includeInterior;
    }

    /// <summary>
    /// The bounds used for masking.
    /// </summary>
    public RasterBounds Bounds => _bounds;

    /// <summary>
    /// Whether pixels inside the bounds are included (true) or excluded (false).
    /// </summary>
    public bool IncludeInterior => _includeInterior;

    /// <inheritdoc />
    public IRasterFrame ApplyMask(IRasterFrame sourceFrame, double noDataValue)
    {
        if (sourceFrame == null)
            throw new ArgumentNullException(nameof(sourceFrame));

        var rawData = sourceFrame.GetRawData();
        var sourceData = new double[rawData.Length / sizeof(double)];
        Buffer.BlockCopy(rawData.ToArray(), 0, sourceData, 0, rawData.Length);

        var maskedData = new double[sourceData.Length];

        for (int row = 0; row < sourceFrame.Height; row++)
        {
            for (int col = 0; col < sourceFrame.Width; col++)
            {
                var index = row * sourceFrame.Width + col;
                var value = sourceData[index];

                // Calculate geographic coordinates
                var lon = sourceFrame.Bounds.MinLongitude +
                    (col / (double)sourceFrame.Width) * sourceFrame.Bounds.Width;
                var lat = sourceFrame.Bounds.MaxLatitude -
                    (row / (double)sourceFrame.Height) * sourceFrame.Bounds.Height;

                // Check if point is in mask region
                var inMask = Contains(lon, lat);
                var shouldInclude = _includeInterior ? inMask : !inMask;

                maskedData[index] = shouldInclude ? value : noDataValue;
            }
        }

        return new ArrayRasterFrame(
            sourceFrame.Tick,
            sourceFrame.Width,
            sourceFrame.Height,
            sourceFrame.Bounds,
            sourceFrame.DataType,
            maskedData,
            noDataValue);
    }

    /// <inheritdoc />
    public bool Contains(double longitude, double latitude)
    {
        return _bounds.Contains(longitude, latitude);
    }
}


// --- PATH: plugins/Raster.Core/Internal/SimpleRasterFrame.cs ---
﻿using FantaSim.Raster.Contracts;
using Plate.TimeDete.Time.Primitives;

namespace FantaSim.Raster.Core;

/// <summary>
/// Simple raster frame wrapper for query results and temporary frame data.
/// </summary>
/// <remarks>
/// This is an internal helper for wrapping byte arrays as <see cref="IRasterFrame"/>.
/// For most use cases, prefer <see cref="ArrayRasterFrame"/> instead.
/// </remarks>
internal sealed class SimpleRasterFrame : IRasterFrame
{
    private readonly byte[] _data;
    private readonly CanonicalTick _tick;

    public SimpleRasterFrame(
        int width,
        int height,
        RasterBounds bounds,
        RasterDataType dataType,
        byte[] data,
        double? noDataValue,
        CanonicalTick? tick = null)
    {
        Width = width;
        Height = height;
        Bounds = bounds;
        DataType = dataType;
        _data = data;
        NoDataValue = noDataValue;
        _tick = tick ?? CanonicalTick.Genesis;
    }

    public CanonicalTick Tick => _tick;
    public int Width { get; }
    public int Height { get; }
    public RasterBounds Bounds { get; }
    public RasterDataType DataType { get; }
    public double? NoDataValue { get; }

    public ReadOnlySpan<byte> GetRawData() => _data;

    public double? GetValue(int row, int col)
    {
        if (row < 0 || row >= Height)
            throw new ArgumentOutOfRangeException(nameof(row));
        if (col < 0 || col >= Width)
            throw new ArgumentOutOfRangeException(nameof(col));

        var index = row * Width + col;
        var bytes = new byte[sizeof(double)];
        Array.Copy(_data, index * sizeof(double), bytes, 0, sizeof(double));
        var value = BitConverter.ToDouble(bytes, 0);

        if (NoDataValue.HasValue)
        {
            var noData = NoDataValue.Value;
            if (double.IsNaN(noData) && double.IsNaN(value))
                return null;
            if (Math.Abs(value - noData) < 1e-10)
                return null;
        }
        else if (double.IsNaN(value))
        {
            return null;
        }

        return value;
    }

    public double? GetValueAt(double longitude, double latitude)
    {
        if (!Bounds.Contains(longitude, latitude))
            return null;

        var cellWidth = Bounds.Width / Width;
        var cellHeight = Bounds.Height / Height;

        var col = (int)((longitude - Bounds.MinLongitude) / cellWidth);
        var row = (int)((Bounds.MaxLatitude - latitude) / cellHeight);

        col = Math.Clamp(col, 0, Width - 1);
        row = Math.Clamp(row, 0, Height - 1);

        return GetValue(row, col);
    }
}


// --- PATH: plugins/Raster.Core/MaskedRasterSequence.cs ---
﻿using System.Collections.Immutable;
using Plate.TimeDete.Time.Primitives;
using FantaSim.Raster.Contracts;
using FantaSim.Raster.Contracts.Masking;

namespace FantaSim.Raster.Core;

/// <summary>
/// A raster sequence that applies masking to frames from a source sequence.
/// RFC-V2-0028 §3.3 compliant.
/// </summary>
/// <remarks>
/// <para>
/// This is the domain-agnostic base implementation. It applies any <see cref="IRasterMask"/>
/// to frames from a source sequence on demand.
/// </para>
/// <para>
/// For plate-specific masking, see <c>Geosphere.Plate.Raster.Masking.Plates</c>.
/// </para>
/// </remarks>
public class MaskedRasterSequence : IMaskedRasterSequence
{
    private readonly IRasterSequence _sourceSequence;
    private readonly IRasterMask _mask;
    private readonly double _noDataValue;

    /// <summary>
    /// Creates a new MaskedRasterSequence.
    /// </summary>
    /// <param name="sourceSequence">The source raster sequence to mask.</param>
    /// <param name="mask">The mask to apply to frames.</param>
    /// <param name="noDataValue">Value to use for masked-out pixels.</param>
    public MaskedRasterSequence(
        IRasterSequence sourceSequence,
        IRasterMask mask,
        double noDataValue)
    {
        _sourceSequence = sourceSequence ?? throw new ArgumentNullException(nameof(sourceSequence));
        _mask = mask ?? throw new ArgumentNullException(nameof(mask));
        _noDataValue = noDataValue;
    }

    /// <inheritdoc />
    public string SequenceId => $"{_sourceSequence.SequenceId}_masked";

    /// <inheritdoc />
    public string DisplayName => $"{_sourceSequence.DisplayName} (Masked)";

    /// <inheritdoc />
    public ImmutableArray<CanonicalTick> AvailableTicks => _sourceSequence.AvailableTicks;

    /// <inheritdoc />
    public RasterMetadata Metadata => _sourceSequence.Metadata;

    /// <inheritdoc />
    public IRasterSequence SourceSequence => _sourceSequence;

    /// <inheritdoc />
    public IRasterMask Mask => _mask;

    /// <summary>
    /// The no-data value used for masked pixels.
    /// </summary>
    protected double NoDataValue => _noDataValue;

    /// <inheritdoc />
    public IRasterFrame? GetFrameAt(CanonicalTick tick)
    {
        var sourceFrame = _sourceSequence.GetFrameAt(tick);
        if (sourceFrame == null)
            return null;

        return _mask.ApplyMask(sourceFrame, _noDataValue);
    }

    /// <inheritdoc />
    public RasterQueryResult QueryAt(CanonicalTick tick, RasterQueryOptions? options = null)
    {
        var sourceResult = _sourceSequence.QueryAt(tick, options);

        if (!sourceResult.HasData)
            return sourceResult;

        var frameData = sourceResult.FrameData!.Value;

        // Apply mask to the frame data
        var maskedFrame = _mask.ApplyMask(
            new SimpleRasterFrame(
                frameData.Width,
                frameData.Height,
                frameData.Bounds,
                frameData.DataType,
                frameData.RawData,
                frameData.NoDataValue),
            _noDataValue);

        var rawData = maskedFrame.GetRawData().ToArray();
        var maskedData = new RasterFrameData(
            maskedFrame.Width,
            maskedFrame.Height,
            maskedFrame.Bounds,
            maskedFrame.DataType,
            maskedFrame.NoDataValue,
            rawData);

        if (sourceResult.IsInterpolated)
        {
            return RasterQueryResult.Interpolated(
                tick,
                sourceResult.SourceFrameTick ?? CanonicalTick.Genesis,
                sourceResult.InterpolationWeight ?? 0,
                maskedData);
        }

        return RasterQueryResult.Exact(tick, maskedData);
    }

    /// <inheritdoc />
    public IEnumerable<IRasterFrame> GetFramesInRange(CanonicalTick startTick, CanonicalTick endTick)
    {
        return _sourceSequence
            .GetFramesInRange(startTick, endTick)
            .Select(frame => _mask.ApplyMask(frame, _noDataValue))
            .ToList();
    }
}


// --- PATH: plugins/Raster.Core/Operations/RasterCropper.cs ---
﻿using FantaSim.Raster.Contracts;

namespace FantaSim.Raster.Core.Operations;

/// <summary>
/// Crops a raster frame to a specified bounding box.
/// </summary>
public static class RasterCropper
{
    /// <summary>
    /// Crops a raster frame to the specified bounds.
    /// </summary>
    /// <param name="frame">The source frame to crop.</param>
    /// <param name="targetBounds">The bounds to crop to.</param>
    /// <returns>A new frame containing only the pixels within the target bounds.</returns>
    /// <exception cref="ArgumentException">Thrown if target bounds don't overlap with frame bounds.</exception>
    public static IRasterFrame Crop(IRasterFrame frame, RasterBounds targetBounds)
    {
        if (frame == null)
            throw new ArgumentNullException(nameof(frame));

        // Calculate the intersection of frame bounds and target bounds
        var intersection = Intersect(frame.Bounds, targetBounds);
        if (intersection == null)
            throw new ArgumentException("Target bounds do not overlap with frame bounds.", nameof(targetBounds));

        var intersectedBounds = intersection.Value;

        // Calculate pixel coordinates of the intersection
        var cellWidth = frame.Bounds.Width / frame.Width;
        var cellHeight = frame.Bounds.Height / frame.Height;

        var startCol = (int)Math.Floor((intersectedBounds.MinLongitude - frame.Bounds.MinLongitude) / cellWidth);
        var endCol = (int)Math.Ceiling((intersectedBounds.MaxLongitude - frame.Bounds.MinLongitude) / cellWidth);
        var startRow = (int)Math.Floor((frame.Bounds.MaxLatitude - intersectedBounds.MaxLatitude) / cellHeight);
        var endRow = (int)Math.Ceiling((frame.Bounds.MaxLatitude - intersectedBounds.MinLatitude) / cellHeight);

        // Clamp to frame dimensions
        startCol = Math.Clamp(startCol, 0, frame.Width);
        endCol = Math.Clamp(endCol, 0, frame.Width);
        startRow = Math.Clamp(startRow, 0, frame.Height);
        endRow = Math.Clamp(endRow, 0, frame.Height);

        var newWidth = endCol - startCol;
        var newHeight = endRow - startRow;

        if (newWidth <= 0 || newHeight <= 0)
            throw new ArgumentException("Cropped region has zero size.", nameof(targetBounds));

        // Extract the cropped data
        var croppedData = new double[newWidth * newHeight];

        for (int row = 0; row < newHeight; row++)
        {
            for (int col = 0; col < newWidth; col++)
            {
                var sourceRow = startRow + row;
                var sourceCol = startCol + col;
                var value = frame.GetValue(sourceRow, sourceCol);
                croppedData[row * newWidth + col] = value ?? (frame.NoDataValue ?? double.NaN);
            }
        }

        // Calculate actual bounds of cropped region
        // RasterBounds(MinLon, MaxLon, MinLat, MaxLat)
        var actualBounds = new RasterBounds(
            frame.Bounds.MinLongitude + startCol * cellWidth,  // MinLon
            frame.Bounds.MinLongitude + endCol * cellWidth,    // MaxLon
            frame.Bounds.MaxLatitude - endRow * cellHeight,    // MinLat
            frame.Bounds.MaxLatitude - startRow * cellHeight); // MaxLat

        return new ArrayRasterFrame(
            frame.Tick,
            newWidth,
            newHeight,
            actualBounds,
            frame.DataType,
            croppedData,
            frame.NoDataValue);
    }

    private static RasterBounds? Intersect(RasterBounds a, RasterBounds b)
    {
        var minLon = Math.Max(a.MinLongitude, b.MinLongitude);
        var maxLon = Math.Min(a.MaxLongitude, b.MaxLongitude);
        var minLat = Math.Max(a.MinLatitude, b.MinLatitude);
        var maxLat = Math.Min(a.MaxLatitude, b.MaxLatitude);

        if (minLon >= maxLon || minLat >= maxLat)
            return null;

        // RasterBounds(MinLon, MaxLon, MinLat, MaxLat)
        return new RasterBounds(minLon, maxLon, minLat, maxLat);
    }
}


// --- PATH: plugins/Raster.Core/Operations/RasterMaskApplier.cs ---
﻿using FantaSim.Raster.Contracts;
using FantaSim.Raster.Contracts.Masking;

namespace FantaSim.Raster.Core.Operations;

/// <summary>
/// Applies a mask to a raster frame.
/// </summary>
/// <remarks>
/// This is a stateless operation helper. The actual masking logic is in the mask implementations.
/// </remarks>
public static class RasterMaskApplier
{
    /// <summary>
    /// Applies a mask to a raster frame, returning a new frame with masked pixels set to no-data.
    /// </summary>
    /// <param name="frame">The source frame to mask.</param>
    /// <param name="mask">The mask to apply.</param>
    /// <param name="noDataValue">Value to use for masked-out pixels (default: NaN).</param>
    /// <returns>A new frame with the mask applied.</returns>
    public static IRasterFrame Apply(IRasterFrame frame, IRasterMask mask, double noDataValue = double.NaN)
    {
        if (frame == null)
            throw new ArgumentNullException(nameof(frame));
        if (mask == null)
            throw new ArgumentNullException(nameof(mask));

        return mask.ApplyMask(frame, noDataValue);
    }
}


// --- PATH: plugins/Raster.Core/Operations/RasterResampler.cs ---
﻿using FantaSim.Raster.Contracts;

namespace FantaSim.Raster.Core.Operations;

/// <summary>
/// Resamples a raster frame to a different resolution.
/// </summary>
public static class RasterResampler
{
    /// <summary>
    /// Resamples a raster frame to the specified dimensions.
    /// </summary>
    /// <param name="frame">The source frame to resample.</param>
    /// <param name="targetWidth">Target width in pixels.</param>
    /// <param name="targetHeight">Target height in pixels.</param>
    /// <param name="method">Interpolation method to use.</param>
    /// <returns>A new frame with the resampled data.</returns>
    public static IRasterFrame Resample(
        IRasterFrame frame,
        int targetWidth,
        int targetHeight,
        InterpolationMethod method = InterpolationMethod.Linear)
    {
        if (frame == null)
            throw new ArgumentNullException(nameof(frame));
        if (targetWidth <= 0)
            throw new ArgumentOutOfRangeException(nameof(targetWidth));
        if (targetHeight <= 0)
            throw new ArgumentOutOfRangeException(nameof(targetHeight));

        var resampledData = new double[targetWidth * targetHeight];
        var noData = frame.NoDataValue ?? double.NaN;

        var targetCellWidth = frame.Bounds.Width / targetWidth;
        var targetCellHeight = frame.Bounds.Height / targetHeight;

        for (int row = 0; row < targetHeight; row++)
        {
            for (int col = 0; col < targetWidth; col++)
            {
                // Calculate geographic coordinates of target pixel center
                var lon = frame.Bounds.MinLongitude + (col + 0.5) * targetCellWidth;
                var lat = frame.Bounds.MaxLatitude - (row + 0.5) * targetCellHeight;

                var value = method switch
                {
                    InterpolationMethod.NearestNeighbor => SampleNearest(frame, lon, lat),
                    InterpolationMethod.Linear => SampleBilinear(frame, lon, lat),
                    _ => SampleBilinear(frame, lon, lat)
                };

                resampledData[row * targetWidth + col] = value ?? noData;
            }
        }

        return new ArrayRasterFrame(
            frame.Tick,
            targetWidth,
            targetHeight,
            frame.Bounds,
            frame.DataType,
            resampledData,
            frame.NoDataValue);
    }

    /// <summary>
    /// Resamples a raster frame by a scale factor.
    /// </summary>
    /// <param name="frame">The source frame to resample.</param>
    /// <param name="scaleFactor">Scale factor (2.0 = double resolution, 0.5 = half resolution).</param>
    /// <param name="method">Interpolation method to use.</param>
    public static IRasterFrame ResampleByFactor(
        IRasterFrame frame,
        double scaleFactor,
        InterpolationMethod method = InterpolationMethod.Linear)
    {
        var targetWidth = (int)Math.Max(1, Math.Round(frame.Width * scaleFactor));
        var targetHeight = (int)Math.Max(1, Math.Round(frame.Height * scaleFactor));
        return Resample(frame, targetWidth, targetHeight, method);
    }

    private static double? SampleNearest(IRasterFrame frame, double lon, double lat)
    {
        return frame.GetValueAt(lon, lat);
    }

    private static double? SampleBilinear(IRasterFrame frame, double lon, double lat)
    {
        if (!frame.Bounds.Contains(lon, lat))
            return null;

        var cellWidth = frame.Bounds.Width / frame.Width;
        var cellHeight = frame.Bounds.Height / frame.Height;

        // Calculate fractional pixel coordinates
        var x = (lon - frame.Bounds.MinLongitude) / cellWidth - 0.5;
        var y = (frame.Bounds.MaxLatitude - lat) / cellHeight - 0.5;

        var x0 = (int)Math.Floor(x);
        var y0 = (int)Math.Floor(y);
        var x1 = x0 + 1;
        var y1 = y0 + 1;

        var xFrac = x - x0;
        var yFrac = y - y0;

        // Clamp to valid range
        x0 = Math.Clamp(x0, 0, frame.Width - 1);
        x1 = Math.Clamp(x1, 0, frame.Width - 1);
        y0 = Math.Clamp(y0, 0, frame.Height - 1);
        y1 = Math.Clamp(y1, 0, frame.Height - 1);

        // Get four corner values
        var v00 = frame.GetValue(y0, x0);
        var v10 = frame.GetValue(y0, x1);
        var v01 = frame.GetValue(y1, x0);
        var v11 = frame.GetValue(y1, x1);

        // If any corner is no-data, use nearest neighbor instead
        if (!v00.HasValue || !v10.HasValue || !v01.HasValue || !v11.HasValue)
        {
            return SampleNearest(frame, lon, lat);
        }

        // Bilinear interpolation
        var top = v00.Value * (1 - xFrac) + v10.Value * xFrac;
        var bottom = v01.Value * (1 - xFrac) + v11.Value * xFrac;
        var result = top * (1 - yFrac) + bottom * yFrac;

        return result;
    }
}


// --- PATH: plugins/Raster.GeoTiff/GeoTiffRasterExporter.cs ---
using System.Collections.Immutable;
using Plate.TimeDete.Time.Primitives;
using FantaSim.Raster.Contracts;
using FantaSim.Raster.Contracts.Export;
using BitMiracle.LibTiff.Classic;

namespace FantaSim.Raster.GeoTiff;

/// <summary>
/// Exports raster sequences to GeoTiff format.
/// Supports single-frame and multi-frame (time-series) exports.
/// RFC-V2-0028 compliant.
/// </summary>
public sealed class GeoTiffRasterExporter : IRasterSequenceExporter
{
    // GeoTiff tag constants (not in BitMiracle.LibTiff.Classic.TiffTag)
    private const TiffTag TIFFTAG_GEOPIXELSCALE = (TiffTag)33550;
    private const TiffTag TIFFTAG_GEOTIEPOINTS = (TiffTag)33922;
    private const TiffTag TIFFTAG_GEOKEYDIRECTORY = (TiffTag)34735;

    // Static flag to ensure tag extender is registered only once
    private static bool _geoTiffTagsRegistered;
    private static readonly object _registrationLock = new();

    /// <summary>
    /// Supported export formats.
    /// </summary>
    public static readonly IReadOnlyCollection<RasterExportFormat> SupportedFormatsList = new[]
    {
        RasterExportFormat.GeoTiff
    };

    /// <inheritdoc />
    public IReadOnlyCollection<RasterExportFormat> SupportedFormats => SupportedFormatsList;

    /// <summary>
    /// Static constructor to register GeoTiff tags with LibTiff.NET.
    /// </summary>
    static GeoTiffRasterExporter()
    {
        EnsureGeoTiffTagsRegistered();
    }

    /// <summary>
    /// Ensures GeoTiff custom tags are registered with LibTiff.NET.
    /// This is required for writing GeoTiff-specific tags.
    /// </summary>
    private static void EnsureGeoTiffTagsRegistered()
    {
        if (_geoTiffTagsRegistered)
            return;

        lock (_registrationLock)
        {
            if (_geoTiffTagsRegistered)
                return;

            // Get the parent tag extender (if any)
            var parentExtender = Tiff.SetTagExtender(GeoTiffTagExtender);

            // If there was a parent, we need to chain to it
            if (parentExtender != null)
            {
                _parentTagExtender = parentExtender;
            }

            _geoTiffTagsRegistered = true;
        }
    }

    private static Tiff.TiffExtendProc? _parentTagExtender;

    /// <summary>
    /// Tag extender that adds GeoTiff tag definitions.
    /// </summary>
    private static void GeoTiffTagExtender(Tiff tiff)
    {
        // Call parent extender first if present
        _parentTagExtender?.Invoke(tiff);

        // Register GeoTiff tags
        var geoTiffTags = new TiffFieldInfo[]
        {
            new(TIFFTAG_GEOPIXELSCALE, TiffFieldInfo.Variable, TiffFieldInfo.Variable,
                TiffType.DOUBLE, FieldBit.Custom, true, true, "GeoPixelScale"),
            new(TIFFTAG_GEOTIEPOINTS, TiffFieldInfo.Variable, TiffFieldInfo.Variable,
                TiffType.DOUBLE, FieldBit.Custom, true, true, "GeoTiePoints"),
            new(TIFFTAG_GEOKEYDIRECTORY, TiffFieldInfo.Variable, TiffFieldInfo.Variable,
                TiffType.SHORT, FieldBit.Custom, true, true, "GeoKeyDirectory"),
        };

        tiff.MergeFieldInfo(geoTiffTags, geoTiffTags.Length);
    }

    /// <inheritdoc />
    public async Task<RasterExportResult> ExportAsync(
        IRasterSequence sequence,
        RasterExportSpec spec,
        CancellationToken cancellationToken = default)
    {
        ArgumentNullException.ThrowIfNull(sequence);

        // Validate spec
        if (!spec.IsValid(out var validationError))
        {
            return RasterExportResult.Failed(RasterExportError.InvalidSpec(validationError ?? "Invalid specification"));
        }

        var outputFiles = new List<string>();
        var errors = new List<RasterExportError>();
        var framesExported = 0;

        try
        {
            // Ensure output directory exists
            if (!Directory.Exists(spec.OutputDirectory))
            {
                Directory.CreateDirectory(spec.OutputDirectory);
            }

            // Get ticks to export using the spec's built-in method
            var ticksToExport = spec.GetExportTicks().ToList();

            if (ticksToExport.Count == 0)
            {
                errors.Add(RasterExportError.InvalidSpec("No frames to export in the specified tick range"));
                return RasterExportResult.Failed(errors.ToArray());
            }

            // Get CRS from sequence metadata (planet-agnostic: may be null)
            var coordinateSystem = sequence.Metadata.CoordinateSystem;

            // Export each frame
            foreach (var tick in ticksToExport)
            {
                cancellationToken.ThrowIfCancellationRequested();

                var frame = sequence.GetFrameAt(tick);
                if (frame == null)
                {
                    errors.Add(RasterExportError.MissingFrame($"Frame not found at tick {tick.Value}"));
                    continue;
                }

                var fileName = spec.GetOutputFileName(tick);
                var filePath = Path.Combine(spec.OutputDirectory, fileName);

                // Ensure .tif extension
                if (!filePath.EndsWith(".tif", StringComparison.OrdinalIgnoreCase) &&
                    !filePath.EndsWith(".tiff", StringComparison.OrdinalIgnoreCase))
                {
                    filePath += ".tif";
                }

                var success = await ExportFrameAsync(frame, filePath, coordinateSystem, cancellationToken).ConfigureAwait(false);

                if (success)
                {
                    outputFiles.Add(filePath);
                    framesExported++;
                }
                else
                {
                    errors.Add(RasterExportError.FormatError($"Failed to export frame at tick {tick.Value}", filePath));
                }
            }

            return new RasterExportResult(
                Success: errors.Count == 0,
                OutputFiles: outputFiles,
                Errors: errors,
                FramesExported: framesExported);
        }
        catch (OperationCanceledException)
        {
            return new RasterExportResult(
                Success: false,
                OutputFiles: outputFiles,
                Errors: errors,
                FramesExported: framesExported);
        }
        catch (Exception ex)
        {
            errors.Add(RasterExportError.IOError($"Export failed: {ex.Message}"));
            return RasterExportResult.Failed(errors.ToArray());
        }
    }

    /// <summary>
    /// Exports a single frame to GeoTiff.
    /// </summary>
    private static async Task<bool> ExportFrameAsync(
        IRasterFrame frame,
        string filePath,
        string? coordinateSystem,
        CancellationToken cancellationToken)
    {
        return await Task.Run(() =>
        {
            try
            {
                // Ensure directory exists
                var directory = Path.GetDirectoryName(filePath);
                if (!string.IsNullOrEmpty(directory) && !Directory.Exists(directory))
                {
                    Directory.CreateDirectory(directory);
                }

                // Create GeoTiff file
                using var tiff = Tiff.Open(filePath, "w");
                if (tiff == null)
                    return false;

                // Set basic tags
                tiff.SetField(TiffTag.IMAGEWIDTH, frame.Width);
                tiff.SetField(TiffTag.IMAGELENGTH, frame.Height);
                tiff.SetField(TiffTag.SAMPLESPERPIXEL, 1);
                tiff.SetField(TiffTag.BITSPERSAMPLE, 64);
                tiff.SetField(TiffTag.SAMPLEFORMAT, SampleFormat.IEEEFP);
                tiff.SetField(TiffTag.PHOTOMETRIC, Photometric.MINISBLACK);
                tiff.SetField(TiffTag.ROWSPERSTRIP, 1);
                tiff.SetField(TiffTag.PLANARCONFIG, PlanarConfig.CONTIG);

                // Use LZW compression by default
                tiff.SetField(TiffTag.COMPRESSION, Compression.LZW);

                // Set geotiff tags (planet-agnostic: only writes CRS if known)
                SetGeoTiffTags(tiff, frame, coordinateSystem);

                // Write data row by row
                var rawData = frame.GetRawData();
                var stride = frame.Width * sizeof(double);

                for (int row = 0; row < frame.Height; row++)
                {
                    cancellationToken.ThrowIfCancellationRequested();

                    var rowData = rawData.Slice(row * stride, stride).ToArray();

                    if (!tiff.WriteScanline(rowData, row))
                        return false;
                }

                return true;
            }
            catch
            {
                return false;
            }
        }, cancellationToken).ConfigureAwait(false);
    }

    /// <summary>
    /// Sets GeoTiff georeferencing tags.
    /// Planet-agnostic: writes CRS only if explicitly provided in metadata.
    /// Always writes geotransform (pixel scale + tie points) for coordinate mapping.
    /// </summary>
    private static void SetGeoTiffTags(Tiff tiff, IRasterFrame frame, string? coordinateSystem)
    {
        var bounds = frame.Bounds;

        // Calculate pixel dimensions
        var pixelWidth = bounds.Width / frame.Width;
        var pixelHeight = bounds.Height / frame.Height;

        // Always set GeoPixelScale (X, Y, Z scales) - needed for pixel-to-coordinate mapping
        tiff.SetField(TIFFTAG_GEOPIXELSCALE, 3, new double[] { pixelWidth, pixelHeight, 0.0 });

        // Always set GeoTiePoints (raster point -> model point mapping)
        // Format: I, J, K, X, Y, Z (raster col, row, 0, lon, lat, 0)
        tiff.SetField(TIFFTAG_GEOTIEPOINTS, 6, new double[]
        {
            0.0, 0.0, 0.0,                              // Raster point (0,0)
            bounds.MinLongitude, bounds.MaxLatitude, 0.0  // Model point (top-left corner)
        });

        // Only set GeoKeyDirectory if we have a known EPSG code
        // Planet-agnostic: do NOT assume Earth/WGS84 if CRS is unknown
        var epsgCode = TryParseEpsgCode(coordinateSystem);
        if (epsgCode.HasValue)
        {
            // Format: KeyDirectoryVersion, KeyRevision, MinorRevision, NumberOfKeys,
            //         then for each key: KeyID, TIFFTagLocation, Count, Value
            tiff.SetField(TIFFTAG_GEOKEYDIRECTORY, 16, new short[]
            {
                1, 1, 0, 3,                          // Version 1.1.0, 3 keys
                1024, 0, 1, 2,                       // GTModelTypeGeoKey = Geographic
                1025, 0, 1, 1,                       // GTRasterTypeGeoKey = RasterPixelIsArea
                2048, 0, 1, (short)epsgCode.Value    // GeographicTypeGeoKey = provided EPSG
            });
        }
        // If no EPSG code: omit GeoKeyDirectory entirely (CRS-agnostic output)
        // The geotransform (PixelScale + TiePoints) still enables coordinate mapping
    }

    /// <summary>
    /// Tries to parse an EPSG code from a coordinate system string.
    /// Supports formats: "EPSG:4326", "epsg:4326", "4326"
    /// </summary>
    private static int? TryParseEpsgCode(string? coordinateSystem)
    {
        if (string.IsNullOrWhiteSpace(coordinateSystem))
            return null;

        var trimmed = coordinateSystem.Trim();

        // Try "EPSG:XXXX" format (case-insensitive)
        if (trimmed.StartsWith("EPSG:", StringComparison.OrdinalIgnoreCase))
        {
            var codeStr = trimmed.Substring(5);
            if (int.TryParse(codeStr, out var code) && code > 0 && code <= 32767)
                return code;
        }

        // Try raw integer format
        if (int.TryParse(trimmed, out var rawCode) && rawCode > 0 && rawCode <= 32767)
            return rawCode;

        return null;
    }
}


// --- PATH: plugins/Raster.GeoTiff/GeoTiffRasterFrame.cs ---
using Plate.TimeDete.Time.Primitives;
using FantaSim.Raster.Contracts;

namespace FantaSim.Raster.GeoTiff;

/// <summary>
/// Implementation of IRasterFrame for GeoTiff data.
/// Supports lazy loading of cell data.
/// </summary>
public sealed class GeoTiffRasterFrame : IRasterFrame, IDisposable
{
    private readonly Lazy<double[]> _data;
    private readonly double? _noDataValue;
    private bool _disposed;

    /// <summary>
    /// Creates a new GeoTiffRasterFrame with pre-loaded data.
    /// </summary>
    public GeoTiffRasterFrame(
        CanonicalTick tick,
        int width,
        int height,
        RasterBounds bounds,
        RasterDataType dataType,
        double[] data,
        double? noDataValue = null)
    {
        Tick = tick;
        Width = width;
        Height = height;
        Bounds = bounds;
        DataType = dataType;
        _noDataValue = noDataValue;
        _data = new Lazy<double[]>(() => data);
    }

    /// <summary>
    /// Creates a new GeoTiffRasterFrame with lazy data loading.
    /// </summary>
    public GeoTiffRasterFrame(
        CanonicalTick tick,
        int width,
        int height,
        RasterBounds bounds,
        RasterDataType dataType,
        Func<double[]> dataLoader,
        double? noDataValue = null)
    {
        Tick = tick;
        Width = width;
        Height = height;
        Bounds = bounds;
        DataType = dataType;
        _noDataValue = noDataValue;
        _data = new Lazy<double[]>(dataLoader);
    }

    /// <inheritdoc />
    public CanonicalTick Tick { get; }

    /// <inheritdoc />
    public int Width { get; }

    /// <inheritdoc />
    public int Height { get; }

    /// <inheritdoc />
    public RasterBounds Bounds { get; }

    /// <inheritdoc />
    public RasterDataType DataType { get; }

    /// <inheritdoc />
    public double? NoDataValue => _noDataValue;

    /// <inheritdoc />
    public ReadOnlySpan<byte> GetRawData()
    {
        ObjectDisposedException.ThrowIf(_disposed, this);

        // Convert double[] to byte[]
        var data = _data.Value;
        var bytes = new byte[data.Length * sizeof(double)];
        Buffer.BlockCopy(data, 0, bytes, 0, bytes.Length);
        return bytes;
    }

    /// <inheritdoc />
    public double? GetValue(int row, int col)
    {
        ObjectDisposedException.ThrowIf(_disposed, this);

        if (row < 0 || row >= Height)
            throw new ArgumentOutOfRangeException(nameof(row));
        if (col < 0 || col >= Width)
            throw new ArgumentOutOfRangeException(nameof(col));

        var index = row * Width + col;
        var value = _data.Value[index];

        // Check for no-data value using proper comparison
        if (IsNoDataValue(value))
        {
            return null;
        }

        return value;
    }

    /// <inheritdoc />
    public double? GetValueAt(double longitude, double latitude)
    {
        ObjectDisposedException.ThrowIf(_disposed, this);

        // Check bounds
        if (!Bounds.Contains(longitude, latitude))
            return null;

        // Calculate cell indices
        var cellWidth = Bounds.Width / Width;
        var cellHeight = Bounds.Height / Height;

        var col = (int)((longitude - Bounds.MinLongitude) / cellWidth);
        var row = (int)((Bounds.MaxLatitude - latitude) / cellHeight);

        // Clamp to valid range
        col = Math.Clamp(col, 0, Width - 1);
        row = Math.Clamp(row, 0, Height - 1);

        return GetValue(row, col);
    }

    /// <summary>
    /// Checks if the given value matches the no-data value.
    /// Uses tolerance-based comparison for floating point values.
    /// </summary>
    private bool IsNoDataValue(double value)
    {
        if (!_noDataValue.HasValue)
            return double.IsNaN(value);

        // For floating point no-data, use tolerance comparison
        var noData = _noDataValue.Value;

        // Handle special cases
        if (double.IsNaN(noData))
            return double.IsNaN(value);
        if (double.IsInfinity(noData))
            return double.IsInfinity(value) && Math.Sign(noData) == Math.Sign(value);

        // Tolerance-based comparison for normal values
        const double tolerance = 1e-10;
        return Math.Abs(value - noData) < tolerance;
    }

    /// <summary>
    /// Gets a copy of all values as a flat array.
    /// </summary>
    public double[] GetAllValues()
    {
        ObjectDisposedException.ThrowIf(_disposed, this);
        return _data.Value.ToArray();
    }

    /// <summary>
    /// Gets a region of the raster as a 2D array.
    /// </summary>
    public double[,] GetRegion(int rowStart, int rowEnd, int colStart, int colEnd)
    {
        ObjectDisposedException.ThrowIf(_disposed, this);

        if (rowStart < 0 || rowEnd > Height || rowStart >= rowEnd)
            throw new ArgumentOutOfRangeException(nameof(rowStart));
        if (colStart < 0 || colEnd > Width || colStart >= colEnd)
            throw new ArgumentOutOfRangeException(nameof(colStart));

        var rowCount = rowEnd - rowStart;
        var colCount = colEnd - colStart;
        var result = new double[rowCount, colCount];

        var data = _data.Value;

        for (int r = 0; r < rowCount; r++)
        {
            for (int c = 0; c < colCount; c++)
            {
                var srcIndex = (rowStart + r) * Width + (colStart + c);
                result[r, c] = data[srcIndex];
            }
        }

        return result;
    }

    /// <summary>
    /// Gets the underlying data array (for internal use).
    /// </summary>
    internal double[] GetDataArray()
    {
        ObjectDisposedException.ThrowIf(_disposed, this);
        return _data.Value;
    }

    /// <summary>
    /// Gets a read-only span view of the data without copying (for internal use).
    /// </summary>
    internal ReadOnlySpan<double> GetDataSpan()
    {
        ObjectDisposedException.ThrowIf(_disposed, this);
        return _data.Value.AsSpan();
    }

    public void Dispose()
    {
        if (!_disposed)
        {
            _disposed = true;
        }
    }
}


// --- PATH: plugins/Raster.GeoTiff/GeoTiffRasterLoader.cs ---
﻿using System.Text.RegularExpressions;
using Plate.TimeDete.Time.Primitives;
using FantaSim.Geosphere.Plate.Datasets.Contracts.Loading;
using FantaSim.Geosphere.Plate.Datasets.Contracts.Manifest;
using FantaSim.Raster.Contracts;
using FantaSim.Raster.Contracts.Loading;
using FantaSim.Raster.GeoTiff.Internal;

namespace FantaSim.Raster.GeoTiff;

/// <summary>
/// Loads raster sequences from GeoTiff files.
/// Supports single files, multi-band files, and file pattern sequences.
/// RFC-V2-0028 compliant.
/// </summary>
public sealed class GeoTiffRasterLoader : IRasterSequenceLoader
{
    private const string FormatName = "geotiff";

    /// <summary>
    /// File extensions supported by this loader.
    /// </summary>
    public static readonly IReadOnlyList<string> SupportedExtensions = new[] { ".tif", ".tiff", ".geotiff" };

    /// <inheritdoc />
    public IReadOnlyCollection<string> SupportedFormats => new[] { FormatName, "tiff", "tif" };

    /// <inheritdoc />
    public bool CanLoad(string format)
    {
        return SupportedFormats.Contains(format.ToLowerInvariant());
    }

    /// <inheritdoc />
    public async Task<IRasterSequence> LoadAsync(
        RasterSequenceAsset asset,
        IPlatesDataset dataset,
        CancellationToken cancellationToken = default)
    {
        var fullPath = Path.Combine(dataset.DatasetRootPath, asset.RelativePath);

        // Determine loading strategy based on path
        if (File.Exists(fullPath))
        {
            return await LoadSingleFileAsync(asset, fullPath, cancellationToken);
        }

        // Check if it's a pattern (contains wildcards)
        if (fullPath.Contains('*') || fullPath.Contains('?'))
        {
            return await LoadPatternAsync(asset, fullPath, cancellationToken);
        }

        // Check if it's a directory
        if (Directory.Exists(fullPath))
        {
            return await LoadDirectoryAsync(asset, fullPath, cancellationToken);
        }

        throw new FileNotFoundException($"GeoTiff source not found: {fullPath}");
    }

    /// <summary>
    /// Loads a single GeoTiff file as a sequence.
    /// Multi-band files are treated as multiple frames.
    /// </summary>
    private async Task<IRasterSequence> LoadSingleFileAsync(
        RasterSequenceAsset asset,
        string filePath,
        CancellationToken ct)
    {
        return await Task.Run(() =>
        {
            using var reader = TiffReader.Open(filePath);

            var geoTransform = reader.GeoTransform ?? DefaultGeoTransform();
            var bounds = CalculateBounds(reader.Width, reader.Height, geoTransform);
            var dataType = reader.GetRasterDataType();
            var noDataValue = reader.NoDataValue;

            var frames = new List<(CanonicalTick, GeoTiffRasterFrame)>();
            var bandCount = reader.SamplesPerPixel;
            var baseTick = CanonicalTick.Genesis;

            if (bandCount == 1)
            {
                // Single band - single frame
                var data = reader.ReadBandAsDouble(0);
                var frame = new GeoTiffRasterFrame(
                    baseTick,
                    reader.Width,
                    reader.Height,
                    bounds,
                    dataType,
                    data,
                    noDataValue);

                frames.Add((baseTick, frame));
            }
            else
            {
                // Multi-band - each band is a frame
                for (int bandIndex = 0; bandIndex < bandCount; bandIndex++)
                {
                    ct.ThrowIfCancellationRequested();

                    var tick = new CanonicalTick(baseTick.Value + bandIndex);

                    var data = reader.ReadBandAsDouble(bandIndex);
                    var frame = new GeoTiffRasterFrame(
                        tick,
                        reader.Width,
                        reader.Height,
                        bounds,
                        dataType,
                        data,
                        noDataValue);

                    frames.Add((tick, frame));
                }
            }

            return new GeoTiffRasterSequence(
                asset.AssetId,
                Path.GetFileNameWithoutExtension(filePath),
                frames);
        }, ct);
    }

    /// <summary>
    /// Loads multiple files matching a pattern as a sequence.
    /// </summary>
    private async Task<IRasterSequence> LoadPatternAsync(
        RasterSequenceAsset asset,
        string pattern,
        CancellationToken ct)
    {
        var dir = Path.GetDirectoryName(pattern) ?? ".";
        var filePattern = Path.GetFileName(pattern);

        if (!Directory.Exists(dir))
            throw new DirectoryNotFoundException($"Directory not found: {dir}");

        var files = Directory.GetFiles(dir, filePattern)
            .Where(f => SupportedExtensions.Any(e =>
                f.EndsWith(e, StringComparison.OrdinalIgnoreCase)))
            .OrderBy(f => f)
            .ToList();

        if (files.Count == 0)
            throw new FileNotFoundException($"No GeoTiff files match pattern: {pattern}");

        return await LoadFilesAsync(asset, files, ct);
    }

    /// <summary>
    /// Loads all GeoTiff files in a directory as a sequence.
    /// </summary>
    private async Task<IRasterSequence> LoadDirectoryAsync(
        RasterSequenceAsset asset,
        string directoryPath,
        CancellationToken ct)
    {
        var files = Directory.GetFiles(directoryPath)
            .Where(f => SupportedExtensions.Any(e =>
                f.EndsWith(e, StringComparison.OrdinalIgnoreCase)))
            .OrderBy(f => f)
            .ToList();

        if (files.Count == 0)
            throw new FileNotFoundException($"No GeoTiff files in directory: {directoryPath}");

        return await LoadFilesAsync(asset, files, ct);
    }

    /// <summary>
    /// Loads a list of files as a sequence, extracting tick information from filenames if possible.
    /// </summary>
    private async Task<IRasterSequence> LoadFilesAsync(
        RasterSequenceAsset asset,
        List<string> files,
        CancellationToken ct)
    {
        return await Task.Run(() =>
        {
            var frames = new List<(CanonicalTick, GeoTiffRasterFrame)>();
            var baseTick = CanonicalTick.Genesis;

            foreach (var (file, index) in files.Select((f, i) => (f, i)))
            {
                ct.ThrowIfCancellationRequested();

                using var reader = TiffReader.Open(file);

                var geoTransform = reader.GeoTransform ?? DefaultGeoTransform();
                var bounds = CalculateBounds(reader.Width, reader.Height, geoTransform);
                var dataType = reader.GetRasterDataType();
                var noDataValue = reader.NoDataValue;

                // Determine tick for this file
                var tick = ExtractTickFromFilename(file, baseTick, index);

                var data = reader.ReadBandAsDouble(0);
                var frame = new GeoTiffRasterFrame(
                    tick,
                    reader.Width,
                    reader.Height,
                    bounds,
                    dataType,
                    data,
                    noDataValue);

                frames.Add((tick, frame));
            }

            return new GeoTiffRasterSequence(
                asset.AssetId,
                asset.AssetId,
                frames);
        }, ct);
    }

    /// <summary>
    /// Attempts to extract a tick value from a filename.
    /// Supports patterns like "elevation_100.tif", "data_001.tif", etc.
    /// </summary>
    private static CanonicalTick ExtractTickFromFilename(
        string filePath,
        CanonicalTick baseTick,
        int index)
    {
        var filename = Path.GetFileNameWithoutExtension(filePath);

        // Try to find numeric suffix/pattern
        // Pattern: any sequence of digits at the end or preceded by underscore/hyphen
        var match = Regex.Match(filename, @"[_\-]?(?<num>\d+)$", RegexOptions.ExplicitCapture, TimeSpan.FromSeconds(1));

        if (match.Success)
        {
            var numberStr = match.Groups["num"].Value;
            if (long.TryParse(numberStr, System.Globalization.NumberStyles.Integer, System.Globalization.CultureInfo.InvariantCulture, out var tickValue))
            {
                return new CanonicalTick(tickValue);
            }
        }

        // Try to find tick pattern with prefix like "tick123" or "t_456"
        match = Regex.Match(filename, @"[Tt]ick[_\-]?(?<num>\d+)", RegexOptions.ExplicitCapture, TimeSpan.FromSeconds(1));
        if (match.Success)
        {
            var numberStr = match.Groups["num"].Value;
            if (long.TryParse(numberStr, System.Globalization.NumberStyles.Integer, System.Globalization.CultureInfo.InvariantCulture, out var tickValue))
            {
                return new CanonicalTick(tickValue);
            }
        }

        // Default: calculate tick based on index
        return new CanonicalTick(baseTick.Value + index);
    }

    /// <summary>
    /// Returns a default geo transform for files without geo-referencing.
    /// </summary>
    private static double[] DefaultGeoTransform()
    {
        return new[] { 0.0, 1.0, 0.0, 0.0, 0.0, -1.0 };
    }

    /// <summary>
    /// Calculates geographic bounds from geo transformation.
    /// </summary>
    public static RasterBounds CalculateBounds(
        int width,
        int height,
        double[] geoTransform)
    {
        // geoTransform: [originX, pixelWidth, rotationX, originY, rotationY, pixelHeight]
        var originX = geoTransform[0];
        var pixelWidth = geoTransform[1];
        var rotationX = geoTransform[2];
        var originY = geoTransform[3];
        var rotationY = geoTransform[4];
        var pixelHeight = geoTransform[5];

        // For unrotated rasters (rotationX == 0, rotationY == 0)
        if (Math.Abs(rotationX) < 1e-10 && Math.Abs(rotationY) < 1e-10)
        {
            var minLon = originX;
            var maxLon = originX + width * pixelWidth;
            var maxLat = originY;
            var minLat = originY + height * pixelHeight; // pixelHeight is typically negative

            // Ensure proper ordering
            if (minLon > maxLon)
                (minLon, maxLon) = (maxLon, minLon);
            if (minLat > maxLat)
                (minLat, maxLat) = (maxLat, minLat);

            return new RasterBounds(minLon, maxLon, minLat, maxLat);
        }

        // For rotated rasters, calculate the bounding box of all corners
        var corners = new (double x, double y)[4];
        corners[0] = TransformPixelToGeo(0, 0, geoTransform);
        corners[1] = TransformPixelToGeo(width, 0, geoTransform);
        corners[2] = TransformPixelToGeo(width, height, geoTransform);
        corners[3] = TransformPixelToGeo(0, height, geoTransform);

        var cornerMinLon = corners.Min(c => c.x);
        var cornerMaxLon = corners.Max(c => c.x);
        var cornerMinLat = corners.Min(c => c.y);
        var cornerMaxLat = corners.Max(c => c.y);

        return new RasterBounds(cornerMinLon, cornerMaxLon, cornerMinLat, cornerMaxLat);
    }

    /// <summary>
    /// Transforms pixel coordinates to geographic coordinates.
    /// </summary>
    private static (double x, double y) TransformPixelToGeo(
        double pixelX,
        double pixelY,
        double[] geoTransform)
    {
        var originX = geoTransform[0];
        var pixelWidth = geoTransform[1];
        var rotationX = geoTransform[2];
        var originY = geoTransform[3];
        var rotationY = geoTransform[4];
        var pixelHeight = geoTransform[5];

        var geoX = originX + pixelX * pixelWidth + pixelY * rotationX;
        var geoY = originY + pixelX * rotationY + pixelY * pixelHeight;

        return (geoX, geoY);
    }
}


// --- PATH: plugins/Raster.GeoTiff/GeoTiffRasterSequence.cs ---
using System.Collections.Immutable;
using System.Diagnostics;
using Plate.TimeDete.Time.Primitives;
using FantaSim.Raster.Contracts;

namespace FantaSim.Raster.GeoTiff;

/// <summary>
/// Implementation of IRasterSequence for GeoTiff data.
/// Supports time-indexed frames from multiple files or multi-band files.
/// RFC-V2-0028 compliant.
/// </summary>
public sealed class GeoTiffRasterSequence : IRasterSequence, IDisposable
{
    private readonly SortedDictionary<CanonicalTick, GeoTiffRasterFrame> _frames;
    private readonly object _lock = new();
    private ImmutableArray<CanonicalTick> _availableTicks;

    /// <summary>
    /// Creates a new GeoTiffRasterSequence.
    /// </summary>
    public GeoTiffRasterSequence(
        string sequenceId,
        string displayName,
        IEnumerable<(CanonicalTick tick, GeoTiffRasterFrame frame)> frames,
        RasterMetadata? metadata = null)
    {
        SequenceId = sequenceId;
        DisplayName = displayName;
        _frames = new SortedDictionary<CanonicalTick, GeoTiffRasterFrame>();

        foreach (var (tick, frame) in frames)
        {
            _frames[tick] = frame;
        }

        _availableTicks = _frames.Keys.ToImmutableArray();

        // Derive metadata from first frame if not provided
        if (metadata.HasValue)
        {
            Metadata = metadata.Value;
        }
        else if (_frames.Count > 0)
        {
            var firstFrame = _frames.Values.First();
            Metadata = new RasterMetadata(
                firstFrame.Width,
                firstFrame.Height,
                firstFrame.Bounds,
                firstFrame.DataType,
                firstFrame.NoDataValue,
                null, // CoordinateSystem
                null  // Units
            );
        }
        else
        {
            Metadata = default;
        }
    }

    /// <inheritdoc />
    public string SequenceId { get; }

    /// <inheritdoc />
    public string DisplayName { get; }

    /// <inheritdoc />
    public ImmutableArray<CanonicalTick> AvailableTicks => _availableTicks;

    /// <inheritdoc />
    public RasterMetadata Metadata { get; }

    /// <inheritdoc />
    public IRasterFrame? GetFrameAt(CanonicalTick tick)
    {
        lock (_lock)
        {
            return _frames.TryGetValue(tick, out var frame) ? frame : null;
        }
    }

    /// <inheritdoc />
    public RasterQueryResult QueryAt(CanonicalTick tick, RasterQueryOptions? options = null)
    {
        var opts = options ?? RasterQueryOptions.Default;

        lock (_lock)
        {
            if (_frames.Count == 0)
                return RasterQueryResult.NotFound(tick);

            // Check for exact match first
            if (_frames.TryGetValue(tick, out var exactFrame))
            {
                return RasterQueryResult.Exact(tick, CreateFrameData(exactFrame));
            }

            // Find surrounding frames
            var (beforeTick, beforeFrame) = GetFrameAtOrBefore(tick);
            var (afterTick, afterFrame) = GetFrameAtOrAfter(tick);

            if (beforeFrame == null && afterFrame == null)
                return RasterQueryResult.NotFound(tick);

            // If only one side exists, use it
            if (beforeFrame == null)
            {
                return RasterQueryResult.Exact(tick, CreateFrameData(afterFrame!));
            }
            if (afterFrame == null)
            {
                return RasterQueryResult.Exact(tick, CreateFrameData(beforeFrame));
            }

            // Handle interpolation
            if (opts.Interpolation == InterpolationMethod.NearestNeighbor)
            {
                // Choose the nearest frame
                var beforeDist = tick.Value - beforeTick.Value;
                var afterDist = afterTick.Value - tick.Value;

                if (beforeDist <= afterDist)
                {
                    return RasterQueryResult.Exact(tick, CreateFrameData(beforeFrame));
                }
                else
                {
                    return RasterQueryResult.Exact(tick, CreateFrameData(afterFrame));
                }
            }
            else if (opts.Interpolation == InterpolationMethod.Linear)
            {
                // Linear interpolation between frames
                var totalTicks = afterTick.Value - beforeTick.Value;
                var targetTicks = tick.Value - beforeTick.Value;
                var weight = totalTicks > 0 ? (double)targetTicks / totalTicks : 0;

                var interpolatedData = InterpolateFrames(beforeFrame, afterFrame, weight);
                var frameData = new RasterFrameData(
                    beforeFrame.Width,
                    beforeFrame.Height,
                    beforeFrame.Bounds,
                    beforeFrame.DataType,
                    beforeFrame.NoDataValue,
                    interpolatedData);

                return RasterQueryResult.Interpolated(tick, beforeTick, weight, frameData);
            }

            // Default to before frame
            return RasterQueryResult.Exact(tick, CreateFrameData(beforeFrame));
        }
    }

    /// <inheritdoc />
    public IEnumerable<IRasterFrame> GetFramesInRange(CanonicalTick startTick, CanonicalTick endTick)
    {
        lock (_lock)
        {
            return _frames
                .Where(kvp => kvp.Key >= startTick && kvp.Key <= endTick)
                .Select(kvp => kvp.Value)
                .ToList();
        }
    }

    /// <summary>
    /// Gets the frame at or before the given tick.
    /// </summary>
    private (CanonicalTick tick, GeoTiffRasterFrame? frame) GetFrameAtOrBefore(CanonicalTick tick)
    {
        var result = _frames
            .LastOrDefault(kvp => kvp.Key <= tick);

        return (result.Key, result.Value);
    }

    /// <summary>
    /// Gets the frame at or after the given tick.
    /// </summary>
    private (CanonicalTick tick, GeoTiffRasterFrame? frame) GetFrameAtOrAfter(CanonicalTick tick)
    {
        var result = _frames
            .FirstOrDefault(kvp => kvp.Key >= tick);

        return (result.Key, result.Value);
    }

    /// <summary>
    /// Linearly interpolates between two frames.
    /// </summary>
    private byte[] InterpolateFrames(GeoTiffRasterFrame before, GeoTiffRasterFrame after, double weight)
    {
        Debug.Assert(before.Width == after.Width && before.Height == after.Height);

        var beforeData = before.GetDataArray();
        var afterData = after.GetDataArray();

        Debug.Assert(beforeData.Length == afterData.Length);

        var interpolatedData = new double[beforeData.Length];
        var noDataValue = before.NoDataValue ?? double.NaN;

        for (int i = 0; i < beforeData.Length; i++)
        {
            var beforeVal = beforeData[i];
            var afterVal = afterData[i];

            // Handle no-data values
            var beforeIsNoData = IsNoData(beforeVal, noDataValue);
            var afterIsNoData = IsNoData(afterVal, noDataValue);

            if (beforeIsNoData && afterIsNoData)
            {
                interpolatedData[i] = noDataValue;
            }
            else if (beforeIsNoData)
            {
                interpolatedData[i] = afterVal;
            }
            else if (afterIsNoData)
            {
                interpolatedData[i] = beforeVal;
            }
            else
            {
                interpolatedData[i] = beforeVal + (afterVal - beforeVal) * weight;
            }
        }

        // Convert to bytes
        var bytes = new byte[interpolatedData.Length * sizeof(double)];
        Buffer.BlockCopy(interpolatedData, 0, bytes, 0, bytes.Length);
        return bytes;
    }

    private static bool IsNoData(double value, double noDataValue)
    {
        if (double.IsNaN(noDataValue))
            return double.IsNaN(value);
        return Math.Abs(value - noDataValue) < 1e-10;
    }

    private static RasterFrameData CreateFrameData(GeoTiffRasterFrame frame)
    {
        return new RasterFrameData(
            frame.Width,
            frame.Height,
            frame.Bounds,
            frame.DataType,
            frame.NoDataValue,
            frame.GetRawData().ToArray());
    }

    /// <summary>
    /// Gets the internal frame for a specific tick (for internal use).
    /// </summary>
    internal GeoTiffRasterFrame? GetInternalFrame(CanonicalTick tick)
    {
        lock (_lock)
        {
            return _frames.TryGetValue(tick, out var frame) ? frame : null;
        }
    }

    public void Dispose()
    {
        lock (_lock)
        {
            foreach (var frame in _frames.Values)
            {
                frame.Dispose();
            }
            _frames.Clear();
        }
    }
}


// --- PATH: plugins/Raster.GeoTiff/Internal/TiffReader.cs ---
using System.Runtime.InteropServices;
using BitMiracle.LibTiff.Classic;
using FantaSim.Raster.Contracts;

namespace FantaSim.Raster.GeoTiff.Internal;

/// <summary>
/// Low-level wrapper for reading GeoTiff files using LibTiff.NET.
/// </summary>
internal sealed class TiffReader : IDisposable
{
    private Tiff? _tiff;
    private bool _disposed;

    // GeoTiff tag constants
    private const TiffTag TIFFTAG_GEOPIXELSCALE = (TiffTag)33550;
    private const TiffTag TIFFTAG_GEOTIEPOINTS = (TiffTag)33922;
    private const TiffTag TIFFTAG_GEOTRANSMATRIX = (TiffTag)34264;
    private const TiffTag TIFFTAG_GEOKEYDIRECTORY = (TiffTag)34735;
    private const TiffTag TIFFTAG_GEODOUBLEPARAMS = (TiffTag)34736;
    private const TiffTag TIFFTAG_GEOASCIIPARAMS = (TiffTag)34737;

    /// <summary>
    /// Opens a Tiff file for reading.
    /// </summary>
    public static TiffReader Open(string path)
    {
        var tiff = Tiff.Open(path, "r");
        if (tiff == null)
        {
            throw new InvalidOperationException($"Failed to open Tiff file: {path}");
        }

        return new TiffReader { _tiff = tiff };
    }

    /// <summary>
    /// Gets the width of the image in pixels.
    /// </summary>
    public int Width => _tiff?.GetField(TiffTag.IMAGEWIDTH)?[0].ToInt() ?? 0;

    /// <summary>
    /// Gets the height of the image in pixels.
    /// </summary>
    public int Height => _tiff?.GetField(TiffTag.IMAGELENGTH)?[0].ToInt() ?? 0;

    /// <summary>
    /// Gets the number of bands/samples per pixel.
    /// </summary>
    public int SamplesPerPixel => _tiff?.GetField(TiffTag.SAMPLESPERPIXEL)?[0].ToInt() ?? 1;

    /// <summary>
    /// Gets the bits per sample.
    /// </summary>
    public int BitsPerSample
    {
        get
        {
            var field = _tiff?.GetField(TiffTag.BITSPERSAMPLE);
            if (field != null && field.Length > 0)
            {
                return field[0].ToInt();
            }
            return 8;
        }
    }

    /// <summary>
    /// Gets the sample format (unsigned int, signed int, float, etc.).
    /// </summary>
    public SampleFormat SampleFormat
    {
        get
        {
            var field = _tiff?.GetField(TiffTag.SAMPLEFORMAT);
            if (field != null && field.Length > 0)
            {
                return (SampleFormat)field[0].ToInt();
            }
            return SampleFormat.UINT;
        }
    }

    /// <summary>
    /// Gets the planar configuration (chunky or separate).
    /// </summary>
    public PlanarConfig PlanarConfig
    {
        get
        {
            var field = _tiff?.GetField(TiffTag.PLANARCONFIG);
            if (field != null && field.Length > 0)
            {
                return (PlanarConfig)field[0].ToInt();
            }
            return PlanarConfig.CONTIG;
        }
    }

    /// <summary>
    /// Gets the no-data value if specified.
    /// </summary>
    public double? NoDataValue
    {
        get
        {
            var field = _tiff?.GetField(TiffTag.GDAL_NODATA);
            if (field != null && field.Length > 1)
            {
                var value = field[1].ToString();
                if (!string.IsNullOrEmpty(value) && double.TryParse(value, System.Globalization.NumberStyles.Float, System.Globalization.CultureInfo.InvariantCulture, out var result))
                {
                    return result;
                }
            }
            return null;
        }
    }

    /// <summary>
    /// Gets the geo transformation (pixel to world coordinates).
    /// Returns [originX, pixelWidth, rotationX, originY, rotationY, pixelHeight].
    /// </summary>
    public double[]? GeoTransform
    {
        get
        {
            // Try to get from GeoTransform matrix tag first
            var matrixField = _tiff?.GetField(TIFFTAG_GEOTRANSMATRIX);
            if (matrixField != null && matrixField.Length > 1)
            {
                var count = matrixField[0].ToInt();
                if (count >= 16)
                {
                    // Full 4x4 transformation matrix - extract the 6-element geotransform
                    var bytes = matrixField[1].GetBytes();
                    var matrix = new double[count];
                    Buffer.BlockCopy(bytes, 0, matrix, 0, count * sizeof(double));
                    return new[]
                    {
                        matrix[3],  // originX
                        matrix[0],  // pixelWidth
                        matrix[1],  // rotationX
                        matrix[7],  // originY
                        matrix[4],  // rotationY
                        matrix[5]   // pixelHeight
                    };
                }
            }

            // Try to build from pixel scale and tie points
            var scaleField = _tiff?.GetField(TIFFTAG_GEOPIXELSCALE);
            var tiePointField = _tiff?.GetField(TIFFTAG_GEOTIEPOINTS);

            if (scaleField != null && tiePointField != null && scaleField.Length > 1 && tiePointField.Length > 1)
            {
                var scaleBytes = scaleField[1].GetBytes();
                var scales = new double[3];
                Buffer.BlockCopy(scaleBytes, 0, scales, 0, Math.Min(scaleBytes.Length, 3 * sizeof(double)));

                var tiePointBytes = tiePointField[1].GetBytes();
                var tiePoints = new double[6];
                Buffer.BlockCopy(tiePointBytes, 0, tiePoints, 0, Math.Min(tiePointBytes.Length, 6 * sizeof(double)));

                // tiePoints: [pixelX, pixelY, pixelZ, geoX, geoY, geoZ]
                return new[]
                {
                    tiePoints[3],  // originX
                    scales[0],     // pixelWidth
                    0.0,           // rotationX (no rotation)
                    tiePoints[4],  // originY
                    0.0,           // rotationY (no rotation)
                    -scales[1]     // pixelHeight (negative for top-down)
                };
            }

            return null;
        }
    }

    /// <summary>
    /// Gets the coordinate reference system (CRS) information.
    /// </summary>
    public string? CoordinateReferenceSystem
    {
        get
        {
            // Try to get from GeoAsciiParams
            var asciiParamsField = _tiff?.GetField(TIFFTAG_GEOASCIIPARAMS);
            if (asciiParamsField != null && asciiParamsField.Length > 1)
            {
                var asciiParams = asciiParamsField[1].ToString();
                if (!string.IsNullOrEmpty(asciiParams))
                {
                    // Parse CRS from ASCII params (often contains EPSG code)
                    var epsgMatch = System.Text.RegularExpressions.Regex.Match(
                        asciiParams,
                        @"EPSG\[""?(?<code>\d+)""?\]",
                        System.Text.RegularExpressions.RegexOptions.ExplicitCapture,
                        TimeSpan.FromSeconds(1));
                    if (epsgMatch.Success)
                    {
                        return $"EPSG:{epsgMatch.Groups["code"].Value}";
                    }
                }
            }

            // Try to parse from GeoKeyDirectory
            var keyDirField = _tiff?.GetField(TIFFTAG_GEOKEYDIRECTORY);
            if (keyDirField != null && keyDirField.Length > 1)
            {
                var keyBytes = keyDirField[1].GetBytes();
                var keyCount = keyDirField[0].ToInt();
                var keys = new short[keyCount];
                Buffer.BlockCopy(keyBytes, 0, keys, 0, Math.Min(keyBytes.Length, keyCount * sizeof(short)));

                // Look for GeographicTypeGeoKey (2048) or ProjectedCSTypeGeoKey (3072)
                // Key format: KeyID (2 bytes), TIFFTagLocation (2 bytes), Count (2 bytes), Value/Offset (2 bytes)
                // Header is 4 shorts, then 4 shorts per key
                for (int i = 4; i < keys.Length; i += 4)
                {
                    var keyId = keys[i];
                    var value = keys[i + 3];

                    if (keyId == 2048 && value != 32767) // GeographicTypeGeoKey
                    {
                        return $"EPSG:{value}";
                    }
                    if (keyId == 3072 && value != 32767) // ProjectedCSTypeGeoKey
                    {
                        return $"EPSG:{value}";
                    }
                }
            }

            return null;
        }
    }

    /// <summary>
    /// Maps the Tiff sample format and bits per sample to RasterDataType.
    /// </summary>
    public RasterDataType GetRasterDataType()
    {
        var sampleFormat = SampleFormat;
        var bitsPerSample = BitsPerSample;

        return sampleFormat switch
        {
            SampleFormat.UINT => bitsPerSample switch
            {
                8 => RasterDataType.UInt8,
                16 => RasterDataType.UInt16,
                32 => RasterDataType.UInt32,
                _ => RasterDataType.UInt16
            },
            SampleFormat.INT => bitsPerSample switch
            {
                8 => RasterDataType.Int8,
                16 => RasterDataType.Int16,
                32 => RasterDataType.Int32,
                _ => RasterDataType.Int16
            },
            SampleFormat.IEEEFP => bitsPerSample switch
            {
                32 => RasterDataType.Float32,
                64 => RasterDataType.Float64,
                _ => RasterDataType.Float32
            },
            _ => RasterDataType.Float32
        };
    }

    /// <summary>
    /// Reads a single band into a typed array.
    /// </summary>
    public T[] ReadBand<T>(int bandIndex = 0) where T : unmanaged
    {
        if (_tiff == null)
            throw new ObjectDisposedException(nameof(TiffReader));

        var width = Width;
        var height = Height;
        var samplesPerPixel = SamplesPerPixel;

        if (bandIndex < 0 || bandIndex >= samplesPerPixel)
            throw new ArgumentOutOfRangeException(nameof(bandIndex));

        var result = new T[width * height];
        var scanlineSize = _tiff.ScanlineSize();
        var buffer = new byte[scanlineSize];

        var gcHandle = GCHandle.Alloc(result, GCHandleType.Pinned);
        try
        {
            var resultPtr = gcHandle.AddrOfPinnedObject();

            for (int row = 0; row < height; row++)
            {
                _tiff.ReadScanline(buffer, row);

                // Copy scanline to result array
                var rowOffset = row * width;
                var elementSize = Marshal.SizeOf<T>();

                for (int col = 0; col < width; col++)
                {
                    var pixelOffset = (col * samplesPerPixel + bandIndex) * elementSize;
                    var resultOffset = (rowOffset + col) * elementSize;

                    if (pixelOffset + elementSize <= buffer.Length)
                    {
                        Marshal.Copy(buffer, pixelOffset, resultPtr + resultOffset, elementSize);
                    }
                }
            }
        }
        finally
        {
            gcHandle.Free();
        }

        return result;
    }

    /// <summary>
    /// Reads a single band as double values.
    /// </summary>
    public double[] ReadBandAsDouble(int bandIndex = 0)
    {
        var dataType = GetRasterDataType();

        return dataType switch
        {
            RasterDataType.UInt8 => ReadBand<byte>(bandIndex).Select(b => (double)b).ToArray(),
            RasterDataType.Int8 => ReadBand<sbyte>(bandIndex).Select(b => (double)b).ToArray(),
            RasterDataType.UInt16 => ReadBand<ushort>(bandIndex).Select(b => (double)b).ToArray(),
            RasterDataType.Int16 => ReadBand<short>(bandIndex).Select(b => (double)b).ToArray(),
            RasterDataType.UInt32 => ReadBand<uint>(bandIndex).Select(b => (double)b).ToArray(),
            RasterDataType.Int32 => ReadBand<int>(bandIndex).Select(b => (double)b).ToArray(),
            RasterDataType.Float32 => ReadBand<float>(bandIndex).Select(b => (double)b).ToArray(),
            RasterDataType.Float64 => ReadBand<double>(bandIndex),
            _ => ReadBand<float>(bandIndex).Select(b => (double)b).ToArray()
        };
    }

    /// <summary>
    /// Gets all band indices available in this file.
    /// </summary>
    public IEnumerable<int> GetBandIndices()
    {
        var count = SamplesPerPixel;
        for (int i = 0; i < count; i++)
        {
            yield return i;
        }
    }

    public void Dispose()
    {
        if (!_disposed)
        {
            _tiff?.Dispose();
            _tiff = null;
            _disposed = true;
        }
    }
}


// --- PATH: plugins/Raster.Masking.Plate/IPlateRasterMaskFactory.cs ---
using System.Runtime.InteropServices;
using FantaSim.Geosphere.Plate.Polygonization.Contracts.Products;
using FantaSim.Raster.Contracts;
using FantaSim.Raster.Contracts.Masking;
using FantaSim.Geosphere.Plate.Topology.Contracts.Entities;
using MessagePack;

namespace FantaSim.Raster.Masking.Plate;

/// <summary>
/// Plate-specific factory for creating masked raster sequences.
/// RFC-V2-0028 §8.2.2 - Composition layer that bridges raster + plates domains.
/// </summary>
/// <remarks>
/// This interface lives in the Masking plugin (composition layer), not in
/// Raster.Contracts, to maintain domain-agnostic contracts.
/// </remarks>
public interface IPlateRasterMaskFactory : IRasterMaskFactory
{
    /// <summary>
    /// Creates a masked sequence using a plate polygon set.
    /// Pixels inside plate polygons are kept; others are masked out.
    /// </summary>
    /// <param name="source">The source raster sequence.</param>
    /// <param name="polygonSet">The plate polygon set for masking.</param>
    /// <param name="specificPlates">Optional: limit masking to specific plates. If null, all plates are included.</param>
    /// <returns>A masked raster sequence.</returns>
    IPlateMaskedRasterSequence CreatePlateMaskedSequence(
        IRasterSequence source,
        PlatePolygonSet polygonSet,
        IReadOnlyCollection<PlateId>? specificPlates = null);
}

/// <summary>
/// Extended masked raster sequence that includes plate polygon information.
/// RFC-V2-0028 §8.2.2 - Composition layer interface.
/// </summary>
/// <remarks>
/// This interface extends <see cref="IMaskedRasterSequence"/> with plate-specific
/// properties. It lives in the Masking plugin, not in Raster.Contracts.
/// </remarks>
public interface IPlateMaskedRasterSequence : IMaskedRasterSequence
{
    /// <summary>
    /// The plate polygon set used for masking.
    /// </summary>
    PlatePolygonSet PolygonSet { get; }

    /// <summary>
    /// The specific plates included in the mask (null = all plates).
    /// </summary>
    IReadOnlyCollection<PlateId>? SpecificPlates { get; }
}

/// <summary>
/// Mask specification for plate polygon-based masking.
/// RFC-V2-0028 - Plate-specific masking configuration.
/// </summary>
[StructLayout(LayoutKind.Auto)]
[MessagePackObject]
public readonly record struct PlatePolygonMaskSpec(
    [property: Key(0)] PlateId PlateId,
    [property: Key(1)] bool IncludeInterior,
    [property: Key(2)] double BufferDegrees
)
{
    /// <summary>
    /// Mask that includes only the interior of the polygon.
    /// </summary>
    public static PlatePolygonMaskSpec Interior(PlateId plateId, double bufferDegrees = 0)
        => new(plateId, true, bufferDegrees);

    /// <summary>
    /// Mask that excludes the interior (keeps exterior).
    /// </summary>
    public static PlatePolygonMaskSpec Exterior(PlateId plateId, double bufferDegrees = 0)
        => new(plateId, false, bufferDegrees);
}


// --- PATH: plugins/Raster.Masking.Plate/Internal/SimpleRasterFrame.cs ---
using FantaSim.Raster.Contracts;
using Plate.TimeDete.Time.Primitives;

namespace FantaSim.Raster.Masking.Plate;

/// <summary>
/// Simple raster frame wrapper for query results and temporary frame data.
/// </summary>
internal sealed class SimpleRasterFrame : IRasterFrame
{
    private readonly byte[] _data;
    private readonly CanonicalTick _tick;

    public SimpleRasterFrame(
        int width,
        int height,
        RasterBounds bounds,
        RasterDataType dataType,
        byte[] data,
        double? noDataValue,
        CanonicalTick? tick = null)
    {
        Width = width;
        Height = height;
        Bounds = bounds;
        DataType = dataType;
        _data = data;
        NoDataValue = noDataValue;
        _tick = tick ?? CanonicalTick.Genesis;
    }

    public CanonicalTick Tick => _tick;
    public int Width { get; }
    public int Height { get; }
    public RasterBounds Bounds { get; }
    public RasterDataType DataType { get; }
    public double? NoDataValue { get; }

    public ReadOnlySpan<byte> GetRawData() => _data;

    public double? GetValue(int row, int col)
    {
        if (row < 0 || row >= Height)
            throw new ArgumentOutOfRangeException(nameof(row));
        if (col < 0 || col >= Width)
            throw new ArgumentOutOfRangeException(nameof(col));

        var index = row * Width + sizeof(double);
        var bytes = new byte[sizeof(double)];
        Array.Copy(_data, index * sizeof(double), bytes, 0, sizeof(double));
        var value = BitConverter.ToDouble(bytes, 0);

        if (NoDataValue.HasValue)
        {
            var noData = NoDataValue.Value;
            if (double.IsNaN(noData) && double.IsNaN(value))
                return null;
            if (Math.Abs(value - noData) < 1e-10)
                return null;
        }
        else if (double.IsNaN(value))
        {
            return null;
        }

        return value;
    }

    public double? GetValueAt(double longitude, double latitude)
    {
        if (!Bounds.Contains(longitude, latitude))
            return null;

        var cellWidth = Bounds.Width / Width;
        var cellHeight = Bounds.Height / Height;

        var col = (int)((longitude - Bounds.MinLongitude) / cellWidth);
        var row = (int)((Bounds.MaxLatitude - latitude) / cellHeight);

        col = Math.Clamp(col, 0, Width - 1);
        row = Math.Clamp(row, 0, Height - 1);

        return GetValue(row, col);
    }
}


// --- PATH: plugins/Raster.Masking.Plate/MaskedRasterSequence.cs ---
using System.Collections.Immutable;
using Plate.TimeDete.Time.Primitives;
using FantaSim.Raster.Contracts;
using FantaSim.Raster.Contracts.Masking;
using FantaSim.Geosphere.Plate.Polygonization.Contracts.Products;
using FantaSim.Geosphere.Plate.Topology.Contracts.Entities;

// Use Core types
using CoreMaskedRasterSequence = FantaSim.Raster.Core.MaskedRasterSequence;

namespace FantaSim.Raster.Masking.Plate;

/// <summary>
/// Backward compatibility alias for <see cref="Core.MaskedRasterSequence"/>.
/// </summary>
/// <remarks>
/// This type has been moved to <c>Raster.Core</c>.
/// For new code, use <c>FantaSim.Raster.Core.MaskedRasterSequence</c>.
/// </remarks>
[Obsolete("Use FantaSim.Raster.Core.MaskedRasterSequence instead.")]
public class MaskedRasterSequence : CoreMaskedRasterSequence
{
    public MaskedRasterSequence(
        IRasterSequence sourceSequence,
        IRasterMask mask,
        double noDataValue)
        : base(sourceSequence, mask, noDataValue)
    {
    }
}

/// <summary>
/// A masked raster sequence that includes plate polygon information.
/// RFC-V2-0028 §8.2.2 - Composition layer implementation.
/// </summary>
/// <remarks>
/// This class extends <see cref="CoreMaskedRasterSequence"/> with plate-specific
/// properties, keeping the base class domain-agnostic.
/// </remarks>
public sealed class PlateMaskedRasterSequence : CoreMaskedRasterSequence, IPlateMaskedRasterSequence
{
    private readonly PlatePolygonSet _polygonSet;
    private readonly IReadOnlyCollection<PlateId>? _specificPlates;

    public PlateMaskedRasterSequence(
        IRasterSequence sourceSequence,
        IRasterMask mask,
        double noDataValue,
        PlatePolygonSet polygonSet,
        IReadOnlyCollection<PlateId>? specificPlates = null)
        : base(sourceSequence, mask, noDataValue)
    {
        _polygonSet = polygonSet;
        _specificPlates = specificPlates;
    }

    /// <inheritdoc />
    public PlatePolygonSet PolygonSet => _polygonSet;

    /// <inheritdoc />
    public IReadOnlyCollection<PlateId>? SpecificPlates => _specificPlates;
}


// --- PATH: plugins/Raster.Masking.Plate/PlatePolygonRasterMask.cs ---
using System.Collections.Immutable;
using FantaSim.Geosphere.Plate.Polygonization.Contracts.Products;
using FantaSim.Raster.Contracts;
using FantaSim.Raster.Contracts.Masking;
using FantaSim.Raster.Core;
using FantaSim.Geosphere.Plate.Topology.Contracts.Entities;
using UnifyGeometry;

namespace FantaSim.Raster.Masking.Plate;

/// <summary>
/// A mask based on plate polygons.
/// Pixels inside/outside plate boundaries are masked.
/// RFC-V2-0028 compliant.
/// </summary>
public sealed class PlatePolygonRasterMask : IRasterMask
{
    private readonly PlatePolygonSet _polygonSet;
    private readonly IReadOnlySet<PlateId>? _specificPlates;

    /// <summary>
    /// Creates a new PlatePolygonRasterMask.
    /// </summary>
    /// <param name="polygonSet">The polygon set containing plate boundaries.</param>
    /// <param name="specificPlates">Optional: limit masking to specific plates. If null, all plates are included.</param>
    public PlatePolygonRasterMask(
        PlatePolygonSet polygonSet,
        IReadOnlyCollection<PlateId>? specificPlates = null)
    {
        if (polygonSet.Polygons.IsDefaultOrEmpty)
            throw new ArgumentException("Polygon set cannot be empty", nameof(polygonSet));
        _polygonSet = polygonSet;
        _specificPlates = specificPlates?.ToHashSet();
    }

    /// <inheritdoc />
    public IRasterFrame ApplyMask(IRasterFrame sourceFrame, double noDataValue)
    {
        if (sourceFrame == null)
            throw new ArgumentNullException(nameof(sourceFrame));

        var rawData = sourceFrame.GetRawData();
        var sourceData = new double[rawData.Length / sizeof(double)];
        Buffer.BlockCopy(rawData.ToArray(), 0, sourceData, 0, rawData.Length);

        var maskedData = new double[sourceData.Length];

        for (int row = 0; row < sourceFrame.Height; row++)
        {
            for (int col = 0; col < sourceFrame.Width; col++)
            {
                var index = row * sourceFrame.Width + col;
                var value = sourceData[index];

                // Calculate geographic coordinates for this cell
                var lon = sourceFrame.Bounds.MinLongitude +
                    (col / (double)sourceFrame.Width) * sourceFrame.Bounds.Width;
                var lat = sourceFrame.Bounds.MaxLatitude -
                    (row / (double)sourceFrame.Height) * sourceFrame.Bounds.Height;

                // Check if point is in any plate polygon
                var inPlate = Contains(lon, lat);
                maskedData[index] = inPlate ? value : noDataValue;
            }
        }

        return new ArrayRasterFrame(
            sourceFrame.Tick,
            sourceFrame.Width,
            sourceFrame.Height,
            sourceFrame.Bounds,
            sourceFrame.DataType,
            maskedData,
            noDataValue);
    }

    /// <inheritdoc />
    public bool Contains(double longitude, double latitude)
    {
        if (_specificPlates != null)
        {
            foreach (var plateId in _specificPlates)
            {
                var polygon = _polygonSet.GetPolygon(plateId);
                if (polygon.HasValue && IsPointInPolygon(polygon.Value, longitude, latitude))
                {
                    return true;
                }
            }
            return false;
        }

        // Check all plates
        foreach (var polygon in _polygonSet.Polygons)
        {
            if (IsPointInPolygon(polygon, longitude, latitude))
            {
                return true;
            }
        }

        return false;
    }

    /// <summary>
    /// Determines if a point is inside a polygon (including holes) using the ray casting algorithm.
    /// </summary>
    private static bool IsPointInPolygon(PlatePolygon polygon, double lon, double lat)
    {
        // Check outer ring first
        if (!IsPointInRing(polygon.OuterRing, lon, lat))
            return false;

        // Check holes - if point is in any hole, it's outside the polygon
        foreach (var hole in polygon.Holes)
        {
            if (IsPointInRing(hole, lon, lat))
                return false;
        }

        return true;
    }

    /// <summary>
    /// Ray casting algorithm for point-in-polygon testing.
    /// </summary>
    private static bool IsPointInRing(Polyline3 ring, double lon, double lat)
    {
        var points = ring.Points;
        if (points.Length < 3)
            return false;

        bool inside = false;
        int j = points.Length - 1;

        for (int i = 0; i < points.Length; i++)
        {
            var vi = points[i];
            var vj = points[j];

            // Check if point is on vertex
            if (Math.Abs(vi.X - lon) < 1e-10 && Math.Abs(vi.Y - lat) < 1e-10)
                return true;

            // Check if edge straddles the horizontal line at y=lat
            bool intersect = ((vi.Y > lat) != (vj.Y > lat)) &&
                (lon < (vj.X - vi.X) * (lat - vi.Y) / (vj.Y - vi.Y + 1e-10) + vi.X);

            if (intersect)
                inside = !inside;

            j = i;
        }

        return inside;
    }
}


// --- PATH: plugins/Raster.Masking.Plate/PlatePolygonRasterMaskFactory.cs ---
using FantaSim.Geosphere.Plate.Polygonization.Contracts.Products;
using FantaSim.Geosphere.Plate.Polygonization.Contracts.Solvers;
using FantaSim.Raster.Contracts.Masking;
using FantaSim.Geosphere.Plate.Topology.Contracts.Derived;
using FantaSim.Geosphere.Plate.Topology.Contracts.Entities;
using Plate.TimeDete.Time.Primitives;

namespace FantaSim.Raster.Masking.Plate;

/// <summary>
/// Factory that creates plate polygon-based masks for a specific tick.
/// Encapsulates the polygonizer + topology lookup so callers don't need to manage tick-to-polygon mapping.
/// RFC-V2-0028 §3.3.
/// </summary>
/// <remarks>
/// <para>
/// This factory provides a single source of truth for "how to get plate polygons at tick T".
/// Callers simply request <c>CreateMask(tick)</c> and receive a ready-to-use mask.
/// </para>
/// <para>
/// For scenarios where the caller already has a <see cref="PlatePolygonSet"/>,
/// use <see cref="PlatePolygonRasterMask"/> directly.
/// </para>
/// </remarks>
public sealed class PlatePolygonRasterMaskFactory : ITickBoundRasterMaskFactory
{
    private readonly IPlatePolygonizer _polygonizer;
    private readonly IPlateTopologyStateView _topology;
    private readonly IReadOnlyCollection<PlateId>? _specificPlates;
    private readonly PolygonizationOptions? _polygonizationOptions;

    /// <summary>
    /// Creates a new PlatePolygonRasterMaskFactory.
    /// </summary>
    /// <param name="polygonizer">The polygonizer for extracting plate polygons.</param>
    /// <param name="topology">The topology state view.</param>
    /// <param name="specificPlates">Optional: limit masking to specific plates. If null, all plates are included.</param>
    /// <param name="polygonizationOptions">Optional: polygonization options.</param>
    public PlatePolygonRasterMaskFactory(
        IPlatePolygonizer polygonizer,
        IPlateTopologyStateView topology,
        IReadOnlyCollection<PlateId>? specificPlates = null,
        PolygonizationOptions? polygonizationOptions = null)
    {
        _polygonizer = polygonizer ?? throw new ArgumentNullException(nameof(polygonizer));
        _topology = topology ?? throw new ArgumentNullException(nameof(topology));
        _specificPlates = specificPlates;
        _polygonizationOptions = polygonizationOptions;
    }

    /// <summary>
    /// The polygonizer used to extract plate polygons.
    /// </summary>
    public IPlatePolygonizer Polygonizer => _polygonizer;

    /// <summary>
    /// The topology state view.
    /// </summary>
    public IPlateTopologyStateView Topology => _topology;

    /// <summary>
    /// The specific plates to include (null = all plates).
    /// </summary>
    public IReadOnlyCollection<PlateId>? SpecificPlates => _specificPlates;

    /// <inheritdoc />
    public IRasterMask CreateMask(CanonicalTick tick)
    {
        var polygonSet = _polygonizer.PolygonizeAtTick(tick, _topology, _polygonizationOptions);
        return new PlatePolygonRasterMask(polygonSet, _specificPlates);
    }
}


// --- PATH: plugins/Raster.Masking.Plate/RasterMaskFactory.cs ---
using FantaSim.Raster.Contracts;
using FantaSim.Raster.Contracts.Masking;
using FantaSim.Raster.Core;
using FantaSim.Geosphere.Plate.Polygonization.Contracts.Products;
using FantaSim.Geosphere.Plate.Topology.Contracts.Entities;

namespace FantaSim.Raster.Masking.Plate;

/// <summary>
/// Factory for creating masked raster sequences.
/// RFC-V2-0028 §8.2.2 compliant - composition layer that bridges raster + plates domains.
/// </summary>
/// <remarks>
/// Implements both domain-agnostic <see cref="IRasterMaskFactory"/> and
/// plate-specific <see cref="IPlateRasterMaskFactory"/>.
/// </remarks>
public sealed class RasterMaskFactory : IPlateRasterMaskFactory
{
    private const double DefaultNoDataValue = double.NaN;

    /// <inheritdoc />
    public IPlateMaskedRasterSequence CreatePlateMaskedSequence(
        IRasterSequence source,
        PlatePolygonSet polygonSet,
        IReadOnlyCollection<PlateId>? specificPlates = null)
    {
        if (source == null)
            throw new ArgumentNullException(nameof(source));

        var mask = new PlatePolygonRasterMask(polygonSet, specificPlates);
        return new PlateMaskedRasterSequence(source, mask, DefaultNoDataValue, polygonSet, specificPlates);
    }

    /// <inheritdoc />
    public IMaskedRasterSequence CreateBoundsMaskedSequence(
        IRasterSequence source,
        RasterBounds bounds)
    {
        if (source == null)
            throw new ArgumentNullException(nameof(source));

        var mask = new BoundsRasterMask(bounds, includeInterior: true);
        return new MaskedRasterSequence(source, mask, DefaultNoDataValue);
    }

    /// <summary>
    /// Creates a masked sequence that excludes points within the specified bounds.
    /// </summary>
    public IMaskedRasterSequence CreateBoundsExcludedSequence(
        IRasterSequence source,
        RasterBounds bounds)
    {
        if (source == null)
            throw new ArgumentNullException(nameof(source));

        var mask = new BoundsRasterMask(bounds, includeInterior: false);
        return new MaskedRasterSequence(source, mask, DefaultNoDataValue);
    }

    /// <inheritdoc />
    public IMaskedRasterSequence CreateCustomMaskedSequence(
        IRasterSequence source,
        IRasterMask mask,
        double noDataValue = double.NaN)
    {
        if (source == null)
            throw new ArgumentNullException(nameof(source));
        if (mask == null)
            throw new ArgumentNullException(nameof(mask));

        return new MaskedRasterSequence(source, mask, noDataValue);
    }
}


// --- PATH: plugins/Raster.Masking.Plate/TickBoundMaskedRasterSequence.cs ---
using System.Collections.Immutable;
using FantaSim.Geosphere.Plate.Polygonization.Contracts.Products;
using FantaSim.Raster.Contracts;
using FantaSim.Raster.Contracts.Masking;
using Plate.TimeDete.Time.Primitives;

namespace FantaSim.Raster.Masking.Plate;

/// <summary>
/// A raster sequence that applies tick-specific masking to frames.
/// Uses <see cref="ITickBoundRasterMaskFactory"/> to obtain the appropriate mask for each tick.
/// RFC-V2-0028 §3.3.
/// </summary>
/// <remarks>
/// <para>
/// Unlike <see cref="MaskedRasterSequence"/> which uses a single static mask,
/// this class requests a fresh mask for each tick from the factory.
/// This enables time-varying masks such as reconstructed plate polygons.
/// </para>
/// </remarks>
public sealed class TickBoundMaskedRasterSequence : IRasterSequence
{
    private readonly IRasterSequence _sourceSequence;
    private readonly ITickBoundRasterMaskFactory _maskFactory;
    private readonly double _noDataValue;

    /// <summary>
    /// Creates a new TickBoundMaskedRasterSequence.
    /// </summary>
    /// <param name="sourceSequence">The source raster sequence to mask.</param>
    /// <param name="maskFactory">Factory that creates tick-appropriate masks.</param>
    /// <param name="noDataValue">Value to use for masked-out pixels.</param>
    public TickBoundMaskedRasterSequence(
        IRasterSequence sourceSequence,
        ITickBoundRasterMaskFactory maskFactory,
        double noDataValue = double.NaN)
    {
        _sourceSequence = sourceSequence ?? throw new ArgumentNullException(nameof(sourceSequence));
        _maskFactory = maskFactory ?? throw new ArgumentNullException(nameof(maskFactory));
        _noDataValue = noDataValue;
    }

    /// <summary>
    /// The underlying (unmasked) raster sequence.
    /// </summary>
    public IRasterSequence SourceSequence => _sourceSequence;

    /// <summary>
    /// The mask factory used to create tick-specific masks.
    /// </summary>
    public ITickBoundRasterMaskFactory MaskFactory => _maskFactory;

    /// <summary>
    /// The no-data value used for masked pixels.
    /// </summary>
    public double NoDataValue => _noDataValue;

    /// <inheritdoc />
    public string SequenceId => $"{_sourceSequence.SequenceId}_tickmasked";

    /// <inheritdoc />
    public string DisplayName => $"{_sourceSequence.DisplayName} (Tick-Masked)";

    /// <inheritdoc />
    public ImmutableArray<CanonicalTick> AvailableTicks => _sourceSequence.AvailableTicks;

    /// <inheritdoc />
    public RasterMetadata Metadata => _sourceSequence.Metadata;

    /// <inheritdoc />
    public IRasterFrame? GetFrameAt(CanonicalTick tick)
    {
        var sourceFrame = _sourceSequence.GetFrameAt(tick);
        if (sourceFrame == null)
            return null;

        var mask = _maskFactory.CreateMask(tick);
        return mask.ApplyMask(sourceFrame, _noDataValue);
    }

    /// <inheritdoc />
    public RasterQueryResult QueryAt(CanonicalTick tick, RasterQueryOptions? options = null)
    {
        var sourceResult = _sourceSequence.QueryAt(tick, options);

        if (!sourceResult.HasData)
            return sourceResult;

        var frameData = sourceResult.FrameData!.Value;

        // Get mask for this specific tick
        var mask = _maskFactory.CreateMask(tick);

        // Apply mask to the frame data
        var tempFrame = new SimpleRasterFrame(
            frameData.Width,
            frameData.Height,
            frameData.Bounds,
            frameData.DataType,
            frameData.RawData,
            frameData.NoDataValue);

        var maskedFrame = mask.ApplyMask(tempFrame, _noDataValue);

        var rawData = maskedFrame.GetRawData().ToArray();
        var maskedData = new RasterFrameData(
            maskedFrame.Width,
            maskedFrame.Height,
            maskedFrame.Bounds,
            maskedFrame.DataType,
            maskedFrame.NoDataValue,
            rawData);

        if (sourceResult.IsInterpolated)
        {
            return RasterQueryResult.Interpolated(
                tick,
                sourceResult.SourceFrameTick ?? CanonicalTick.Genesis,
                sourceResult.InterpolationWeight ?? 0,
                maskedData);
        }

        return RasterQueryResult.Exact(tick, maskedData);
    }

    /// <inheritdoc />
    public IEnumerable<IRasterFrame> GetFramesInRange(CanonicalTick startTick, CanonicalTick endTick)
    {
        foreach (var tick in _sourceSequence.AvailableTicks.Where(t => t >= startTick && t <= endTick))
        {
            var frame = GetFrameAt(tick);
            if (frame != null)
                yield return frame;
        }
    }
}


// --- PATH: plugins/Raster.Registry/RasterSequenceLoaderRegistry.cs ---
using System.Collections.Concurrent;
using FantaSim.Raster.Contracts.Loading;

namespace FantaSim.Raster.Registry;

/// <summary>
/// Default implementation of IRasterSequenceLoaderRegistry.
/// Thread-safe registry for raster sequence loaders.
/// RFC-V2-0028 compliant.
/// </summary>
public sealed class RasterSequenceLoaderRegistry : IRasterSequenceLoaderRegistry
{
    private readonly ConcurrentDictionary<string, IRasterSequenceLoader> _loaders;
    private readonly object _lock = new();

    /// <summary>
    /// Creates a new RasterSequenceLoaderRegistry.
    /// </summary>
    public RasterSequenceLoaderRegistry()
    {
        _loaders = new ConcurrentDictionary<string, IRasterSequenceLoader>(StringComparer.OrdinalIgnoreCase);
    }

    /// <inheritdoc />
    public void Register(IRasterSequenceLoader loader)
    {
        ArgumentNullException.ThrowIfNull(loader);

        foreach (var format in loader.SupportedFormats)
        {
            _loaders[format.ToLowerInvariant()] = loader;
        }
    }

    /// <inheritdoc />
    public IRasterSequenceLoader? GetLoader(string format)
    {
        if (string.IsNullOrWhiteSpace(format))
            return null;

        return _loaders.TryGetValue(format.ToLowerInvariant(), out var loader) ? loader : null;
    }

    /// <summary>
    /// Gets all registered loaders.
    /// </summary>
    public IReadOnlyCollection<IRasterSequenceLoader> GetAllLoaders()
    {
        lock (_lock)
        {
            return _loaders.Values.Distinct().ToList();
        }
    }

    /// <summary>
    /// Gets all supported formats.
    /// </summary>
    public IReadOnlyCollection<string> GetSupportedFormats()
    {
        lock (_lock)
        {
            return _loaders.Keys.ToList();
        }
    }
}


// --- PATH: plugins/Space.Stellar.Solvers.Reference/ReferenceInsolationSolver.cs ---
using FantaSim.Space.Stellar.Contracts.Solvers;

namespace FantaSim.Space.Stellar.Solvers.Reference;

/// <summary>
/// Reference implementation of <see cref="IInsolationSolver"/>.
/// Implements inverse-square flux, solar geometry, and daily mean TOA insolation
/// with polar day/night handling.
/// </summary>
public sealed class ReferenceInsolationSolver : IInsolationSolver
{
    private const double HalfPi = 0.5 * Math.PI;

    public double CalculateSolarFlux(double starLuminosityW, double distanceM)
    {
        ValidateFinite(nameof(starLuminosityW), starLuminosityW);
        ValidateFinite(nameof(distanceM), distanceM);

        if (starLuminosityW <= 0)
            throw new ArgumentOutOfRangeException(nameof(starLuminosityW), starLuminosityW, "Must be > 0.");
        if (distanceM <= 0)
            throw new ArgumentOutOfRangeException(nameof(distanceM), distanceM, "Must be > 0.");

        // Flux = Luminosity / (4π r^2)
        return starLuminosityW / (4.0 * Math.PI * distanceM * distanceM);
    }

    public double CalculateDailyInsolation(double latitudeRad, double declinationRad, double solarConstant)
    {
        ValidateLatitude(nameof(latitudeRad), latitudeRad);
        ValidateDeclination(nameof(declinationRad), declinationRad);
        ValidateFinite(nameof(solarConstant), solarConstant);

        if (solarConstant < 0)
            throw new ArgumentOutOfRangeException(nameof(solarConstant), solarConstant, "Must be >= 0.");
        if (solarConstant == 0)
            return 0;

        double H0 = CalculateSunriseHourAngle(latitudeRad, declinationRad); // 0..π
        if (H0 <= 0)
            return 0;

        double sinPhi = Math.Sin(latitudeRad);
        double cosPhi = Math.Cos(latitudeRad);
        double sinDelta = Math.Sin(declinationRad);
        double cosDelta = Math.Cos(declinationRad);

        // Daily mean TOA insolation (averaged over 24h):
        // Q = (S0/π) * ( H0*sinφ*sinδ + cosφ*cosδ*sinH0 )
        double term = (H0 * sinPhi * sinDelta) + (cosPhi * cosDelta * Math.Sin(H0));
        double Q = (solarConstant / Math.PI) * term;

        return Q > 0 ? Q : 0;
    }

    public double CalculateSolarZenithAngle(double latitudeRad, double declinationRad, double hourAngleRad)
    {
        ValidateLatitude(nameof(latitudeRad), latitudeRad);
        ValidateDeclination(nameof(declinationRad), declinationRad);
        ValidateFinite(nameof(hourAngleRad), hourAngleRad);

        // cosZ = sinφ sinδ + cosφ cosδ cosH
        double sinPhi = Math.Sin(latitudeRad);
        double cosPhi = Math.Cos(latitudeRad);
        double sinDelta = Math.Sin(declinationRad);
        double cosDelta = Math.Cos(declinationRad);

        double cosZ = (sinPhi * sinDelta) + (cosPhi * cosDelta * Math.Cos(hourAngleRad));
        cosZ = Clamp(cosZ, -1.0, 1.0);
        return Math.Acos(cosZ);
    }

    public double CalculateDayLength(double latitudeRad, double declinationRad)
    {
        // Validation performed by CalculateSunriseHourAngle.
        double H0 = CalculateSunriseHourAngle(latitudeRad, declinationRad); // 0..π
        return 24.0 * H0 / Math.PI;
    }

    public double CalculateSunriseHourAngle(double latitudeRad, double declinationRad)
    {
        ValidateLatitude(nameof(latitudeRad), latitudeRad);
        ValidateDeclination(nameof(declinationRad), declinationRad);

        // cosH0 = -tanφ * tanδ
        double cosH0 = -Math.Tan(latitudeRad) * Math.Tan(declinationRad);

        // Polar night: no sunrise; Polar day: sun never sets.
        // Map to H0 in [0, π] so day length = 24 * H0 / π yields 0 or 24.
        if (cosH0 >= 1.0)
            return 0.0;
        if (cosH0 <= -1.0)
            return Math.PI;

        return Math.Acos(Clamp(cosH0, -1.0, 1.0));
    }

    private static void ValidateFinite(string paramName, double value)
    {
        if (double.IsNaN(value) || double.IsInfinity(value))
            throw new ArgumentOutOfRangeException(paramName, value, "Must be finite.");
    }

    private static void ValidateLatitude(string paramName, double latitudeRad)
    {
        ValidateFinite(paramName, latitudeRad);
        if (latitudeRad < -HalfPi || latitudeRad > HalfPi)
            throw new ArgumentOutOfRangeException(paramName, latitudeRad, "Must be in [-π/2, π/2].");
    }

    private static void ValidateDeclination(string paramName, double declinationRad)
    {
        ValidateFinite(paramName, declinationRad);
        if (declinationRad < -HalfPi || declinationRad > HalfPi)
            throw new ArgumentOutOfRangeException(paramName, declinationRad, "Must be in [-π/2, π/2].");
    }

    private static double Clamp(double value, double min, double max)
        => value < min ? min : (value > max ? max : value);
}


// --- PATH: plugins/Space.Stellar.Solvers.Reference/ReferenceOrbitSolver.cs ---
using FantaSim.Space.Stellar.Contracts.Mechanics;
using FantaSim.Space.Stellar.Contracts.Numerics;
using FantaSim.Space.Stellar.Contracts.Solvers;

namespace FantaSim.Space.Stellar.Solvers.Reference;

/// <summary>
/// Reference implementation of <see cref="IOrbitSolver"/> using Kepler's equation (elliptic, e in [0, 1)).
/// Deterministic Newton-Raphson iteration; no caching.
/// </summary>
public sealed class ReferenceOrbitSolver : IOrbitSolver
{
    private const int MaxKeplerIterations = 50;
    private const double KeplerTolerance = 1e-12;
    private const double TwoPi = 2.0 * Math.PI;

    public Vector3d CalculatePosition(OrbitalElements orbit, double centralMassKg, double timeS)
        => CalculateOrbitalState(orbit, centralMassKg, timeS).PositionM;

    public Vector3d CalculateVelocity(OrbitalElements orbit, double centralMassKg, double timeS)
        => CalculateOrbitalState(orbit, centralMassKg, timeS).VelocityMPerS;

    public OrbitalState CalculateOrbitalState(OrbitalElements orbit, double centralMassKg, double timeS)
    {
        ValidateCommonInputs(orbit, centralMassKg);
        if (double.IsNaN(timeS) || double.IsInfinity(timeS))
            throw new ArgumentOutOfRangeException(nameof(timeS), timeS, "Must be finite.");

        double mu = OrbitalMechanics.GravitationalConstant * centralMassKg;
        return CalculateOrbitalStateInternal(orbit, mu, timeS);
    }

    public double FindTimeAtTrueAnomaly(OrbitalElements orbit, double centralMassKg, double targetTrueAnomalyRad, double afterTimeS)
    {
        ValidateCommonInputs(orbit, centralMassKg);
        if (double.IsNaN(afterTimeS) || double.IsInfinity(afterTimeS))
            throw new ArgumentOutOfRangeException(nameof(afterTimeS), afterTimeS, "Must be finite.");
        if (double.IsNaN(targetTrueAnomalyRad) || double.IsInfinity(targetTrueAnomalyRad))
            throw new ArgumentOutOfRangeException(nameof(targetTrueAnomalyRad), targetTrueAnomalyRad, "Must be finite.");

        double a = orbit.SemiMajorAxisM;
        double e = orbit.Eccentricity;
        double mu = OrbitalMechanics.GravitationalConstant * centralMassKg;

        double n = Math.Sqrt(mu / Math.Pow(a, 3));
        double mAfter = GetMeanAnomalyAtTime(orbit, mu, afterTimeS);

        double nuTarget = NormalizeAngle(targetTrueAnomalyRad);
        double eTarget = TrueToEccentricAnomaly(nuTarget, e);
        double mTarget = NormalizeAngle(eTarget - e * Math.Sin(eTarget));

        double deltaM = NormalizeAngle(mTarget - mAfter);
        return afterTimeS + (deltaM / n);
    }

    public double MeanToTrueAnomaly(double meanAnomalyRad, double eccentricity)
    {
        if (double.IsNaN(meanAnomalyRad) || double.IsInfinity(meanAnomalyRad))
            throw new ArgumentOutOfRangeException(nameof(meanAnomalyRad), meanAnomalyRad, "Must be finite.");
        if (eccentricity < 0 || eccentricity >= 1)
            throw new ArgumentOutOfRangeException(nameof(eccentricity), eccentricity, "Must be in [0, 1).");

        double M = NormalizeAngle(meanAnomalyRad);
        double E = SolveKeplerEquation(M, eccentricity);
        return EccentricToTrueAnomaly(E, eccentricity);
    }

    public double TrueToEccentricAnomaly(double trueAnomalyRad, double eccentricity)
    {
        if (double.IsNaN(trueAnomalyRad) || double.IsInfinity(trueAnomalyRad))
            throw new ArgumentOutOfRangeException(nameof(trueAnomalyRad), trueAnomalyRad, "Must be finite.");
        if (eccentricity < 0 || eccentricity >= 1)
            throw new ArgumentOutOfRangeException(nameof(eccentricity), eccentricity, "Must be in [0, 1).");

        double nu = NormalizeAngle(trueAnomalyRad);

        // E = 2 * atan( sqrt((1-e)/(1+e)) * tan(ν/2) )
        double factor = Math.Sqrt((1.0 - eccentricity) / (1.0 + eccentricity));
        double E = 2.0 * Math.Atan(factor * Math.Tan(nu / 2.0));
        return NormalizeAngle(E);
    }

    private static void ValidateCommonInputs(OrbitalElements orbit, double centralMassKg)
    {
        if (!orbit.IsValid())
            throw new ArgumentOutOfRangeException(nameof(orbit), orbit, "Orbital elements are not valid.");
        if (double.IsNaN(orbit.LongitudeOfAscendingNodeRad) || double.IsInfinity(orbit.LongitudeOfAscendingNodeRad))
            throw new ArgumentOutOfRangeException(nameof(orbit), orbit, "LongitudeOfAscendingNodeRad must be finite.");
        if (double.IsNaN(orbit.ArgumentOfPeriapsisRad) || double.IsInfinity(orbit.ArgumentOfPeriapsisRad))
            throw new ArgumentOutOfRangeException(nameof(orbit), orbit, "ArgumentOfPeriapsisRad must be finite.");
        if (double.IsNaN(orbit.MeanAnomalyAtEpochRad) || double.IsInfinity(orbit.MeanAnomalyAtEpochRad))
            throw new ArgumentOutOfRangeException(nameof(orbit), orbit, "MeanAnomalyAtEpochRad must be finite.");
        if (double.IsNaN(orbit.EpochTimeS) || double.IsInfinity(orbit.EpochTimeS))
            throw new ArgumentOutOfRangeException(nameof(orbit), orbit, "EpochTimeS must be finite.");

        if (centralMassKg <= 0)
            throw new ArgumentOutOfRangeException(nameof(centralMassKg), centralMassKg, "Must be > 0.");
    }

    private static OrbitalState CalculateOrbitalStateInternal(OrbitalElements orbit, double mu, double timeS)
    {
        double a = orbit.SemiMajorAxisM;
        double e = orbit.Eccentricity;

        double Omega = NormalizeAngle(orbit.LongitudeOfAscendingNodeRad);
        double i = orbit.InclinationRad;
        double omega = NormalizeAngle(orbit.ArgumentOfPeriapsisRad);

        double M = GetMeanAnomalyAtTime(orbit, mu, timeS);
        double E = SolveKeplerEquation(M, e);
        double nu = EccentricToTrueAnomaly(E, e);

        double r = a * (1.0 - e * Math.Cos(E));
        double h = Math.Sqrt(mu * a * (1.0 - e * e));

        // Perifocal (orbital plane) position
        double xPqw = r * Math.Cos(nu);
        double yPqw = r * Math.Sin(nu);

        // Perifocal (orbital plane) velocity
        // vx = -μ/h * sin(ν)
        // vy =  μ/h * (e + cos(ν))
        double vxPqw = (-mu / h) * Math.Sin(nu);
        double vyPqw = (mu / h) * (e + Math.Cos(nu));

        Vector3d position = TransformToInertial(new Vector3d(xPqw, yPqw, 0.0), Omega, i, omega);
        Vector3d velocity = TransformToInertial(new Vector3d(vxPqw, vyPqw, 0.0), Omega, i, omega);

        return new OrbitalState(
            PositionM: position,
            VelocityMPerS: velocity,
            DistanceM: r,
            SpeedMPerS: velocity.Length(),
            TrueAnomalyRad: nu,
            EccentricAnomalyRad: E,
            MeanAnomalyRad: M,
            TimeS: timeS);
    }

    private static double GetMeanAnomalyAtTime(OrbitalElements orbit, double mu, double timeS)
    {
        double n = Math.Sqrt(mu / Math.Pow(orbit.SemiMajorAxisM, 3));
        double M0 = NormalizeAngle(orbit.MeanAnomalyAtEpochRad);
        return NormalizeAngle(M0 + n * (timeS - orbit.EpochTimeS));
    }

    /// <summary>
    /// Solve Kepler's equation M = E - e*sin(E) for E using Newton-Raphson iteration.
    /// </summary>
    private static double SolveKeplerEquation(double meanAnomalyRad, double eccentricity)
    {
        double M = WrapAngleSignedPi(meanAnomalyRad);

        // Initial guess: E ≈ M for small e, otherwise start near ±π.
        double E = eccentricity < 0.8
            ? M
            : (M >= 0.0 ? Math.PI : -Math.PI);

        for (int iter = 0; iter < MaxKeplerIterations; iter++)
        {
            double f = E - (eccentricity * Math.Sin(E)) - M;
            double df = 1.0 - (eccentricity * Math.Cos(E));
            double delta = f / df;
            E -= delta;

            if (Math.Abs(delta) < KeplerTolerance)
                return NormalizeAngle(E);
        }

        return NormalizeAngle(E);
    }

    private static double EccentricToTrueAnomaly(double eccentricAnomalyRad, double eccentricity)
    {
        // Stable atan2 form
        double sinE = Math.Sin(eccentricAnomalyRad);
        double cosE = Math.Cos(eccentricAnomalyRad);
        double denom = 1.0 - eccentricity * cosE;

        double sinNu = Math.Sqrt(1.0 - (eccentricity * eccentricity)) * sinE / denom;
        double cosNu = (cosE - eccentricity) / denom;
        return NormalizeAngle(Math.Atan2(sinNu, cosNu));
    }

    /// <summary>
    /// Transform from perifocal (orbital plane) to inertial frame using Ω (LAN), i, ω.
    /// Rotation: R3(Ω) * R1(i) * R3(ω)
    /// </summary>
    private static Vector3d TransformToInertial(Vector3d pqw, double Omega, double i, double omega)
    {
        double cosOmega = Math.Cos(Omega);
        double sinOmega = Math.Sin(Omega);
        double cosI = Math.Cos(i);
        double sinI = Math.Sin(i);
        double cosOmegaSmall = Math.Cos(omega);
        double sinOmegaSmall = Math.Sin(omega);

        double r11 = (cosOmega * cosOmegaSmall) - (sinOmega * sinOmegaSmall * cosI);
        double r12 = (-cosOmega * sinOmegaSmall) - (sinOmega * cosOmegaSmall * cosI);
        double r13 = sinOmega * sinI;

        double r21 = (sinOmega * cosOmegaSmall) + (cosOmega * sinOmegaSmall * cosI);
        double r22 = (-sinOmega * sinOmegaSmall) + (cosOmega * cosOmegaSmall * cosI);
        double r23 = -cosOmega * sinI;

        double r31 = sinOmegaSmall * sinI;
        double r32 = cosOmegaSmall * sinI;
        double r33 = cosI;

        return new Vector3d(
            (r11 * pqw.X) + (r12 * pqw.Y) + (r13 * pqw.Z),
            (r21 * pqw.X) + (r22 * pqw.Y) + (r23 * pqw.Z),
            (r31 * pqw.X) + (r32 * pqw.Y) + (r33 * pqw.Z));
    }

    /// <summary>Normalize angle to [0, 2π).</summary>
    private static double NormalizeAngle(double angle)
    {
        angle %= TwoPi;
        if (angle < 0.0)
            angle += TwoPi;
        return angle;
    }

    /// <summary>Wrap angle to (-π, π].</summary>
    private static double WrapAngleSignedPi(double angle)
    {
        angle = NormalizeAngle(angle);
        return angle > Math.PI ? angle - TwoPi : angle;
    }
}

