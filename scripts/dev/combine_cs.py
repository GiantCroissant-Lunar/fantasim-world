#!/usr/bin/env python3
"""
Combine all C# source files under project/ into a single file.

Usage:
    python scripts/combine_cs.py [--exclude-tests]

Output:
    scripts/combined_all_cs.cs
"""

import argparse
import os
from datetime import datetime, timezone
from pathlib import Path


def should_skip_dir(dir_name: str) -> bool:
    """Check if directory should be skipped."""
    skip_names = {"bin", "obj", ".git"}
    # Skip hidden directories (starting with .)
    if dir_name.startswith("."):
        return True
    return dir_name in skip_names


def should_skip_file(file_name: str) -> bool:
    """Check if file should be skipped."""
    # Skip hidden files (starting with .)
    if file_name.startswith("."):
        return True
    return False


def find_cs_files(root_dir: Path, exclude_tests: bool = False) -> list[Path]:
    """Recursively find all .cs files under root_dir."""
    cs_files = []

    for dirpath, dirnames, filenames in os.walk(root_dir):
        # Filter out directories to skip
        dirnames[:] = [d for d in dirnames if not should_skip_dir(d)]

        for filename in filenames:
            if should_skip_file(filename):
                continue
            if filename.lower().endswith(".cs"):
                file_path = Path(dirpath) / filename
                rel_path = file_path.relative_to(root_dir).as_posix()

                # Skip test files if --exclude-tests is set
                if exclude_tests and rel_path.lower().startswith("tests/"):
                    continue

                cs_files.append(file_path)

    return cs_files


def main() -> int:
    """Main entry point."""
    # Parse command-line arguments
    parser = argparse.ArgumentParser(
        description="Combine all C# source files under project/ into a single file."
    )
    parser.add_argument(
        "--exclude-tests",
        action="store_true",
        help="Exclude files in the project/tests/ directory",
    )
    args = parser.parse_args()

    # Determine paths
    script_dir = Path(__file__).parent.resolve()
    workspace_root = script_dir.parent
    project_dir = workspace_root / "project"
    output_file = script_dir / "combined_all_cs.cs"

    if not project_dir.exists():
        print(f"Error: Project directory not found: {project_dir}")
        return 1

    # Find all .cs files
    cs_files = find_cs_files(project_dir, exclude_tests=args.exclude_tests)

    # Sort by relative POSIX path for deterministic output
    cs_files.sort(key=lambda p: p.relative_to(project_dir).as_posix())

    # Generate timestamp
    timestamp = datetime.now(timezone.utc).strftime("%Y-%m-%dT%H:%M:%SZ")

    # Build output content
    lines: list[str] = []

    # Header
    lines.append(f"// Generated by combine_cs.py on {timestamp}")
    lines.append("// Source root: project/")
    if args.exclude_tests:
        lines.append("// Tests excluded: yes")
    lines.append("")

    skipped_count = 0
    processed_count = 0

    for cs_file in cs_files:
        rel_path = cs_file.relative_to(project_dir).as_posix()

        # Read file content - try multiple encodings
        content = None
        encodings = ["utf-8", "utf-8-sig", "windows-1252", "latin-1", "iso-8859-1"]

        try:
            for encoding in encodings:
                try:
                    content = cs_file.read_text(encoding=encoding)
                    if encoding != "utf-8":
                        print(f"Info: Read {rel_path} using {encoding} encoding")
                    break
                except UnicodeDecodeError:
                    continue

            if content is None:
                print(f"Warning: Skipping file - could not decode with any encoding: {rel_path}")
                skipped_count += 1
                continue
        except OSError as e:
            print(f"Warning: Skipping file due to read error: {rel_path} ({e})")
            skipped_count += 1
            continue

        # Add file separator and content
        lines.append(f"// --- PATH: {rel_path} ---")
        lines.append(content)
        lines.append("")  # Blank line after each file
        processed_count += 1

    # Write output file
    output_content = "\n".join(lines)
    output_file.write_text(output_content, encoding="utf-8")

    # Print summary message
    if args.exclude_tests:
        print(f"Combined {processed_count} files (tests excluded) into {output_file}")
    else:
        print(f"Combined {processed_count} files into {output_file}")
    if skipped_count > 0:
        print(f"Skipped {skipped_count} file(s) due to read/decode errors")

    return 0


if __name__ == "__main__":
    raise SystemExit(main())
